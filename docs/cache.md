# Кеш додатка

- [Вступ](#introduction)
- [Налаштування](#configuration)
  - [Попередня підготовка драйверів](#driver-prerequisites)
- [Використання кеша](#cache-usage)
  - [Отримання екземпляра кеша](#obtaining-a-cache-instance)
  - [Отримання елементів з кеша](#retrieving-items-from-the-cache)
  - [Збереження елементів в кеші](#storing-items-in-the-cache)
  - [Видалення елементів з кеша](#removing-items-from-the-cache)
  - [Глобальний помічник кеша](#the-cache-helper)
- [Тегований кеш](#cache-tags)
  - [Зберігання тегованих елементів кеша](#storing-tagged-cache-items)
  - [Доступ до елементів тегованого кеша](#accessing-tagged-cache-items)
  - [Видалення елементів тегованого кеша](#removing-tagged-cache-items)
- [Атомарні блокування](#atomic-locks)
  - [Попередня підготовка драйверів](#lock-driver-prerequisites)
  - [Керування блокуваннями](#managing-locks)
  - [Керування блокуваннями між процесами](#managing-locks-across-processes)
- [Додавання власних драйверів кеша](#adding-custom-cache-drivers)
  - [Написання драйверів](#writing-the-driver)
  - [Реєстрація драйвера кеша](#registering-the-driver)
- [Події](#events)

<a name="introduction"></a>

## Вступ

Деякі завдання по відновленню чи опрацюванню даних, які виконуються вашим додатоком, можуть інтенсивно навантажувати CPU або тривати декілька секунд. У цьому випадку прийнято кешувати отримані дані на певний час, що дозволить швидко отримати їх у наступних запитах. Кешовані дані зазвичай зберігаються в дуже швидкому сховищі даних, наприклад [Memcached](https://memcached.org) або [Redis](https://redis.io).

На щастя, Laravel надає виразний, уніфікований API для різних серверних модулів кеша, що дозволяє вам скористатися перевагами надзвичайно швидкого отримання даних і прискорити веб-додаток.

<a name="configuration"></a>

## Налаштування

Конфігураційний файл кеша вашого додатка росташований в `config/cache.php`. У цьому файлі ви можете визначити, який драйвер кеша ви хочете використовувати за замовчуванням у вашому додатку. Laravel підтримує з коробки такі популярні серверні модулі кешування як [Memcached](https://memcached.org), [Redis](https://redis.io), [DynamoDB](https://aws.amazon.com/dynamodb), і реляційні бази даних. Крім того, доступний драйвер кеша на основі файлів, в той же час як драйвери `array` і `null` забезпечують зручні серверні модулі кешування для ваших автоматизованих тестів.

Конфігураційний файл кеша також містить різні інші параметри, які задокументовані у файлі, тому обов’язково прочитайте ці параметри. За замовчуванням Laravel налаштовано на використання `file` драйвера кеша, який зберігає серіалізовані кешовані об’єкти у файловій системі сервера. Для великих додатків рекомендується використовувати більш надійний драйвер, наприклад Memcached або Redis. Ви навіть можете налаштувати декілька конфігурацій кеша для одного драйвера.

<a name="driver-prerequisites"></a>

### Попередня підготовка драйверів

<a name="prerequisites-database"></a>

#### База даних

Коли використовувається драйвер кеша `database`, вам потрібно визначити таблицю для збереження елементів кеша. Ви знайдете приклад `Schema` визначення потрібної таблиці нижче:

```php
Schema::create('cache', function (Blueprint $table) {
    $table->string('key')->unique();
    $table->text('value');
    $table->integer('expiration');
});
```

> **Note**  
> Ви також можете використовувати команду Artisan `php artisan cache:table`, щоб згенерувати відповідну схему міграції.

<a name="memcached"></a>

#### Memcached

Щоб використовувати драйвер Memcached, потрібно встановити [пакунок Memcached PECL](https://pecl.php.net/package/memcached). Ви можете перерахувати всі свої сервери Memcached у конфігураційному файлі `config/cache.php`. Цей файл вже містить запис `memcached.servers` для початку:

    'memcached' => [
        'servers' => [
            [
                'host' => env('MEMCACHED_HOST', '127.0.0.1'),
                'port' => env('MEMCACHED_PORT', 11211),
                'weight' => 100,
            ],
        ],
    ],

За потреби ви можете встановити шлях параметру `host` сокета UNIX. Якщо ви це зробите, параметр `port` має бути встановлений на `0`:

    'memcached' => [
        [
            'host' => '/var/run/memcached/memcached.sock',
            'port' => 0,
            'weight' => 100
        ],
    ],

<a name="redis"></a>

#### Redis

Перед використанням кеша Redis разом з Laravel, вам потрібно буде встановити розширення PHP `PhpRedis` через PECL, або встановити пакунок `predis/predis` (~1.0) за допомогою Composer. [Laravel Sail](sail.md) вже включає це розширення. Крім того офіційні платформи розгортання такі як [Laravel Forge](https://forge.laravel.com) та [Laravel Vapor](https://vapor.laravel.com) вже мають за замовчуванням встановлене розширення PhpRedis.

Щоб дізнатися більше про налаштування Redis перегляньте цю [сторінку документації Laravel](redis.md#configuration).

<a name="dynamodb"></a>

#### DynamoDB

Перед тим як використовувати драйвер кеша [DynamoDB](https://aws.amazon.com/dynamodb), вам потрібно створити таблицю DynamoDB для того, щоб зберігати всі кешовані дані. Однак, вам потрібно буде назвати таблицю на основі конфігураційного значення `stores.dynamodb.table` у вашому конфігураційному файлі `cache.php` вашого додатка.

Також дана таблиця повинна мати ключ розділу рядка з іменем, яке відповідає значенню елемента конфігурації `stores.dynamodb.attributes.key` у вашому конфігураційному файлі `cache.php` вашого додатка. За замовчування ключ розділу повинен назватись як `key`.

<a name="cache-usage"></a>

## Використання кеша

<a name="obtaining-a-cache-instance"></a>

### Отримання екземпляра кеша

Для отримання збереженого екземпляра кеша, ви можете використовувати фада `Cache`, який ми будему використовувати всюди у цій документації. Фасад `Cache` надає зручний, стислий доступ до основних реалізацій контрактів кеша Laravel:

```php
<?php

namespace App\Http\Controllers;

use Illuminate\Support\Facades\Cache;

class UserController extends Controller
{
    /**
     * Показати список всіх користувачів додатка.
     *
     * @return Response
     */
    public function index()
    {
        $value = Cache::get('key');

        //
    }
}
```

<a name="accessing-multiple-cache-stores"></a>

#### Доступ до декількох сховищ кеша

Використовуючи фасад `Cache`, ви можете отримати доступ до різних сховищ кеша за допомогою метода `store`. Ключ переданий методу `store`, повинен відповідати одному з перерахованих ключів сховища `stores` у конфігураційному масиві вашого конфігураційного файла `cache.php`:

```php
$value = Cache::store('file')->get('foo');

Cache::store('redis')->put('bar', 'baz', 600); // 10 Minutes
```

<a name="retrieving-items-from-the-cache"></a>

### Отримання елементів з кеша

Метод `get` фасада `Cache` використовується для отримання елементів з кеша. Якщо елемент не існує в кеші, буде повернуто `null`.
За бажанням ви можете передати другий аргумент методу `get` визначаючи таким чином значення, яке буде повернуто за замовчуванням, якщо елемент не існує:

```php
$value = Cache::get('key');

$value = Cache::get('key', 'default');
```

Ви навіть можете передати замикання як значення за замовучуванням. Результат замикання буде повернуто, якщо зазначений елемент відсутній в кеші. Передавання замикання дозволяє вам відкласти отримання значеннь за замовчуванням з бази даних або інших зовнішніх служб:

```php
    $value = Cache::get('key', function () {
        return DB::table(/* ... */)->get();
    });
```

<a name="checking-for-item-existence"></a>

#### Перевірка наявності елемента

Метод `has` може використовуватись, щоб визначити чи існує елемент в кеші. Також цей метод повертатиме `false`, якщо елемент існує, але його значення визначене як `null`:

```php
if (Cache::has('key')) {
    //
}
```

<a name="incrementing-decrementing-values"></a>

#### Збільшення та зменьшення значення в кеші

Методи `increment` та `decrement` можуть використовуватись для коригування цілочисленного значення елементів в кеші. Також обидва методи приймають необов'язковий другий аргумент який визначатиме суму для збільшення або зменьшення значень елементів:

```php
Cache::increment('key');
Cache::increment('key', $amount);
Cache::decrement('key');
Cache::decrement('key', $amount);
```

<a name="retrieve-store"></a>

#### Отримання і збереження

Іноді ви можете захотіти отримати елемент з кеша, а також зберегти значення за замовчуванням, якщо запитуваний елемент не існує. На приклад, ви можете захотіти отримати всіх користувачів з кеша або, якщо вони не існують, отримати їх з бази даних та додати їх до кешу. Ви можете зробити це використовуючи метод `Cache::remember`:

```php
$value = Cache::remember('users', $seconds, function () {
    return DB::table('users')->get();
});
```

Якщо елемент не існує в кеші, замикання передане методу `remember` буде виконане та його результат буде розміщений в кеші.

Ви можете використовувати метод `rememberForever` для отримання елемента з кеша або зберегти його назавжди, якщо він не існує:

```php
$value = Cache::rememberForever('users', function () {
    return DB::table('users')->get();
});
```

<a name="retrieve-delete"></a>

#### Отримання з видаленням

Якщо вам потрібно отримати елемент з кеша та одразу видалити цей елемент, ви можете використати метод `pull`. Так само як з методом `get`, буде повернуто `null`, якщо елемент не існує в кеші:

```php
$value = Cache::pull('key');
```

<a name="storing-items-in-the-cache"></a>

### Збереження елементів в кеші

Ви можете використати метод `put` фасада `Cache` для збереження елементів в кеші:

```php
    Cache::put('key', 'value', $seconds = 10);
```

Якщо час зберігання елемента не переданий до метода `put`, елемент буде збережений на невизначений термін:

```php
Cache::put('key', 'value');
```

Замість передавання кількості секунд цілими числоми, ви також можете передати представлення екземпляра `DateTime`, як бажаний термін збереження для кешованого елемента:

```php
Cache::put('key', 'value', now()->addMinutes(10));
```

<a name="store-if-not-present"></a>

#### Збереження значень за умови їх відсутності

Метод `add` додасть елемент до кеша лише, якщо він, відсутній в сховищі кеша. Цей метод поверне `true`, якщо елемент дійсно доданий до кеша. В іншому випадку, метод поверне `false`. Метод `add` є [атомарною операцією](https://uk.wikipedia.org/wiki/Атомарна_операція).

```php
Cache::add('key', 'value', $seconds);
```

<a name="storing-items-forever"></a>

#### Збереження елементів на постійній основі

Метод `forever` може використовуватись для збереження елемента в кеші на постійній основі. Оскільки ці елементи не мають терміну збереження, вони повинні видалятись в ручну з кеша за допомогою метода `forget`:

```php
Cache::forever('key', 'value');
```

> **Note**  
> Якщо ви використовуєте драйвер Memcached, елементи які збережені "на постійній основі" можуть видалятись коли розмір кеша досягне обмеження.

<a name="removing-items-from-the-cache"></a>

### Видалення елементів з кеша

Ви можете видалити елементи з кеша використовуючи метод `forget`:

```php
Cache::forget('key');
```

Ви також можете видалити елементи надавши нуль або від'ємну кількість секунд збереження:

```php
Cache::put('key', 'value', 0);

Cache::put('key', 'value', -5);
```

Ви можете очистити весь кеш використовуючи метод `flush`:

```php
Cache::flush();
```

> **Warning**  
> Очищення кеша не враховує ваш налаштований "префікс" кеша і буде видаляти всі записи з кеша. Уважно враховуйте це під час очищення кеша, який використовується іншими додатками

<a name="the-cache-helper"></a>

### Кеш помічник

Крім того використання фасада `Cache`, ви також можете використовувати глобальну функцію `cache` для отримання та збереження даних через кеш. Коли функція `cache` викликана з единим рядковим аргументом, вона поверне значення за вказаним ключем:

```php
$value = cache('key');
```

Якщо ви надаєте функції масив пари ключ / значення, та час терміну збереження, вона збереже значення в кеші на визначений термін.

```php
cache(['key' => 'value'], $seconds);

cache(['key' => 'value'], now()->addMinutes(10));
```

Коли функція `cache` викликається без будьяких аргументів, то вона повертає реалізацію екземпляра `Illuminate\Contracts\Cache\Factory`, що дозволяє вам викликати інші методи кешування.

```php
cache()->remember('users', $seconds, function () {
    return DB::table('users')->get();
});
```

> **Note**  
> Під час тестування глобальної функції `cache`, ви можете використовувати метод `Cache::shouldReceive` так само, якщоб ви тестували фасад [тестували фасад](mocking.md#mocking-facades).

<a name="cache-tags"></a>

## Тегований кеш

> **Warning**  
> Теги кеша не підримується під час використання таких драйверів кешуання `file`, `dynamodb` або `database`. Крім того, при використанні декількох тегів з кешами, які зберігаються на постійній основі, матимуть найкращу продуктивність з таким драйвером як `memcached`, який автоматично очищує застарілі записи.

<a name="storing-tagged-cache-items"></a>

### Збереження тегованих елементів в кеш

Теги кеша дозволяють вам позначити пов'язані елементи в кеші, а потім очистити всі кешовані значення яким було призначено даний тег.
Ви можете отримати доступ до тегованого кеша передаючи впорядкований масив імен тегів. Елементи збережені за допомогою тегів, не можуть бути отримані без надання тегів, які використовувалися під час збереження елементів. Наприклад, давайте визначемо тегований кеш і покладемо `put` значення в кеш.

```php
Cache::tags(['people', 'artists'])->put('John', $john, $seconds);

Cache::tags(['people', 'authors'])->put('Anne', $anne, $seconds);
```

<a name="accessing-tagged-cache-items"></a>

### Доступ до тегованих елементів кеша

Для отримання тегованих елементів кеша, передайте той самий визначений список тегів в метод `tags` і потім викличте метод `get` з ключем за яким бажаєте отримати тегований елемент.

```php
$john = Cache::tags(['people', 'artists'])->get('John');

$anne = Cache::tags(['people', 'authors'])->get('Anne');
```

<a name="removing-tagged-cache-items"></a>

### Видалення тегованих елементів з кеша

Ви можете очистити всі елементи, яким призначено тег або список тегів. Наприклад, дане визначення очистить весь тегований кеш за будь-яким з даних тегів `people`, `authors` або за обома зразу. Отже, `Anne` та `John` будуть видалені з кеша.

```php
Cache::tags(['people', 'authors'])->flush();
```

Навідміну від попереднього визначення, наступний приклад видалить лише кешовані теговані значення по тегу `authors`, тобто буде видалено лише `Anne` а не `John`:

```php
Cache::tags('authors')->flush();
```

<a name="atomic-locks"></a>

## Атомарні блокування

> **Warning**  
> Щоб використовувати даний функціонал, ваш додаток повинен використовувати наступні драйвери кеша `memcached`, `redis`, `dynamodb`, `database`, `file`, або `array` як драйвери кеша за замовчування. Крім того, всі сервери повинні взаємодіяти з єдиним центральним кеш сервером.

<a name="lock-driver-prerequisites"></a>

### Попередня підготовка драйверів

<a name="atomic-locks-prerequisites-database"></a>

#### База даних

Під час використання драйвера кеша `database`, вам потрібно створити таблицю для зберігання блокувань кеша вашого додатка. Нижче ви знайдете приклад `Schema` визначення потрібної таблиці:

```php
Schema::create('cache_locks', function ($table) {
    $table->string('key')->primary();
    $table->string('owner');
    $table->integer('expiration');
});
```

<a name="managing-locks"></a>

### Керування блокуваннями

Атомарні блокування дозволяють маніпулювати розподіленими блокуваннями без турботи про умови преорітету. Наприклад, [Laravel Forge](https://forge.laravel.com) використовує атомарні блокування, щоб гарантувати, що на сервері одночасно виконується лише одне віддалене завдання. Ви можете створити і керувати блокуваннями використовуючи метод `Cache::lock`:

```php
use Illuminate\Support\Facades\Cache;

$lock = Cache::lock('foo', 10);

if ($lock->get()) {
    // Блокування отримано на 10 секунд...

    $lock->release();
}
```

Також метод `get` приймає замикання. Після виконання замикання, Laravel автоматинчно звільнить блокування:

```php
Cache::lock('foo')->get(function () {
    // Блокування отримано на невизначений термін і автоматично звільнено...
});
```

Якщо блокуваня недоступне в момент, коли ви його запитуєте, ви можете вказати Laravel чекати визначену кількість секунд. Якщо блокування не може бути отримане протягом визначеного часу, буде викинуто виняток `Illuminate\Contracts\Cache\LockTimeoutException`:

```php
use Illuminate\Contracts\Cache\LockTimeoutException;

$lock = Cache::lock('foo', 10);

try {
    $lock->block(5);

    // Блокування отримано після очікування максимум 5 секунд...
} catch (LockTimeoutException $e) {
    // Неможливо отримати блокування...
} finally {
    optional($lock)->release();
}
```

Приклад вище може бути спрощений за допомогою переданого замикання методу `block`. Коли замикання передається до цього метода, Laravel спробує отримати блокування протягом вказаної кількості секунд і автоматично зніме блокування після виконання замикання:

```php
Cache::lock('foo', 10)->block(5, function () {
    // Блокування отримано після очікування максимум 5 секунд...
});
```

<a name="managing-locks-across-processes"></a>

### Керування блокуваннями між процесами

Іноді, вам може захотітися отримати блокування в одному процесі і звільнити його в іншому процесі. Наприклад, ви можете отримати блокування протягом web-запита і звільнити це блокування в кінці завдання в черзі, яке буде ініційоване цим запитом. В даному сценарії ви повинні передати «токен власника» блокування до завдання в черзі, щоб завдання могло повторно створити екземпляр блокування за допомогою заданого токена.

В прикладі нижче, ми будемо відправляти завдання в чергу, якщо буде успішно отримано блокування. Крім того, ми будемо передавати токен власника блокування завданню в черзі за допомогою метода `owner`.

```php
$podcast = Podcast::find($id);

$lock = Cache::lock('processing', 120);

if ($lock->get()) {
    ProcessPodcast::dispatch($podcast, $lock->owner());
}
```

В межах завдання `ProcessPodcast` вашого додатка, ми можемо відновити та звільнити блокування за допомогою токена власника:

```php
Cache::restoreLock('processing', $this->owner)->release();
```

Якщо ви бажаєте звільнити блокування оминувши його поточного власника, ви можете використати метод `forceRelease`:

```php
Cache::lock('processing')->forceRelease();
```

<a name="adding-custom-cache-drivers"></a>

## Додавання власних драйверів кеша

<a name="writing-the-driver"></a>

### Написання драйвера

По перше, щоб створити ваш власний драйвер кеша, нам потрібно реалізувати [контракт](contracts.md) `Illuminate\Contracts\Cache\Store`. Отже, реалізація кеша MongoDB може виглядати приблизно так:

```php
<?php

namespace App\Extensions;

use Illuminate\Contracts\Cache\Store;

class MongoStore implements Store
{
    public function get($key) {}
    public function many(array $keys) {}
    public function put($key, $value, $seconds) {}
    public function putMany(array $values, $seconds) {}
    public function increment($key, $value = 1) {}
    public function decrement($key, $value = 1) {}
    public function forever($key, $value) {}
    public function forget($key) {}
    public function flush() {}
    public function getPrefix() {}
}
```

Нам просто потрібно реалізувати кожний з цих методів використовуючи підключення MongoDB. Щоб отримати приклаж, як реалізувати кожний з цих методв, можна розглянути клас `Illuminate\Cache\MemcachedStore` у [початковому коді фреймворка Laravel](https://github.com/laravel/framework). Як тільки наша реалізація буде завершена, ми пожему завершити реєстрацію нашого власного драйвера викликавши метод `extend` фасада `Cache`:

```php
Cache::extend('mongo', function ($app) {
    return Cache::repository(new MongoStore);
});
```

> **Note**  
> Якщо вас цікавить куди б покласти ващ власний код драйвера кеша, ви можете створити простір імен `Extensions` в середині вашого каталогу `app`. Однак майте на увазі, що Laravel не має жорсткої структури додатка і ви можете організувати свій додаток відповідно до своїх побажань.

<a name="registering-the-driver"></a>

### Реєстрація драйвера

Щоб зареєструвати власний драйвера кеша в Laravel, нам потрібно буде використати метод `extend` фасада `Cache`. Оскільки інші постачальники служб можуть спробувати прочитати кешовані значення в своєму методі `boot`, ми зареєструємо наш власний драйвер кеша в замиканні `booting`. Використовуючи замикання `booting`, ми можемо гарантувати, що власний драйвер буде зареєстровано безпосередньо перед викликом метода `boot` постачальником служб нашого додатка, але після виклику метода `register` для всіх постачальників служб. Ми зареєструємо замикання `booting` в методі `register` класа `App\Providers\AppServiceProvider` нашого додатка:

```php
<?php

namespace App\Providers;

use App\Extensions\MongoStore;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\ServiceProvider;

class CacheServiceProvider extends ServiceProvider
{
    /**
     * Зареєструйте будь-які сервіси додатків.
     *
     * @return void
     */
    public function register()
    {
        $this->app->booting(function () {
            Cache::extend('mongo', function ($app) {
                return Cache::repository(new MongoStore);
            });
        });
    }

    /**
     * Завантажте будь-які служби додатків.
     *
     * @return void
     */
    public function boot()
    {
        //
    }
}
```

Перший переданий аргумент методу `extend` має бути ім'я драрайвера. Це ім'я відповідатиме параметрам драйвера в конфігураційному файлі `config/cache.php`. Наступний аргумент має бути замикання, яке повинно повертати екземпляр `Illuminate\Cache\Repository`. Замиканню буде передано екземпляр `$app` [контейнера послуг](container.md).

Як тільки ваше розширення буде зареєстровано, оновіть ваш параметр `driver` в конфігураційному файлі `config/cache.php` на ім'я вашого розширення.

<a name="events"></a>

## Події

Щоб виконати будь-який код під час кожної операції кешування, ви можете прослухати події, викликані кешем. Як правило, вам потріно буде розмістити слухачів подій в класі вашого `App\Providers\EventServiceProvider` дадатка:

```php
/**
 * Мапа слухачів подій для вашого додатка.
 *
 * @var array
 */
protected $listen = [
    'Illuminate\Cache\Events\CacheHit' => [
        'App\Listeners\LogCacheHit',
    ],

    'Illuminate\Cache\Events\CacheMissed' => [
        'App\Listeners\LogCacheMissed',
    ],

    'Illuminate\Cache\Events\KeyForgotten' => [
        'App\Listeners\LogKeyForgotten',
    ],

    'Illuminate\Cache\Events\KeyWritten' => [
        'App\Listeners\LogKeyWritten',
    ],
];
```
