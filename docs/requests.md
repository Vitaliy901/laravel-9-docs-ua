# HTTP-запити

- [Вступ](#introduction)
- [Взаємодія із запитом](#interacting-with-the-request)
  - [Доступ до запита](#accessing-the-request)
  - [Шлях запита, хост і метод](#request-path-and-method)
  - [Заголовки запитів](#request-headers)
  - [IP-адреса Запита](#request-ip-address)
  - [Узгодження вмісту](#content-negotiation)
  - [PSR-7 Запити](#psr7-requests)
- [Дані полів введення](#input)
  - [Отримання вхідних даних](#retrieving-input)
  - [Визначення наявності необхідних даних](#determining-if-input-is-present)
  - [Об’єднання додаткових вхідних даних](#merging-additional-input)
  - [Дані минулого запита](#old-input)
  - [Файли Cookies](#cookies)
  - [Обрізання та нормалізація значень полів уведення](#input-trimming-and-normalization)
- [Файли](#files)
  - [Отримання завантажених файлів](#retrieving-uploaded-files)
  - [Зберігання завантажених файлів](#storing-uploaded-files)
- [Налаштування довірених проксі](#configuring-trusted-proxies)
- [Налаштування довірених хостів](#configuring-trusted-hosts)

<a name="introduction"></a>

## Вступ

Клас `Illuminate\Http\Request` Laravel забезпечує об’єктно-орієнтований спосіб взаємодії з поточним HTTP-запитом, який обробляє ваш додаток, а також отримання вхідних даних з полів введення, файлів cookie та файлів, надісланих із запитом.

<a name="interacting-with-the-request"></a>

## Взаємодія із запитом

<a name="accessing-the-request"></a>

### Доступ до запиту

Щоб отримати екземпляр поточного запиту HTTP за допомогою ін’єкції залежностей, вам слід оголосити тип класу `Illuminate\Http\Request` у методі замикання маршруту або контролера. Екземпляр вхідного запиту буде автоматично впроваджено [контейнером служби](container.md) Laravel:

```php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class UserController extends Controller
{
	/**
	 * Зберегти нового користувача.
	 *
	 * @param  \Illuminate\Http\Request  $request
	 * @return \Illuminate\Http\Response
	 */
	public function store(Request $request)
	{
		$name = $request->input('name');

		//
	}
}
```

Як зазнячалося, ви також можете оголосити тип класу `Illuminate\Http\Request` у замиканні маршруту. Контейнер служб автоматично додасть вхідний запит до замикання під час його виконання:

```php
use Illuminate\Http\Request;

Route::get('/', function (Request $request) {
	//
});
```

<a name="dependency-injection-route-parameters"></a>

#### Впровадження залежностей і параметри маршруту

Якщо ваш метод контролера також очікує параметри маршруту, ви повинні вказати параметри маршруту після інших залежностей. Наприклад, якщо ваш маршрут визначено так:

```php
use App\Http\Controllers\UserController;

Route::put('/user/{id}', [UserController::class, 'update']);
```

Ви, як і раніше, можете оголосити `Illuminate\Http\Request` і отримати доступ до параметра `id` маршруту, визначивши метод контролера так:

```php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class UserController extends Controller
{
	/**
	 * Оновити конкретного користувача.
	 *
	 * @param  \Illuminate\Http\Request  $request
	 * @param  string  $id
	 * @return \Illuminate\Http\Response
	 */
	public function update(Request $request, $id)
	{
		//
	}
}
```

<a name="request-path-and-method"></a>

### Шлях запита, хост і метод

Екземпляр `Illuminate\Http\Request` надає різноманітні методи для перевірки вхідного HTTP-запиту та розширює клас `Symfony\Component\HttpFoundation\Request`. Нижче ми обговоримо декілька найважливіших методів.

<a name="retrieving-the-request-path"></a>

#### Отримання шляху запита

Метод `path` повертає інформацію про шлях запита. Отже, якщо вхідний запит націлений на `http://example.com/foo/bar`, метод `path` поверне foo/bar:

```php
$uri = $request->path();
```

<a name="inspecting-the-request-path"></a>

#### Перевірка шляху / маршрута запита

Метод `is` дозволяє перевірити, чи шлях вхідного запита відповідає заданому шаблону. Ви можете використовувати символ `*` як символ узагальнення під час використання цього метода:

```php
if ($request->is('admin/*')) {
	//
}
```

Використовуючи метод `routeIs`, ви можете визначити, чи належить шлях вхідного запита [іменованому маршруту](routing.md#named-routes):

```php
if ($request->routeIs('admin.*')) {
	//
}
```

<a name="retrieving-the-request-url"></a>

#### Отримання URL-адреси запита

Щоб отримати повну URL-адресу вхідного запита, вам слід використати методи `url` or `fullUrl`. Метод `url` поверне URL-адресу без рядка параметрів запита, тоді як метод `fullUrl` включає рядок параметрів запита:

```php
$url = $request->url();

$urlWithQueryString = $request->fullUrl();
```

Якщо ви хочете додатково додати до поточної URL-адреси параметри запита, ви можете викликати метод `fullUrlWithQuery`. Цей метод об’єднує заданий масив змінних у якості рядка параметрів запита з поточним рядком параметрів запита:

```php
$request->fullUrlWithQuery(['type' => 'phone']);
```

<a name="retrieving-the-request-host"></a>

#### Отримання хоста запита

Ви можете отримати «хост» вхідного запита за допомогою методів `host`, `httpHost` і `schemeAndHttpHost`

```php
$request->host();
// localhost
$request->httpHost();
// localhost
$request->schemeAndHttpHost();
// http://localhost
```

<a name="retrieving-the-request-method"></a>

#### Отримання метода запита

Метод `method` поверне HTTP-метод запита. Ви можете використовувати метод `isMethod`, щоб переконатися, що HTTP-метод запита відповідає заданому рядку:

```php
$method = $request->method();

if ($request->isMethod('post')) {
	//
}
```

<a name="request-headers"></a>

### Заголовки запитів

Ви можете отримати значення заголовка або масив заголовків запита з екземпляра `Illuminate\Http\Request` за допомогою метода `header`. Якщо заголовок відсутній у запиті, буде повернуто значення `null`. Однак метод `header` приймає необов’язковий другий аргумент, який буде повернуто, якщо заголовок відсутній у запиті:

```php
$value = $request->header();

$value = $request->header('X-Header-Name');

$value = $request->header('X-Header-Name', 'default');
```

Метод `hasHeader` можна використовувати, щоб визначити, чи містить запит заданий заголовок:

```php
if ($request->hasHeader('X-Header-Name')) {
	//
}
```

Для зручності можна використовувати метод `bearerToken` для отримання токена із заголовка `Authorization` запита. Якщо такий заголовок відсутній, буде повернено порожній рядок:

```php
$token = $request->bearerToken();
```

<a name="request-ip-address"></a>

### IP-адреса запиту

Метод `ip` можна використовувати для отримання IP-адреси клієнта, який зробив запит до вашого додатка:

```php
$ipAddress = $request->ip();
```

<a name="content-negotiation"></a>

### Узгодження вмісту

Laravel містить декілька методів для перевірки типів вмісту вхідного запита через заголовок `Accept`, які він підтримує. По-перше, метод `getAcceptableContentTypes` поверне масив, що містить усі типи контенту, прийняті запитом:

```php
$contentTypes = $request->getAcceptableContentTypes();
```

Метод `accepts` приймає масив типів вмісту та повертає `true`, якщо будь-який із типів вмісту приймається запитом. В іншому випадку буде повернено `false`:

```php
if ($request->accepts(['text/html', 'application/json'])) {
	// ...
}
```

Ви можете використовувати метод `prefers`, щоб визначити, який тип вмісту з заданого у масиві типів вмісту є найбільш бажаним для запита. Якщо жоден із наданих типів вмісту не приймається запитом, буде повернено значення `null`:

```php
$preferred = $request->prefers(['text/html', 'application/json']);
```

Оскільки багато програм обслуговують лише HTML або JSON, ви можете використовувати метод `expectsJson`, щоб швидко визначити, чи очікує вхідний запит відповідь JSON:

```php
if ($request->expectsJson()) {
	// ...
}
```

<a name="psr7-requests"></a>

### PSR-7 Запити

[Стандарт PSR-7](https://www.php-fig.org/psr/psr-7/) визначає інтерфейси для повідомлень HTTP, включаючи запити та відповіді. Якщо ви хочете отримати екземпляр запиту PSR-7 замість запиту Laravel, вам спочатку потрібно буде інсталювати декілька бібліотек. Laravel використовує компонент _Symfony HTTP Message Bridge_ для перетворення типових запитів і відповідей Laravel у PSR-7-сумісні реалізації:

```shell
composer require symfony/psr-http-message-bridge
composer require nyholm/psr7
```

Після того, як ви встановили ці бібліотеки, ви можете отримати запит PSR-7, вказавши підказку інтерфейсу запита в методі замикання маршруту або контролера:

```php
use Psr\Http\Message\ServerRequestInterface;

Route::get('/', function (ServerRequestInterface $request) {
	//
});
```

> **Note**  
> Якщо ви повернете екземпляр відповіді PSR-7 із маршруту або контролера, він буде автоматично перетворений назад на екземпляр відповіді Laravel і відображатиметься фреймворком.

<a name="input"></a>

## Дані полів введення

<a name="retrieving-input"></a>

### Отримання вхідних даних

<a name="retrieving-all-input-data"></a>

#### Отримання всіх вхідних даних

Ви можете отримати всі дані полів введення вхідного запита як `array` за допомогою метода `all`. Цей метод можна використовувати незалежно від того, чи є вхідний запит із форми HTML чи є запитом XHR:

```php
$input = $request->all();
```

Використовуючи метод `collect`, ви можете отримати всі вхідні дані полів введення як [колекцію](collections.md)::

```php
$input = $request->collect();
```

Метод `collect` також дозволяє отримати підмножину вхідного запита як колекцію:

```php
$request->collect('users')->each(function ($user) {
	// ...
});
```

<a name="retrieving-an-input-value"></a>

#### Отримання окремо взятого значення з поля введення

Використовуючи декілька простих методів, ви можете отримати доступ до всього введеного користувачем з вашого екземпляра `Illuminate\Http\Request`, не турбуючись про те, який HTTP-метода було використано для запиту. Незалежно від HTTP-метода, метод `input` може використовуватися для отримання введених користувачем даних:

```php
$name = $request->input('name');
```

Ви можете передати значення за замовчуванням як другий аргумент метода `input`. Це значення буде повернено, якщо вхідне значення відсутнє в запиті:

```php
$name = $request->input('name', 'Sally');
```

Під час роботи з формами, які містять масив вхідних даних, використовуйте «крапкову нотацію» для доступу до масивів:

```php
$name = $request->input('products.0.name');

$names = $request->input('products.*.name');
```

Ви можете викликати метод `input` без будь-яких аргументів, щоб отримати всі вхідні значення як асоціативний масив:

```php
$input = $request->input();
```

<a name="retrieving-input-from-the-query-string"></a>

#### Отримання вхідних даних із рядка URL запита

У той час як метод `input` отримує значення з усієї інформаційної частини даних запита (включаючи рядок запита), метод `query` отримує значення тільки з параметрів рядка URL запита:

```php
$name = $request->query('name');
```

Якщо значення даних із рядка запита відсутні, буде повернено другий аргумент цього метода:

```php
$name = $request->query('name', 'Helen');
```

Ви можете викликати метод `query` без аргументів, щоб отримати всі значення рядка запита як асоціативного масиву:

```php
$query = $request->query();
```

<a name="retrieving-json-input-values"></a>

#### Отримання вхідних значень JSON

Надсилаючи запити JSON до вашого додатка, ви можете отримати доступ до даних JSON за допомогою метода `input`, якщо заголовок `Content-Type` запита встановлено як значення `application/json`. Ви навіть можете використовувати синтаксис «крапкової нотації» для отримання значень, вкладених у масиви JSON:

```php
$name = $request->input('user.name');
```

<a name="retrieving-stringable-input-values"></a>

#### Отримання рядкових вхідних значень

Замість того, щоб отримувати вхідні дані запита як примітивний рядок, ви можете використовувати метод `string`, щоб отримати дані запита як екземпляр [`Illuminate\Support\Stringable`](helpers.md#fluent-strings):

```php
$name = $request->string('name')->trim();
```

<a name="retrieving-boolean-input-values"></a>

#### Отримання значень логічного тип

Маючи справу з елементами HTML, такими як прапорці, ваш додаток може отримати «справжні» значення, які насправді є рядками. Наприклад, "true" або "on". Для зручності ви можете використовувати метод `boolean` для отримання цих значень як логічних. Логічний метод повертає `true` для 1, "1", true, "true", "on" і "yes". Усі інші значення повернуть `false`:

```php
$archived = $request->boolean('archived');
```

<a name="retrieving-date-input-values"></a>

#### Отримання значень дати

Для зручності вхідні значення, що містять дати/час, можна отримати як екземпляри Carbon за допомогою метода `date`. Якщо запит не містить вхідного значення з заданим іменем, буде повернено значення `null`:

```php
$birthday = $request->date('birthday');
```

Другий і третій аргументи, які приймає метод `date`, можуть використовуватися для визначення формату дати та часового поясу відповідно:

```php
$elapsed = $request->date('elapsed', '!H:i', 'Europe/Madrid');
```

Якщо вхідне значення присутнє, але має недійсний формат, буде викинуто виняток `InvalidArgumentException`; отже, рекомендується перевірити введені дані перед тим, як викликати метод `date`.

<a name="retrieving-enum-input-values"></a>

#### Отримання вхідних значень перерахування

Вхідні значення, які відповідають перелікам [PHP перахування](https://www.php.net/manual/en/language.types.enumerations.php), також можна отримати із запиту. Якщо запит не містить вхідного значення з заданим іменем або перехунок не має резервного значення, яке відповідає вхідному значенню, буде повернуто значення `null`. Метод `enum` приймає назву вхідного значення та клас перерахунку як перший і другий аргументи:

```php
use App\Enums\Status;

$status = $request->enum('status', Status::class);
```

<a name="retrieving-input-via-dynamic-properties"></a>

#### Отримання даних через динамічні властивості

Ви також можете отримати доступ до даних, що надійшли від користувача, використовуючи динамічні властивості екземпляра `Illuminate\Http\Request`. Наприклад, якщо одна з форм додатка містить поле `name`, то ви можете отримати доступ до значення поля наступним чином:

```php
$name = $request->name;
```

При використанні динамічних властивостей Laravel спочатку шукатиме значення параметра в інформаційній частині даних запита. Якщо його немає, Laravel шукатиме поле в параметрах відповідного маршруту.

<a name="retrieving-a-portion-of-the-input-data"></a>

#### Вибіркове отримання даних полів введення

Якщо вам потрібно отримати підмножину вхідних даних, ви можете скористатися методами `only` і `except`. Обидва методи приймають один масив або динамічний список аргументів:

```php
$input = $request->only(['username', 'password']);

$input = $request->only('username', 'password');

$input = $request->except(['credit_card']);

$input = $request->except('credit_card');
```

> **Warning**  
> Метод `only` повертає всі пари ключ/значення, які ви запитуєте; однак він не поверне пари ключ/значення, яких немає в запиті.

<a name="determining-if-input-is-present"></a>

### Визначення наявності вхідних даних

Ви можете використовувати метод `has`, щоб визначити, чи присутнє значення в запиті. Метод `has` повертає `true`, якщо значення присутнє в запиті:

```php
if ($request->has('name')) {
	//
}
```

Коли надається масив, метод `has` визначає, чи присутні всі вказані значення:

```php
if ($request->has(['name', 'email'])) {
	//
}
```

Метод `whenHas` виконає задане замикання, якщо в запиті є значення:

```php
$request->whenHas('name', function ($input) {
	//
});
```

Друге замикання може бути передано методу `whenHas`, який буде виконано, якщо вказане значення відсутнє в запиті:

```php
$request->whenHas('name', function ($input) {
	// Присутнє значення "name"...
}, function () {
	// Значення "name" відсутнє...
});
```

Метод `hasAny` повертає`true`, якщо присутні будь-які з вказаних значень:

```php
if ($request->hasAny(['name', 'email'])) {
	//
}
```

Якщо ви бажаєте визначити, чи присутнє значення в запиті та не порожнє, ви можете використати метод `filled`:

```php
if ($request->filled('name')) {
	//
}
```

Метод `whenFilled` виконає дане замикання, якщо значення присутнє в запиті і не порожне:

```php
$request->whenFilled('name', function ($input) {
	//
});
```

Друге замикання може бути передано методу `whenFilled`, яке буде виконано, якщо вказане значення не буде «заповнено»:

```php
$request->whenFilled('name', function ($input) {
	// Значення `name` заповнено ...
}, function () {
	// Значення `name` не заповнене ...
});
```

Щоб визначити, чи немає конкретного ключа в запиті, ви можете використовувати метод `missing`:

```php
if ($request->missing('name')) {
	//
}
```

<a name="merging-additional-input"></a>

### Об’єднання додаткових вхідних даних

Іноді може знадобитися вручну об’єднати додаткові вхідні дані з наявними вхідними даними запита. Щоб досягти цього, ви можете використати метод `merge`:

```php
$request->merge(['votes' => 0]);
```

Метод `mergeIfMissing` можна використовувати для об’єднання вхідних даних з запитом, якщо відповідні ключі ще не існують у вхідних даних запита:

```php
$request->mergeIfMissing(['votes' => 0]);
```

<a name="old-input"></a>

### Дані минулого запита

Laravel дозволяє зберігати введення з одного запиту під час наступного запиту. Ця функція особливо корисна для повторного заповнення форм після виявлення помилок перевірки. Однак, якщо ви використовуєте включений [валідаційний функціонал](validation.md) Laravel, вам не потрібно буде вручну використовувати ці методи короткочасного сеансу безпосередньо, оскільки деякі вбудовані засоби перевірки Laravel викличуть їх автоматично.

<a name="flashing-input-to-the-session"></a>

#### Короткочасне збереження вхідних даних у сесії

Метод `flash` класу `Illuminate\Http\Request` буде зберігати вхідні дані в [сесії](session.md), щоб вони були доступні тільки під час наступного запиту користувача до вашого додатка:

```php
$request->flash();
```

Ви також можете використовувати методи `flashOnly` і `flashExcept` для передачі підмножини даних запита до сесії. Ці методи корисні для приховання конфіденційної інформації ві сесії, наприклад паролі:

```php
$request->flashOnly(['username', 'email']);

$request->flashExcept('password');
```

<a name="flashing-input-then-redirecting"></a>

#### Короткочасне збереження при перенаправленні

Так як вам часто потрібно виконувати короткочасне збереження вхідних даних у сесії, а потім перенаправляти на попередню сторінку, ви можете легко зв'язати збереження даних з перенаправленням, використовуючи метод `withInput`:

```php
return redirect('form')->withInput();

return redirect()->route('user.create')->withInput();

return redirect('form')->withInput(
	$request->except('password')
);
```

<a name="retrieving-old-input"></a>

#### Отримання даних минулого запита

Щоб отримати короткочасно збережені вхідні дані з попереднього запиту, викличте метод `old` екземпляра `Illuminate\Http\Request`. Метод `old` витягне раніше записані вхідні дані із [сесії](session.md):

```php
$username = $request->old('username');
```

Laravel також містить глобального помічника `old`. Якщо ви показуєте дані з попереднього запиту у [шаблоні Blade](blade.md), зручніше використовувати помічник `old` для повторного заповнення форми. Якщо для поля не було вказано даних у попередньому запиті, то буде повернуто `null`:

```blade
<input type="text" name="username" value="{{ old('username') }}">
```

<a name="cookies"></a>

### Файли Cookies

<a name="retrieving-cookies-from-requests"></a>

#### Отримання файлів cookie із запитів

Усі файли cookie, створені фреймворком Laravel, зашифровані та підписані кодом автентифікації, тобто вони вважатимуться недійсними, якщо їх змінив клієнт. Щоб отримати значення cookie із запиту, використовуйте метод `cookie` в екземплярі `Illuminate\Http\Request`:

```php
$value = $request->cookie('name');
```

<a name="input-trimming-and-normalization"></a>

## Обрізання та нормалізація значень полів введення

За замовчуванням Laravel включає посередника `App\Http\Middleware\TrimStrings` і `App\Http\Middleware\ConvertEmptyStringsToNull` у глобальний стек посередиків вашого додатка. Ці посередники перераховано в глобальному стеку посердників у класі `App\Http\Kernel`. Перший посередник автоматично обрізає пробіли на початкау та в кінці значень всіх вхідних рядкових полів запита, другий перетворює будь-які порожні рядкові поля на `null`. Це дозволяє вам не турбуватися про ці проблеми нормалізації у ваших маршрутах і контролерах.

#### Disabling Input Normalization

Якщо ви хочете відключити цю поведінку для всіх запитів, то ви можете видалити два посередника зі стека посередників вашого додатка, вилучивши їх із властивості `$middleware` вашого класу `App\Http\Kernel`.

Якщо ви хочете вимкнути обрізання рядків і перетворення порожнього рядка для підмножени запитів вашого додатка, то ви можете використовувати метод `skipWhen`, який пропонується обома посередниками. Цей метод приймає замикання, яке має повертати `true` або `false`, щоб вказати, чи слід пропустити нормалізацію введення. Як правило, виклик метода `skipWhen` здійснюється у методі `boot` постачальника `App\Providers\AppServiceProvider`:

```php
use App\Http\Middleware\ConvertEmptyStringsToNull;
use App\Http\Middleware\TrimStrings;

/**
 * Завантаження будь-яких служб програми.
 *
 * @return void
 */
public function boot()
{
    TrimStrings::skipWhen(function ($request) {
        return $request->is('admin/*');
    });

    ConvertEmptyStringsToNull::skipWhen(function ($request) {
        // ...
    });
}
```

<a name="files"></a>

## Файли

<a name="retrieving-uploaded-files"></a>

### Отримання завантажених файлів

Ви можете отримати завантажені файли з екземпляра `Illuminate\Http\Request`, використовуючи метод `file` або динамічні властивості. Метод `file` повертає екземпляр класу `Illuminate\Http\UploadedFile`, який розширює клас `SplFileInfo` PHP і містить різні методи для взаємодії з файлом:

```php
$file = $request->file('photo');

$file = $request->photo;
```

Ви можете визначити, чи присутній файл у запиті, використовуючи метод `hasFile`:

```php
if ($request->hasFile('photo')) {
	//
}
```

<a name="validating-successful-uploads"></a>

#### Перевірка успішних завантажень

Окрім перевірки наявності файлу, ви можете перевірити, чи не було проблем із завантаженням файла за допомогою метода `isValid`:

```php
if ($request->file('photo')->isValid()) {
	//
}
```

<a name="file-paths-extensions"></a>

#### Шляхи до файлів та їх формати

Клас `UploadedFile` також містить методи для доступу до повного шляху файла та його формат. Метод `extension` спробує вгадати формат файлу з урахуванням його вмісту. Це формат може відрізнятись від формату, наданого клієнтом:

```php
$path = $request->photo->path();

$extension = $request->photo->extension();
```

<a name="other-file-methods"></a>

#### Інші файлові методи

У екземплярах `UploadedFile` доступна низка інших методів. Перегляньте [документацію API для класу](https://github.com/symfony/symfony/blob/6.0/src/Symfony/Component/HttpFoundation/File/UploadedFile.php), щоб дізнатися більше про ці методи.

<a name="storing-uploaded-files"></a>

### Зберігання завантажених файлів

Щоб зберегти завантажений файл, ви зазвичай використовуєте одну з налаштованих [файлових систем](filesystem.md). Клас `UploadedFile` має метод `store`, який переміщує завантажений файл на один із ваших дисків, який може бути розташований у вашій локальній файловій системі або у хмарному сховищі, наприклад Amazon S3.

Метод `store` приймає шлях, де має зберігатися файл відносно налаштованого кореневого каталогу файлової системи. Цей шлях не повинен містити ім’я файлу, оскільки автоматично буде згенеровано унікальний ідентифікатор, який буде використовуватися як ім’я файлу.

Метод `store` також приймає додатковий другий аргумент для імені диска, який слід використовувати для зберігання файлу. Метод поверне шлях до файлу відносно кореня диска:

```php
$path = $request->photo->store('images');

$path = $request->photo->store('images', 's3');
```

Якщо ви не хочете, щоб ім’я файлу генерувалося автоматично, ви можете використати метод `storeAs`, який приймає шлях, ім’я файлу та ім’я диска:

```php
$path = $request->photo->storeAs('images', 'filename.jpg');

$path = $request->photo->storeAs('images', 'filename.jpg', 's3');
```

> **Note**  
> Для отримання додаткової інформації про сховище файлів у Laravel, ознайомтеся з повною документацією щодо [файлового сховища](filesystem.md).

<a name="configuring-trusted-proxies"></a>

## Налаштування довірених проксі

При запуску ваших додатків, що використовують балансувальник навантаження, який завершує сертифікати TLS/SSL, ви можете помітити, що ваш додаток іноді не генерує посилання протоколу HTTPS при використанні глобального помічника `url`. Зазвичай це пов'язано з тим, що ваш додаток перенаправляє трафік від вашого балансувальника навантаження на порт 80 і не знає, що він має генерувати безпечні посилання.

Щоб вирішити цю проблему, ви можете використовувати посередник `App\Http\Middleware\TrustProxies`, який міститься у вашому додатку Laravel, що дозволяє вам швидко налаштовувати балансувальники навантаження або проксі, яким ваш додаток має довіряти. Ваші довірені проксі мають бути вказані у вигляді масиву як `$proxies` цього посередника. Крім налаштування довірених проксі, ви можете налаштувати `$headers` проксі, яким слід довіряти:

```php
<?php

namespace App\Http\Middleware;

use Illuminate\Http\Middleware\TrustProxies as Middleware;
use Illuminate\Http\Request;

class TrustProxies extends Middleware
{
	/**
	 * Довірені проксі цього додатка.
	 *
	 * @var string|array
	 */
	protected $proxies = [
		'192.168.1.1',
		'192.168.1.2',
	];

	/**
	 * Заголовки, які використовуються для виявлення проксі.
	 *
	 * @var int
	 */
	protected $headers = Request::HEADER_X_FORWARDED_FOR | Request::HEADER_X_FORWARDED_HOST | Request::HEADER_X_FORWARDED_PORT | Request::HEADER_X_FORWARDED_PROTO;
}
```

> **Note**  
> Якщо ви використовуєте AWS Elastic Load Balancing, значення `$headers` має бути `Request::HEADER_X_FORWARDED_AWS_ELB`. Для отримання додаткової інформації про константи, які можуть використовуватися як `$headers`, ознайомтесь з документацією Symfony про [довірені проксі-сервери](https://symfony.com/doc/current/deployment/proxies.html).

<a name="trusting-all-proxies"></a>

#### Довіра всім проксі

Якщо ви використовуєте Amazon AWS або іншого «хмарного» постачальника балансувальників навантаження, ви можете не знати IP-адреси своїх фактичних балансувальників. У цьому випадку ви можете використовувати `*`, щоб довіряти всім проксі:

```php
/**
 * Довірені проксі для цього додатка.
 *
 * @var string|array
 */
protected $proxies = '*';
```

<a name="configuring-trusted-hosts"></a>

## Налаштування довірених хостів

За замовчуванням Laravel відповідатиме на всі отримані запити незалежно від вмісту заголовка `Host` HTTP-запита. Крім того, значення заголовка `Host` використовуватиметься під час створення абсолютних URL-адрес вашого додатка, під час веб-запита.

Як правило, вам слід налаштувати свій веб-сервер (Nginx або Apache), щоб він обслуговував запити, що відповідають лише вказаному імені хоста. Однак, якщо у вас немає можливості безпосередньо налаштувати свій веб-сервер і вам потрібно вказати Laravel, щоб він відповідав тільки на певні імена хостів, ви можете зробити це, задіявши посередник `App\Http\Middleware\TrustHosts` для вашого додатка.

Посередник `TrustHosts` вже міститься у стеку `$middleware` вашого додатка; однак ви повинні розкоментувати його, щоб він став активним. У методі `hosts` цього посередника ви можете вказати імена хостів, на які ваш додаток повинен відповідати. Вхідні запити з іншими значеннями заголовка `Host` будуть відхилені:

```php
/**
 * Отримати шаблони довірених хостів.
 *
 * @return array
 */
public function hosts()
{
	return [
		'laravel.test',
		$this->allSubdomainsOfApplicationUrl(),
	];
}
```

Допоміжний метод `allSubdomainsOfApplicationUrl` поверне регулярний вираз, що відповідає всім субдоменам значення конфігурації `app.url` вашого додатка. Цей допоміжний метод забезпечує зручний спосіб дозволу всім субдоменам вашого додатка під час створення додатків, з використанням піддоменів, які визначаються метасимволами підстановки.
