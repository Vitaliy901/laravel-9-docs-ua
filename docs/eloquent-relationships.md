# Eloquent: Відношення

- [Вступ](#introduction)
- [Визначення Відношень](#defining-relationships)
  - [Один до Одного](#one-to-one)
  - [Один до Багатьох](#one-to-many)
  - [Визначення Зворотного Відношення Один до Багатьох](#one-to-many-inverse)
  - [Один з Багатьох](#has-one-of-many)
  - [Один через Відношення](#has-one-through)
  - [Багато через Відношення](#has-many-through)
- [Відношення Багато до Багатьох](#many-to-many)
  - [Отримання стовпців проміжної таблиці](#retrieving-intermediate-table-columns)
  - [Фільтрування Запитів по Стовпцях Проміжної Таблиці](#filtering-queries-via-intermediate-table-columns)
  - [Визначення Власних Моделей Проміжних Таблиць](#defining-custom-intermediate-table-models)
- [Поліморфні Відношення](#polymorphic-relationships)
  - [Один до Одного (поліморфний)](#one-to-one-polymorphic-relations)
  - [Один до Багатьох (поліморфний)](#one-to-many-polymorphic-relations)
  - [Один з Багатьох](#one-of-many-polymorphic-relations)
  - [Багато до Багатьох (поліморфний)](#many-to-many-polymorphic-relations)
  - [Спеціальні Поліморфні типи](#custom-polymorphic-types)
- [Динамічні Відношення](#dynamic-relationships)
- [Запити Відношень](#querying-relations)
  - [Методи Відношень Проти Динамічних Властивостей](#relationship-methods-vs-dynamic-properties)
  - [Запити, Обмежені Наявністю Відношень](#querying-relationship-existence)
  - [Запити, Обмежені Відсутністю Відношень](#querying-relationship-absence)
  - [Запит Поліморфних Відношень Morph To](#querying-morph-to-relationships)
- [Агрегування Пов'язаних Моделей](#aggregating-related-models)
  - [Підрахунок Пов'язаних Моделей](#counting-related-models)
  - [Інші Агрегатні Функції](#other-aggregate-functions)
  - [Підрахунок Пов'язаних Відношень Моделей Morph To](#counting-related-models-on-morph-to-relationships)
- [Нетерпляче Завантаження](#eager-loading)
  - [Обмеження Нетерплячого Завантаження](#constraining-eager-loads)
  - [Нетерпляче Пост-Завантаження](#lazy-eager-loading)
  - [Запобігання Відкладеному Завантаженню](#preventing-lazy-loading)
- [Вставка та Оновлення Пов'язаних Моделей](#inserting-and-updating-related-models)
  - [Метод `save`](#the-save-method)
  - [Метод `create`](#the-create-method)
  - [Оновлення Відношень Один До](#updating-belongs-to-relationships)
  - [Оновлення Відношень Багато до Більшості](#updating-many-to-many-relationships)
- [Зачіпання Батьківських Міток Часу](#touching-parent-timestamps)

<a name="introduction"></a>

## Вступ

Таблиці бази даних часто пов’язані одна з одною. Наприклад, публікація в блозі може мати багато коментарів або замовлення може бути пов’язане з користувачем, який його розмістив. Eloquent спрощує керування цими відношеннями і роботу з ними та підтримує низку загальних зв’язків:

<div class="content-list" markdown="1">

- [Один до Одного](#one-to-one)
- [Один до Багатьох](#one-to-many)
- [Багато до Більшості](#many-to-many)
- [Один через Відношення](#has-one-through)
- [Багато через Відношення](#has-many-through)
- [Один до Одного (поліморфний)](#one-to-one-polymorphic-relations)
- [Один до Багатьох (поліморфний)](#one-to-many-polymorphic-relations)
- [Багато до Більшості (поліморфний)](#many-to-many-polymorphic-relations)

</div>

<a name="defining-relationships"></a>

## Визначення Відношень

Відношення Eloquent визначаються як методи у ваших класах моделі Eloquent. Оскільки відношення також служать потужними [конструкторами запитів](queries.md), визначення відношень як методів надає потужні можливості ланцюжкового з’єднання методів і створення запитів. Наприклад, ми можемо об’єднати додаткові обмеження запита на цей зв’язок `posts`:

```php
$user->posts()->where('active', 1)->get();
```

Але перш ніж пірнути глибше у використання відношень, давайте дізнаємося, як визначити кожен тип відношення, який підтримує Eloquent.

<a name="one-to-one"></a>

### Один до Одного

Зв’язок «один-до-одного» — це дуже простий тип зв’язку бази даних. Наприклад, модель `User` може бути пов’язана з однією моделлю `Phone`. Щоб визначити цей зв’язок, ми розмістимо метод `Phone` у моделі `User`. Метод `phone` має викликати метод `hasOne` і повертати його результат. Метод `hasOne` доступний для вашої моделі через базовий клас моделі `Illuminate\Database\Eloquent\Model`:

```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class User extends Model
{
	/**
	 * Отримання користувача, якому належить телефон.
	 */
	public function phone()
	{
		return $this->hasOne(Phone::class);
	}
}
```

Перший аргумент, який передається в метод `hasOne`, — це ім’я пов’язаного класа моделі. Після визначення зв’язку ми можемо отримати відповідний запис за допомогою динамічних властивостей Eloquent. Динамічні властивості дозволяють вам отримати доступ до методів відношень так, ніби вони були властивостями, визначеними в моделі:

```php
$phone = User::find(1)->phone;
```

Eloquent визначає зовнішній ключ відношення на основі назви батьківської моделі. У цьому випадку автоматично передбачається, що модель `Phone` має зовнішній ключ `user_id`. Якщо ви хочете перевизначити цю угоду, ви можете передати другий аргумент методу `hasOne`:

```php
return $this->hasOne(Phone::class, 'foreign_key');
```

Крім того, Eloquent припускає, що зовнішній ключ повинен мати значення, яке дорівнює стовпцю батьківського первинного ключа. Іншими словами, Eloquent шукатиме значення стовпця `id` користувача в стовпці `user_id` записа `Phone`. Якщо ви хочете, щоб зв’язок використовував значення первинного ключа, інакший від `id` або властивості `$primaryKey` вашої моделі, ви можете передати третій аргумент методу `hasOne`:

```php
return $this->hasOne(Phone::class, 'foreign_key', 'local_key');
```

<a name="one-to-one-defining-the-inverse-of-the-relationship"></a>

#### Визначення зворотного відношення Один до одного

Отже, ми можемо отримати доступ до моделі `Phone` з моделі `User`. Далі визначимо зв’язок на моделі `Phone`, який дозволить нам отримати доступ до користувача, якому належить телефон. Ми можемо визначити зворотний зв’язок `hasOne` за допомогою методу `belongsTo`:

```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class Phone extends Model
{
	/**
	 * Отримання користувача, якому належить телефон.
	 */
	public function user()
	{
		return $this->belongsTo(User::class);
	}
}
```

Викликаючи метод `user`, Eloquent намагатиметься знайти модель `User`, `id` якої відповідає стовпцю `user_id` у моделі `Phone`.

Eloquent визначає назву зовнішнього ключа, досліджуючи назву метода відношення та додаючи до назви метода суфікс `_id`. Отже, у цьому випадку Eloquent припускає, що модель `Phone` має стовпець `user_id`. Однак, якщо зовнішній ключ у моделі `Phone` не `user_id`, ви можете передати власне ім’я ключа як другий аргумент метода `belongsTo`:

```php
/**
 * Отримання користувача, якому належить телефон.
 */
public function user()
{
	return $this->belongsTo(User::class, 'foreign_key');
}
```

Якщо батьківська модель не використовує `id` як первинний ключ або ви бажаєте знайти пов’язану модель за допомогою іншого стовпця, ви можете передати третій аргумент методу belongsTo, вказуючи власний ключ батьківської таблиці:

```php
/**
 * Отримання користувача, якому належить телефон.
 */
public function user()
{
	return $this->belongsTo(User::class, 'foreign_key', 'owner_key');
}
```

<a name="one-to-many"></a>

### Один до багатьох

Відношення «один-до-багатьох» використовується для визначення відношень, де одна модель є батьківською для однієї або кількох дочірніх моделей. Наприклад, публікація у блозі може мати нескінченну кількість коментарів. Як і всі інші відношенння Eloquent, відношенння «один до багатьох» визначаються шляхом визначення метода у вашій моделі Eloquent:

```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class Post extends Model
{
	/**
	 * Отримайте коментарі до публікації в блозі.
	 */
	public function comments()
	{
		return $this->hasMany(Comment::class);
	}
}
```

Пам’ятайте, що Eloquent автоматично визначить відповідний стовпець зовнішнього ключа для моделі `Comment`. Відповідно до домовленості, Eloquent візьме назву у «snake case» батьківської моделі та додасть до неї суфікс `_id`. Отже, у цьому прикладі Eloquent припускатиме, що стовпцем зовнішнього ключа в моделі `Comment` це `post_id`.

Після визначення метода відношень ми можемо отримати доступ до [колекції](eloquent-collections.md) пов’язаних коментарів, звернувшись до властивості `comments`. Пам’ятайте, оскільки Eloquent надає «динамічні властивості відношень», ми можемо отримати доступ до методів відношень так, ніби вони були визначені як властивості моделі:

```php
use App\Models\Post;

$comments = Post::find(1)->comments;

foreach ($comments as $comment) {
	//
}
```

Оскільки всі відношенння також служать конструкторами запитів, ви можете додати додаткові обмеження до запита на зв’язок, викликавши метод `comments` і продовживши зв’язувати умови в запиті:

```php
$comment = Post::find(1)->comments()
		->where('title', 'foo')
		->first();
```

Подібно до метода `hasOne`, ви також можете замінити зовнішні та локальні ключі, передавши додаткові аргументи методу `hasMany`:

```php
return $this->hasMany(Comment::class, 'foreign_key');

return $this->hasMany(Comment::class, 'foreign_key', 'local_key');
```

<a name="one-to-many-inverse"></a>

### Визначення Зворотного відношення Один до Багатьох

Тепер, коли ми маємо доступ до всіх коментарів публікації, давайте визначимо відношення, щоб надати коментарю доступ до батьківської публікації. Щоб визначити зворотне відношення `hasMany`, визначте метод відношення в дочірній моделі, який викликає метод `belongsTo`:

```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class Comment extends Model
{
	/**
	 * Отримайте публікацію, до якої належить коментар.
	 */
	public function post()
	{
		return $this->belongsTo(Post::class);
	}
}
```

Після того, як зв’язок визначено, ми можемо отримати батьківську публікацію коментаря, звернувшись до «динамічної властивості відношення» `post`:

```php
use App\Models\Comment;

$comment = Comment::find(1);

return $comment->post->title;
```

У наведеному вище прикладі Eloquent спробує знайти модель `Post`, яка має `id`, який відповідає стовпцю `post_id` у моделі `Comment`.

Eloquent визначає ім’я зовнішнього ключа за замовчуванням, перевіряючи ім’я метода відношень та додаючи до імені метода суфікс `_`, після якого йде ім’я стовпця первинного ключа батьківської моделі. Отже, у цьому прикладі Eloquent припускатиме, що зовнішній ключ моделі `Post` у таблиці `comments` – `post_id`.

Однак, якщо зовнішній ключ для вашого зв’язку не відповідає цим умовам, ви можете передати власне ім’я зовнішнього ключа другим аргументом методу `belongsTo`:

```php
/**
 * Отримайте публікацію, до якої належить коментар.
 */
public function post()
{
	return $this->belongsTo(Post::class, 'foreign_key');
}
```

Якщо ваша батьківська модель не використовує `id` як первинний ключ або ви бажаєте знайти пов’язану модель за допомогою іншого стовпця, ви можете передати третій аргумент методу `belongsTo`, вказуючи власний ключ вашої батьківської таблиці:

```php
/**
 * Отримайте публікацію, до якої належить коментар.
 */
public function post()
{
	return $this->belongsTo(Post::class, 'foreign_key', 'owner_key');
}
```

<a name="default-models"></a>

#### Моделі за замовчуванням

Відношення `belongsTo`, `hasOne`, `hasOneThrough` і `morphOne` дозволяють визначити модель за замовчуванням, яка повертатиметься, якщо даний зв’язок дорівнюватиме `null`. Цей шаблон часто називають [шаблоном нульового об’єкта](https://en.wikipedia.org/wiki/Null_Object_pattern), і він може допомогти видалити умовні перевірки у вашому коді. У наступному прикладі відношення `user` поверне порожню модель `App\Models\User`, якщо до моделі `Post` не приєднано жодного користувача:

```php
/**
 * Отримати автора поста.
 */
public function user()
{
	return $this->belongsTo(User::class)->withDefault();
}
```

Щоб заповнити модель атрибутами за замовчуванням, ви можете передати масив або замикання методу `withDefault`:

```php
/**
 * Отримати автора поста.
 */
public function user()
{
	return $this->belongsTo(User::class)->withDefault([
		'name' => 'Guest Author',
	]);
}

/**
 * Отримати автора поста.
 */
public function user()
{
	return $this->belongsTo(User::class)->withDefault(function ($user, $post) {
		$user->name = 'Guest Author';
	});
}
```

<a name="querying-belongs-to-relationships"></a>

#### Запити відношень Belongs To

Під час запиту дочірніх елементів відношення «belongs to» ви можете вручну створити вираз `where`, щоб отримати відповідні моделі Eloquent:

```php
use App\Models\Post;

$posts = Post::where('user_id', $user->id)->get();
```

Однак вам може бути зручніше використовувати метод `whereBelongsTo`, який автоматично визначатиме належний зв’язок і зовнішній ключ для заданої моделі:

```php
$posts = Post::whereBelongsTo($user)->get();
```

Ви також можете надати екземпляр [колекції](eloquent-collections.md) методу `whereBelongsTo`. При цьому Laravel отримає моделі, які належать до будь-якої з батьківських моделей у колекції:

```php
$users = User::where('vip', true)->get();

$posts = Post::whereBelongsTo($users)->get();
```

За замовчуванням Laravel визначатиме відношення, пов’язане із заданою моделлю, на основі імені класу моделі; однак ви можете вказати ім’я відношення вручну, надавши його як другий аргумент методу `whereBelongsTo`:

```php
$posts = Post::whereBelongsTo($user, 'author')->get();
```

<a name="has-one-of-many"></a>

### Один з Багатьох

Іноді модель може мати багато пов’язаних моделей, але ви хочете з легкістю отримати «найновішу» або «найстарішу» пов’язану модель відношення. Наприклад, модель користувача може бути пов’язана з багатьма моделями `Order`, але ви хочете визначити зручний спосіб взаємодії з останнім замовленням, розміщеним користувачем. Ви можете досягти цього, використовуючи тип зв’язку `hasOne` у поєднанні з методами `ofMany`:

```php
/**
 * Отримати нове замовлення користувача.
 */
public function latestOrder()
{
    return $this->hasOne(Order::class)->latestOfMany();
}
```

Так само ви можете визначити метод для отримання «найстарішої» або першої пов’язаної моделі відношення:

```php
/**
 * Отримати старе замовлення користувача.
 */
public function oldestOrder()
{
    return $this->hasOne(Order::class)->oldestOfMany();
}
```

За замовчуванням методи `latestOfMany` та `oldestOfMany` отримають останню або найстарішу пов’язану модель на основі первинного ключа моделі, який має бути сортованим. Однак іноді вам може знадобитися отримати одну модель з відношення, використовуючи інші критерії сортування.

Наприклад, використовуючи метод `ofMany`, ви можете отримати найдорожче замовлення користувача. Метод `ofMany` приймає стовпець для сортування першим аргументом і агрегатну функцію (`min` або `max`), які застосовуватимуться під час запита для пов’язаної моделі:

```php
/**
 * Отримайте найбільше замовлення користувача.
 */
public function largestOrder()
{
    return $this->hasOne(Order::class)->ofMany('price', 'max');
}
```

> **Warning**  
> Оскільки PostgreSQL не підтримує виконання функції `MAX` для стовпців UUID, наразі неможливо використовувати відношенння «один із багатьох» у поєднанні зі стовпцями PostgreSQL UUID.

<a name="advanced-has-one-of-many-relationships"></a>

#### Доповнення відношень Один з багатьох

Можна побудувати більш просунуті відношенння «один з багатьох». Наприклад, модель `Product` може мати багато пов’язаних моделей `Price`, які зберігаються в системі навіть після публікації нових цін. Крім того, нові дані про ціни на продукт можуть бути опубліковані заздалегідь, щоб набути чинності в майбутньому через стовпець `published_at`.

Отже, підсумовуючи, нам потрібно отримати останні опубліковані ціни враховуючи дати публікації. Крім того, якщо дві ціни мають однакову дату публікації, ми віддамо перевагу ціні з найбільшим ідентифікатором. Щоб виконати це, ми повинні передати масив методу `ofMany`, який містить стовпці для сортування, які визначають останню ціну. Крім того, другим аргументом буде надане замикання методу `ofMany`. Це замикання відповідатиме за додавання додаткових обмежень дати публікації на запит відношень:

```php
/**
 * Отримати поточну ціну товару.
 */
public function currentPricing()
{
    return $this->hasOne(Price::class)->ofMany([
        'published_at' => 'max',
        'id' => 'max',
    ], function ($query) {
        $query->where('published_at', '<', now());
    });
}
```

<a name="has-one-through"></a>

### Один через Відношення

Відношення "один через відношення" визначає зв'язок один-до-одного з іншою моделлю. Однак цей зв’язок вказує на те, що оголошена модель може бути порівняна ​​з одним екземпляром іншої моделі, переходячи _через_ третю модель.

Наприклад, у додатку автомайстерні кожна модель `Mechanic` може бути пов’язана з однією моделлю `Car`, а кожна модель `Car` може бути пов’язана з однією моделлю `Owner`. Хоча механік і власник не мають прямого зв’язку в базі даних, механік може отримати доступ до власника _через_ модель `Car`. Давайте розглянемо таблиці, необхідні для визначення цього зв’язку:

    mechanics
        id - integer
        name - string

    cars
        id - integer
        model - string
        mechanic_id - integer

    owners
        id - integer
        name - string
        car_id - integer

Тепер, коли ми дослідили структуру таблиці для відношення, давайте визначимо зв’язок на моделі `Mechanic`:

```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class Mechanic extends Model
{
	/**
	 * Отримати власника машини.
	 */
	public function carOwner()
	{
		return $this->hasOneThrough(Owner::class, Car::class);
	}
}
```

Перший аргумент, який передається в метод `hasOneThrough`, — це ім’я кінцевої моделі, до якої ми хочемо отримати доступ, тоді як другий аргумент — це ім’я проміжної моделі.

<a name="has-one-through-key-conventions"></a>

#### Угоди по іменуванню ключів відношень Один через відношення

Типові угоди про зовнішні ключі Eloquent використовуватимуться під час виконання запитів відношення. Якщо ви хочете змінити ключі відношення, ви можете передати їх як третій і четвертий аргументи методу `hasOneThrough`. Третій аргумент - ім'я зовнішнього ключа проміжної моделі. Четвертий аргумент - це ім'я зовнішнього ключа кінцевої моделі. П’ятий аргумент – локальний ключ, а шостий – локальний ключ проміжної моделі:

```php
class Mechanic extends Model
{
	/**
	 * Get the car's owner.
	 */
	public function carOwner()
	{
		return $this->hasOneThrough(
			Owner::class,
			Car::class,
			'mechanic_id', // Зовнішній ключ у таблиці `cars` ...
			'car_id', // Зовнішній ключ у таблиці `owners` ...
			'id', // Локальний ключ у таблиці `mechanics` ...
			'id' // Локальний ключ у таблиці `cars` ...
		);
	}
}
```

<a name="has-many-through"></a>

### Багато через Відношення

Відношення «багато через відношення» забезпечує зручний спосіб доступу до віддалених зв’язків через проміжне відношення. Наприклад, припустімо, що ми створюємо платформу для розгортання, таку як [Laravel Vapor](https://vapor.laravel.com). Модель `Project` може отримати доступ до багатьох моделей `Deployment` через проміжну модель `Environment`. Використовуючи цей приклад, ви можете легко зібрати всі розгортання для певного проекту. Давайте розглянемо таблиці, необхідні для визначення цього зв’язку:

    projects
        id - integer
        name - string

    environments
        id - integer
        project_id - integer
        name - string

    deployments
        id - integer
        environment_id - integer
        commit_hash - string

Тепер, коли ми дослідили структуру таблиці для відношень, давайте визначимо відношення у моделі `Project`:

```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class Project extends Model
{
	/**
	 * Отримайте всі розгортання для проекту.
	 */
	public function deployments()
	{
		return $this->hasManyThrough(Deployment::class, Environment::class);
	}
}
```

Перший аргумент, який передається в метод `hasManyThrough`, — це ім’я кінцевої моделі, до якої ми хочемо отримати доступ, тоді як другий аргумент — це ім’я проміжної моделі.

Хоча таблиця моделі розгортання не містить стовпець `project_id`, відношення `hasManyThrough` надає доступ до розгортань проекту через `$project->deployments`. Щоб отримати ці моделі, Eloquent перевіряє стовпець `project_id` у таблиці проміжної моделі `Environment`. Після знаходження відповідних ID середовища вони використовуються для запита до таблиці моделі `Deployment`.

<a name="has-many-through-key-conventions"></a>

#### Угоди щодо іменування ключів відношень Багато через відношення

Типові угоди про зовнішні ключі Eloquent використовуватимуться під час виконання запитів відношення. Якщо ви хочете змінити ключі відношення, ви можете передати їх як третій і четвертий аргументи методу `hasManyThrough`. Третій аргумент - ім'я зовнішнього ключа проміжної моделі. Четвертий аргумент - це ім'я зовнішнього ключа в остаточній моделі. П’ятий аргумент – локальний ключ, а шостий – локальний ключ проміжної моделі:

```php
class Project extends Model
{
	public function deployments()
	{
		return $this->hasManyThrough(
			Deployment::class,
			Environment::class,
			'project_id', // Зовнішній ключ у таблиці середовища...
			'environment_id', // Зовнішній ключ у таблиці розгортань...
			'id', // Локальний ключ у таблиці проектів...
			'id' // Локальний ключ у таблиці середовищ...
		);
	}
}
```

<a name="many-to-many"></a>

## Відношення Багато до багатьох

Відношення «багато-до-багатьох» трохи складніше, ніж відношення `hasOne` і `hasMany`. Прикладом зв’язку «багато-до-багатьох» є користувач, який має багато ролей, і ці ролі також спільно використовуються іншими користувачами додатка. Наприклад, користувачеві можуть бути призначені ролі «Автор» і «Редактор»; однак ці ролі також можуть бути призначені іншим користувачам. Отже, користувач має багато ролей, а роль має багато користувачів.

<a name="many-to-many-table-structure"></a>

#### Структура таблицить

Щоб визначити цей зв’язок, необхідні три таблиці бази даних: `users`, `roles` і `role_user`. Назва таблиці `role_user` походить від назв пов’язаних моделей у алфавітнму порядку і містить стовпці `user_id` і `role_id`. Laravel передбачатиме, що ця таблиця використовується як проміжна, яка зв’язує користувачів і ролі.

Пам’ятайте: оскільки роль може належати багатьом користувачам, ми не можемо просто розмістити стовпець `user_id` в таблиці `roles`. Це означатиме, що роль може належати лише одному користувачеві. Щоб забезпечити підтримку ролей, які призначаються кільком користувачам, потрібна таблиця `role_user`. Ми можемо узагальнити структуру таблиці відношенння наступним чином:

    users
        id - integer
        name - string

    roles
        id - integer
        name - string

    role_user
        user_id - integer
        role_id - integer

<a name="many-to-many-model-structure"></a>

#### Структура моделі

Відношення «багато до багатьох» визначаються шляхом написання метода, який повертає результат метода `belongsToMany`. Метод `belongsToMany` надається базовим класом `Illuminate\Database\Eloquent\Model`, який використовується всіма моделями Eloquent вашого додатка. Перший аргумент, який передається цьому методу, — це ім’я пов’язаного класу моделі. Наприклад, давайте визначимо метод `roles` у нашій моделі `User`:

```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class User extends Model
{
	/**
	 * Ролі, які належать користувачу.
	 */
	public function roles()
	{
		return $this->belongsToMany(Role::class);
	}
}
```

Після визначення відношення ви можете отримати доступ до ролей користувача за допомогою властивості динамічного відношення `roles`:

```php
use App\Models\User;

$user = User::find(1);

foreach ($user->roles as $role) {
	//
}
```

Оскільки всі відношення також служать конструкторами запитів, ви можете додати додаткові обмеження до запиту відношення, викликавши метод `roles` і продовжуючи зв’язувати умови в запиті:

```php
$roles = User::find(1)->roles()->orderBy('name')->get();
```

Щоб визначити назву проміжної таблиці відношення, Eloquent об’єднає дві пов’язані назви моделей в алфавітному порядку. Однак ви можете перевизначити цю конвенцію. Ви можете зробити це, передавши другий аргумент методу `belongsToMany`:

```php
return $this->belongsToMany(Role::class, 'role_user');
```

Окрім налаштування назви проміжної таблиці, ви також можете налаштувати назви стовпців ключів у таблиці, передавши додаткові аргументи методу `belongsToMany`. Третій аргумент — ім’я зовнішнього ключа моделі, на основі якої ви визначаєте зв’язок, тоді як четвертий аргумент — ім’я зовнішнього ключа моделі, до якої ви приєднуєтеся:

```php
return $this->belongsToMany(Role::class, 'role_user', 'user_id', 'role_id');
```

<a name="many-to-many-defining-the-inverse-of-the-relationship"></a>

#### Визначення зворотного відношення Багато до багатьох

Щоб визначити «зворотний» зв’язок «багато-до-багатьох», вам слід визначити метод у пов’язаній моделі, яка також повертає результат методу `belongsToMany`. Щоб завершити наш приклад користувача/ролі, давайте визначимо метод `users` на моделі `Role`:

```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class Role extends Model
{
	/**
	 * Користувачі, які належать ролям.
	 */
	public function users()
	{
		return $this->belongsToMany(User::class);
	}
}
```

Як бачите, зв’язок визначено аналогічним чином як, і в моделі `User`, за винятком посилання на модель `App\Models\User`. Оскільки ми повторно використовуємо метод `belongsToMany`, всі звичайні параметри налаштування таблиць і ключів доступні під час визначення «зворотних» відношень «багато до багатьох».

<a name="retrieving-intermediate-table-columns"></a>

### Отримання стовпців проміжної таблиці

Як ви вже зрозуміли, робота з відношеннями «багато до багатьох» вимагає наявності проміжної таблиці. Eloquent пропонує кілька дуже корисних способів взаємодії з цією таблицею. Наприклад, припустимо, що наша модель `User` має багато моделей `Role`, з якими вона пов’язана. Після доступу до цього зв’язку ми можемо отримати доступ до проміжної таблиці за допомогою атрибута `pivot` у моделях:

```php
use App\Models\User;

$user = User::find(1);

foreach ($user->roles as $role) {
	echo $role->pivot->created_at;
}
```

Зверніть увагу, що кожній `Role` моделі, яку ми отримуємо, автоматично призначається `pivot`. Цей атрибут містить модель, що представляє проміжну таблицю.

За замовчуванням у проміжній моделі `pivot` будуть присутні лише ключі. Якщо ваша проміжна таблиця містить додаткові атрибути, ви повинні вказати їх під час визначення зв’язку:

```php
return $this->belongsToMany(Role::class)->withPivot('active', 'created_by');
```

Якщо ви хочете, щоб у вашій проміжній таблиці були часові мітки `created_at` і `updated_at`, які автоматично підтримуються Eloquent, викличте метод `withTimestamps` під час визначення відношення:

```php
return $this->belongsToMany(Role::class)->withTimestamps();
```

> **Warning**  
> Проміжні таблиці, які використовують автоматично підтримувані часові мітки Eloquent, повинні мати стовпці часових позначок `created_at` і `updated_at` .

<a name="customizing-the-pivot-attribute-name"></a>

#### Коригування імені атрибута `pivot`

Як зазначалося раніше, доступ до атрибутів із проміжної таблиці можна отримати на моделях через атрибут `pivot`. Однак ви можете налаштувати назву цього атрибута, щоб краще відображати його призначення у вашому додатку.

Наприклад, якщо ваш додаток містить користувачів, які можуть підписатися на подкасти, ймовірно, між користувачами та подкастами існує зв’язок «багато-до-багатьох». Якщо це так, ви можете перейменувати атрибут проміжної таблиці на `subscription` замість `pivot`. Це можна зробити за допомогою метода `as` під час визначення зв’язку:

```php
    return $this->belongsToMany(Podcast::class)
                    ->as('subscription')
                    ->withTimestamps();
```

Після визначення власної назви атрибуту `pivot` проміжної таблиці, ви можете отримати доступ до даних проміжної таблиці за допомогою цього імені:

```php
$users = User::with('podcasts')->get();

foreach ($users->flatMap->podcasts as $podcast) {
	echo $podcast->subscription->created_at;
}
```

<a name="filtering-queries-via-intermediate-table-columns"></a>

### Фільтрація запитів через стовпці проміжної таблиці

Ви також можете відфільтрувати результати, які повертає запит на відношення `belongsToMany`, за допомогою `wherePivot`, `wherePivotIn`, `wherePivotNotIn`, `wherePivotBetween`, `wherePivotNotBetween`, `wherePivotNull`, і `wherePivotNotNull` під час визначення відношення:

```php
return $this->belongsToMany(Role::class)
				->wherePivot('approved', 1);

return $this->belongsToMany(Role::class)
				->wherePivotIn('priority', [1, 2]);

return $this->belongsToMany(Role::class)
				->wherePivotNotIn('priority', [1, 2]);

return $this->belongsToMany(Podcast::class)
				->as('subscriptions')
				->wherePivotBetween('created_at', ['2020-01-01 00:00:00', '2020-12-31 00:00:00']);

return $this->belongsToMany(Podcast::class)
				->as('subscriptions')
				->wherePivotNotBetween('created_at', ['2020-01-01 00:00:00', '2020-12-31 00:00:00']);

return $this->belongsToMany(Podcast::class)
				->as('subscriptions')
				->wherePivotNull('expired_at');

return $this->belongsToMany(Podcast::class)
				->as('subscriptions')
				->wherePivotNotNull('expired_at');
```

<a name="defining-custom-intermediate-table-models"></a>

### Визначення власних моделей проміжних таблиць

Якщо ви бажаєте визначити власну модель проміжної таблиці відношення «багато-до-багатьох», ви можете викликати метод `using` під час визначення відношення. Явні проміжні моделі дають вам можливість визначити додаткову поведінку на проміжній моделі, наприклад методи та типізації.

Явні проміжні моделі «багато-до-багатьох» повинні розширювати клас `Illuminate\Database\Eloquent\Relations\Pivot`, тоді як спеціальні поліморфні проміжні моделі «багато-до-багатьох» мають розширювати клас `Illuminate\Database\Eloquent\Relations\MorphPivot`. Наприклад, ми можемо визначити модель `Role`, яка використовує спеціальну проміжну модель `RoleUser`:

```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class Role extends Model
{
	/**
	 * Користувачі, які належать ролі.
	 */
	public function users()
	{
		return $this->belongsToMany(User::class)->using(RoleUser::class);
	}
}
```

Визначаючи модель `RoleUser`, ви повинні розширити клас `Illuminate\Database\Eloquent\Relations\Pivot`:

```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Relations\Pivot;

class RoleUser extends Pivot
{
	//
}
```

> **Warning**  
> Проміжні моделі можуть не використовувати трейт `SoftDeletes`. Якщо вам потрібно програмно видалити проміжні записи, подумайте про перетворення вашої проміжної моделі на реальну модель Eloquent.

<a name="custom-pivot-models-and-incrementing-ids"></a>

#### Власні проміжні моделі та автоінкрементні IDs

Якщо ви визначили зв’язок «багато-до-багатьох», який використовує явну проміжну модель, і ця проміжна модель має автоінкрементний первинний ключ, вам слід переконатися, що ваш клас явної проміжної моделі визначає властивість `incrementing`, яка має значення `true`.

```php
/**
 * Вказує на те, що ID моделі є автоінкрементними.
 *
 * @var bool
 */
public $incrementing = true;
```

<a name="polymorphic-relationships"></a>

## Поліморфні Відношення

Поліморфний зв’язок дозволяє дочірній моделі належати до більш ніж одного типу моделі за допомогою однієї асоціації. Наприклад, уявіть, що ви створюєте додаток, який дозволяє користувачам ділитися публікаціями в блозі та відео. У такому додатку модель `Comment` може належати як до моделей `Post`, так і до `Video`.

<a name="one-to-one-polymorphic-relations"></a>

### Один до Одного (поліморфний)

<a name="one-to-one-polymorphic-table-structure"></a>

#### Структура таблицить

Поліморфне відношення «один до одного» подібне до типового відношення «один до одного»; однак дочірня модель може належати більш ніж одному типу моделі за допомогою однієї асоціації. Наприклад, `Post` в блозі та `User` можуть мати спільний поліморфний зв’язок із моделлю `Image`. Використання поліморфного відношення «один до одного» дозволяє мати єдину таблицю з унікальними зображенннями для `Post`, і для `User`, які можуть бути пов’язані з публікаціями та користувачами. Спочатку розглянемо структуру таблиці:

    posts
        id - integer
        name - string

    users
        id - integer
        name - string

    images
        id - integer
        url - string
        imageable_id - integer
        imageable_type - string

Зверніть увагу на стовпці `imageable_id` and `imageable_type` у таблиці `images`. Стовпець `imageable_id` міститиме значення ID публікації або користувача, тоді як стовпець `imageable_type` міститиме назву класу батьківської моделі. Стовпець `imageable_type` використовується Eloquent, щоб визначити, який «тип» батьківської моделі повертати під час доступу до відношення `imageable`. У цьому випадку стовпець міститиме `App\Models\Post` або `App\Models\User`.

<a name="one-to-one-polymorphic-model-structure"></a>

#### Структура моделі

Далі розглянемо необхідні визначення у моделі, для побудови цього зв’язку:

```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class Image extends Model
{
	/**
	 * Отримати батьківську модель, до якої належить зображення.
	 */
	public function imageable()
	{
		return $this->morphTo();
	}
}

class Post extends Model
{
	/**
	 * Отримати зображення поста.
	 */
	public function image()
	{
		return $this->morphOne(Image::class, 'imageable');
	}
}

class User extends Model
{
	/**
	 * Отримати зображення користувача.
	 */
	public function image()
	{
		return $this->morphOne(Image::class, 'imageable');
	}
}
```

<a name="one-to-one-polymorphic-retrieving-the-relationship"></a>

#### Отримання відношення Один до одного (поліморфний)

Як тільки ваша таблиця бази даних та моделі визначені, ви можете отримати доступ до відношень через свої моделі. Наприклад, щоб отримати зображення для поста, ми можемо звернутися до динамічної властивості відношення `image`:

```php
use App\Models\Post;

$post = Post::find(1);

$image = $post->image;
```

Ви можете отримати батьківський об'єкт поліморфної моделі, звернувшись до імені метода, який виконує виклик `morphTo`. У цьому випадку це метод `imageable` моделі `Image`.

```php
use App\Models\Image;

$image = Image::find(1);

$imageable = $image->imageable;
```

Відношення `imageable` до моделі `Image` повертатиме екземпляр `Post` або `User`, залежно від того, до якого типу моделі відноситься зображення.

<a name="morph-one-to-one-key-conventions"></a>

#### Угоди щодо іменування ключів відношення Один до одного (поліморфний)

Якщо необхідно, ви можете вказати назву стовпців «id» і «type», які використовуються вашою поліморфною дочірньою моделлю. Якщо ви це зробите, переконайтеся, що ви завжди передаєте назву відношення першим аргументом методу `morphTo`. Як правило, це значення має збігатися з назвою метода, тому ви можете використовувати константу PHP `__FUNCTION__`:

```php
/**
 * Отримати батьківську модель, якій належить зображення.
 */
public function imageable()
{
	return $this->morphTo(__FUNCTION__, 'imageable_type', 'imageable_id');
}
```

<a name="one-to-many-polymorphic-relations"></a>

### Один до Багатьох (поліморфний)

<a name="one-to-many-polymorphic-table-structure"></a>

#### Структура таблицить

Поліморфне відношення «один до багатьох» подібне до типового відношення «один до багатьох»; однак дочірня модель може належати більш ніж одному типу моделі за допомогою однієї асоціації. Наприклад, уявіть, що користувачі вашого додатка можуть «коментувати» публікації та відео. Використовуючи поліморфні відношення, ви можете використовувати єдину таблицю `comments`, щоб зберігати коментарі для публікацій і відео. Спочатку розглянемо структуру таблиці, необхідну для створення цього зв’язку:

    posts
        id - integer
        title - string
        body - text

    videos
        id - integer
        title - string
        url - string

    comments
        id - integer
        body - text
        commentable_id - integer
        commentable_type - string

<a name="one-to-many-polymorphic-model-structure"></a>

#### Структура моделі

Далі розглянемо необхідні визначення у моделі, для побудови цього зв’язку:

```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class Comment extends Model
{
	/**
	 * Отримати батьківську модель (поста чи відео), до якої належить коментар.
	 */
	public function commentable()
	{
		return $this->morphTo();
	}
}

class Post extends Model
{
	/**
	 * Отримати всі коментарі поста.
	 */
	public function comments()
	{
		return $this->morphMany(Comment::class, 'commentable');
	}
}

class Video extends Model
{
	/**
	 * Отримати всі коментарі відео.
	 */
	public function comments()
	{
		return $this->morphMany(Comment::class, 'commentable');
	}
}
```

<a name="one-to-many-polymorphic-retrieving-the-relationship"></a>

#### Отримання відношення Один до багатьох (поліморфний)

Після того, як ваша таблиця бази даних та моделі визначені, ви можете отримати доступ до відношень через динамічні властивості відношень вашої моделі. Наприклад, щоб отримати доступ до всіх коментарів постів, ми можемо використовувати динамічні властивості `comments`:

```php
use App\Models\Post;

$post = Post::find(1);

foreach ($post->comments as $comment) {
	//
}
```

Ви також можете отримати батьківську модель дочірньої поліморфної моделі, звернувшись до імені метода, який виконує виклик `morphTo`. В даному випадку це метод `commentable` у моделі `Comment`. Отже, ми будемо звертатися до цього метода як динамічної властивості відношень, щоб отримати доступ до батьківської моделі коментаря:

```php
use App\Models\Comment;

$comment = Comment::find(1);

$commentable = $comment->commentable;
```

Відношення `commentable` у моделі `Comment` поверне або екземпляр `Post`, або `Video`, залежно від того, який тип моделі є батьківським для коментаря.

<a name="one-of-many-polymorphic-relations"></a>

### Один з багатьох (поліморфний)

Іноді модель може мати багато пов’язаних моделей, але ви хочете з легкістю отримати «найновішу» або «найстарішу» пов’язану модель відношення. Наприклад, модель `User` може бути пов’язана з багатьма моделями `Image`, але ви хочете визначити зручний спосіб взаємодії з останнім зображенням, яке користувач завантажив. Ви можете досягти цього, використовуючи тип зв’язку `morphOne` у поєднанні з методами `ofMany`:

```php
/**
 * Отримайте останнє зображення користувача.
 */
public function latestImage()
{
    return $this->morphOne(Image::class, 'imageable')->latestOfMany();
}
```

Так само ви можете визначити метод для отримання «найстарішої» або першої пов’язаної моделі відношень:

```php
/**
 * Отримати найстаріше зображення користувача.
 */
public function oldestImage()
{
    return $this->morphOne(Image::class, 'imageable')->oldestOfMany();
}
```

За замовчуванням методи `latestOfMany` та `oldestOfMany` отримають останню або найстарішу пов’язану модель на основі автоінкриментного первинного ключа моделі. Однак іноді вам може знадобитися отримати одну модель з відношення, використовуючи інші критерії сортування.

Наприклад, використовуючи метод `ofMany`, ви можете отримати зображення, яке найбільше "подобається" користувачам. Метод `ofMany` приймає стовпець для сортування першим аргументом, а другим аргументом функцію (`min` або `max`) які застосовуватимуться під час запита для пов’язаної моделі:

```php
/**
 * Отримати найпопулярніше зображення користувача.
 */
public function bestImage()
{
    return $this->morphOne(Image::class, 'imageable')->ofMany('likes', 'max');
}
```

> **Note**  
> Можна побудувати більш просунуті відношення «один з багатьох». Для отримання додаткової інформації зверніться до [розділу Доповнення відношень Один з багатьох](#advanced-has-one-of-many-relationships).

<a name="many-to-many-polymorphic-relations"></a>

### Багато до Багатьох (поліморфний)

<a name="many-to-many-polymorphic-table-structure"></a>

#### Структура таблицить

Поліморфні відношенння «багато-до-багатьох» дещо складніші, ніж відношенння «один-до-одного» та «одним-до-багатьох». Наприклад, модель `Post` і модель `Video` можуть спільно використовувати поліморфне відношення до моделі `Tag`. Використання поліморфного відношення «багато-до-багатьох» у цій ситуації дозволить вашому додатку мати єдину таблицю унікальних тегів, які можуть бути пов’язані з публікаціями чи відео. Спочатку розглянемо структуру таблиці, необхідну для створення цього зв’язку:

    posts
        id - integer
        name - string

    videos
        id - integer
        name - string

    tags
        id - integer
        name - string

    taggables
        tag_id - integer
        taggable_id - integer
        taggable_type - string

> **Note**  
> Перш ніж зануритися в поліморфні відношення «багато-до-багатьох», корисно буде прочитати документацію по типових [відношеннях багато-до-багатьох](#many-to-many).

<a name="many-to-many-polymorphic-model-structure"></a>

#### Структура моделі

Далі ми готові визначити відношення на моделях. Моделі `Post` і `Video` міститимуть метод `tags`, який викликає метод `morphToMany`, наданий базовим класом моделі Eloquent.

Метод `morphToMany` приймає назву пов’язаної моделі, а також «ім’я выдношення». Базуючись на імені, яке ми визначели нашій проміжній таблиці, і ключах, які вона містить, ми називатимемо зв’язок «taggable»:

```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class Post extends Model
{
	/**
	 * Отримайте всі теги для публікації.
	 */
	public function tags()
	{
		return $this->morphToMany(Tag::class, 'taggable');
	}
}
```

<a name="many-to-many-polymorphic-defining-the-inverse-of-the-relationship"></a>

#### Визначення зворотного відношення Багато до багатьох (поліморфний)

Далі в моделі `Tag` ви повинні визначити метод для кожної з її можливих батьківських моделей. Отже, у цьому прикладі ми визначимо метод `posts` і `videos`. Обидва ці методи мають повертати результат методу `morphedByMany`.

Метод `morphedByMany` приймає назву пов’язаної моделі, а також «ім’я відношення». Базуючись на імені, яке ми визначели нашій проміжній таблиці, і ключах, які вона містить, ми називатимемо зв’язок «taggable»:

```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class Tag extends Model
{
	/**
	 * Отримати всі публікації, яким присвоєно цей тег.
	 */
	public function posts()
	{
		return $this->morphedByMany(Post::class, 'taggable');
	}

	/**
	 * Отримайте всі відео, яким присвоєно цей тег.
	 */
	public function videos()
	{
		return $this->morphedByMany(Video::class, 'taggable');
	}
}
```

<a name="many-to-many-polymorphic-retrieving-the-relationship"></a>

#### Отримання відношення Багато до багатьох (поліморфний)

Після визначення таблиці бази даних і моделей ви можете отримати доступ до відношень через свої моделі. Наприклад, щоб отримати доступ до всіх тегів для публікації, ви можете використати властивість `tags` динамічного зв’язку:

```php
use App\Models\Post;

$post = Post::find(1);

foreach ($post->tags as $tag) {
	//
}
```

Ви можете отримати батьківський елемент поліморфного відношення з поліморфної дочірньої моделі, отримавши доступ до імені метода, який виконує виклик `morphedByMany`. У цьому випадку це методи `posts` або `videos` в моделі `Tag`:

```php
use App\Models\Tag;

$tag = Tag::find(1);

foreach ($tag->posts as $post) {
	//
}

foreach ($tag->videos as $video) {
	//
}
```

<a name="custom-polymorphic-types"></a>

### Іменування поліморфних типів

За замовчуванням Laravel використовуватиме повне ім’я класу для зберігання «типу» пов’язаної моделі. Наприклад, враховуючи наведений вище приклад зв’язку «один до багатьох», де модель коментаря може належати до моделі `Post` чи `Video`,`commentable_type` за замовчуванням буде відповідно `App\Models\Post` або `App\Models\Video`. Однак ви можете відокремити ці значення від внутрішньої структури додатка.

Наприклад, замість того, щоб використовувати назви моделей як «тип», ми можемо використовувати прості рядки, такі як `post` and `video`. Таким чином поліморфні значення стовпця "тип" у нашій базі даних залишатимуться дійсними, навіть якщо моделі буде перейменовано:

```php
use Illuminate\Database\Eloquent\Relations\Relation;

Relation::enforceMorphMap([
	'post' => 'App\Models\Post',
	'video' => 'App\Models\Video',
]);
```

Ви можете викликати метод `enforceMorphMap` у методі `boot` вашого класу `App\Providers\AppServiceProvider` або створити окремого постачальника послуг, якщо хочете.

Ви можете визначити псевдонім поліморфного типу для конкретної моделі під час виконання, за допомогою метода моделі `getMorphClass`. І навпаки, ви можете визначити повне ім'я класу, пов'язане із псевдонімом поліморфного типу, використовуючи метод`Relation::getMorphedModel`:

```php
use Illuminate\Database\Eloquent\Relations\Relation;

$alias = $post->getMorphClass();

$class = Relation::getMorphedModel($alias);
```

> **Warning**  
> Під час додавання «мапи поліморфних типів» до вашого іcнуючого додатка кожне значення стовпця `*_type` у вашій базі даних, яке все ще містить повну назву класу, потрібно буде перетворити на назву «map».

<a name="dynamic-relationships"></a>

### Динамічні відношення

Ви можете використовувати метод `resolveRelationUsing` для визначення відношень між моделями Eloquent під час виконання. Хоча це зазвичай не рекомендується для звичайної розробки додатків, іноді це може бути корисним під час розробки пакетів Laravel.

Метод `resolveRelationUsing` приймає бажане ім’я зв’язку як перший аргумент. Другим аргументом, переданим у метод, має бути замикання, яке приймає екземпляр моделі та повертає дійсне визначення зв’язку Eloquent. Як правило, ви повинні налаштувати динамічні відношенння в методі `boot` [постачальника послуг](providers.md):

```php
use App\Models\Order;
use App\Models\Customer;

Order::resolveRelationUsing('customer', function ($orderModel) {
	return $orderModel->belongsTo(Customer::class, 'customer_id');
});
```

> **Warning**  
> Визначаючи динамічні відношенння, завжди надавайте явні аргументи імені ключа для методів зв’язків Eloquent.

<a name="querying-relations"></a>

## Відношення запитів

Оскільки всі відношенння Eloquent визначаються за допомогою методів, ви можете викликати ці методи, щоб отримати екземпляр відношень без фактичного виконання запита для завантаження пов’язаних моделей. Крім того, всі типи відношень Eloquent також служать [конструкторами запитів](queries.md), дозволяючи продовжувати прив’язувати обмежень до запита відношення перед остаточним виконанням SQL-запита до вашої бази даних.

Наприклад, уявіть собі додаток блогу, у якому модель `User` має багато пов’язаних моделей `Post`:

```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class User extends Model
{
	/**
	 * Отримати всі пости користувача.
	 */
	public function posts()
	{
		return $this->hasMany(Post::class);
	}
}
```

Ви можете запитати відношення публікацій і додати додаткові обмеження до відношення таким чином:

```php
use App\Models\User;

$user = User::find(1);

$user->posts()->where('active', 1)->get();
```

Ви можете використовувати будь-які методи [конструктора запитів](queries.md) Laravel для відношення, тому обов’язково ознайомтеся з документацією конструктора запитів, щоб дізнатися про всі доступні вам методи.

<a name="chaining-orwhere-clauses-after-relationships"></a>

#### Створення ланцюжка виразів `orWhere` після відношень

Як показано в наведеному вище прикладі, ви можете вільно додавати додаткові обмеження до відношень під час запита. Однак будьте обережні під час зв’язування виразів `orWhere` з відношенням, оскільки вирази `orWhere` будуть логічно згруповані на тому самому рівні, що й обмеження відношення:

```php
$user->posts()
	->where('active', 1)
	->orWhere('votes', '>=', 100)
	->get();
```

Наведений вище приклад створить наступний SQL. Як ви бачите, вираз `or` вказує запиту повернути _будь-якого_ користувача, який набрав понад 100 голосів. Запит більше не обмежений конкретним користувачем:

```sql
select *
from posts
where user_id = ? and active = 1 or votes >= 100
```

У більшості ситуацій вам слід використовувати [логічні групи](queries.md#logical-grouping) для групування умовних перевірок між дужками:

```php
use Illuminate\Database\Eloquent\Builder;

$user->posts()
	->where(function (Builder $query) {
		return $query->where('active', 1)
			->orWhere('votes', '>=', 100);
	})
	->get();
```

Наведений вище приклад створить наступний SQL. Зверніть увагу, що логічне групування правильно згрупувало обмеження, і запит залишається обмеженим для конкретного користувача:

```sql
select *
from posts
where user_id = ? and (active = 1 or votes >= 100)
```

<a name="relationship-methods-vs-dynamic-properties"></a>

### Методи відношень проти динамічних властивостей

Якщо вам не потрібно додавати додаткові обмеження до запита відношень Eloquent, ви можете отримати доступ до відношень так, ніби це властивість. Наприклад, продовжуючи використовувати наші моделі `User` та `Post` з прикладу, ми можемо отримати доступ до всіх публікацій користувача таким чином:

```php
use App\Models\User;

$user = User::find(1);

foreach ($user->posts as $post) {
	//
}
```

Властивості динамічних відношеннь виконують «ліниве завантаження», тобто вони завантажуватимуть дані своїх відношень лише тоді, коли ви фактично до них звертаєтеся. Через це розробники часто використовують [нетерпляче завантаження](#eager-loading) для попереднього завантаження відношень, які, як вони знають, будуть доступні після завантаження моделі. Нетерпляче завантаження забезпечує значне скорочення кількості SQL-запитів, які потрібно виконати для завантаження відношень моделі.

<a name="querying-relationship-existence"></a>

### Запити, обмежені наявністю відношень

Під час отримання записів моделі ви можете обмежити свої результати на основі наявності відношення. Наприклад, уявіть, що ви хочете отримати всі публікації блогу, які мають принаймні один коментар. Для цього ви можете передати назву відношення методам `has` і `orHas`:

```php
use App\Models\Post;

// Отримати всі пости, в яких є хоча б один коментар.
$posts = Post::has('comments')->get();
```

Ви також можете вказати оператор та значення лічильника для уточнення запита:

```php
// Отримати всі публікації, які мають три або більше коментарів...
$posts = Post::has('comments', '>=', 3)->get();
```

Ви можете використовувати «крапкову нотацію» для виконання запита до вкладених відношень. Наприклад, ви можете отримати всі пости, в яких є хоча б один коментар з хоча б одним зображенням:

```php
// Отримати публікації, які мають принаймні один коментар із зображеннями...
$posts = Post::has('comments.images')->get();
```

Якщо вам потрібно ще більше можливостей, ви можете використовувати методи `whereHas` і `orWhereHas`, щоб визначити додаткові обмеження запитів на `has`-запити, наприклад, перевірити вміст коментаря:

```php
use Illuminate\Database\Eloquent\Builder;

// Отримати пости з принаймні одним коментарем, що містить такі слова, як `code%` ...
$posts = Post::whereHas('comments', function (Builder $query) {
	$query->where('content', 'like', 'code%');
})->get();
// Отримати пости з принаймні десятьма коментарями, що містять `code%` ...
$posts = Post::whereHas('comments', function (Builder $query) {
	$query->where('content', 'like', 'code%');
}, '>=', 10)->get();
```

> **Warning**  
> Наразі Eloquent не підтримує запити про наявність відношень між базами даних. Відношенння мають існувати в одній базі даних.

<a name="inline-relationship-existence-queries"></a>

#### Однолінійний запис запита, обмеженого наявністю відношень

Якщо ви хочете виконати запит, обмежений наявністю відношень, за допомогою однієї простої умови `where`, то вам буде зручніше використовувати методи `whereRelation`, `orWhereRelation`, `whereMorphRelation` і `orWhereMorphRelation`. Наприклад, ми можемо запросити всі пости з несхваленими коментарями:

```php
use App\Models\Post;

$posts = Post::whereRelation('comments', 'is_approved', false)->get();
```

Звичайно, як і виклики метода `where` конструктора запитів, ви також можете вказати оператор:

```php
$posts = Post::whereRelation(
	'comments', 'created_at', '>=', now()->subHour()
)->get();
```

<a name="querying-relationship-absence"></a>

### Запити, обмежені відсутністю відношень

Під час отримання записів моделі ви можете обмежити свої результати на основі відсутності відношення. Наприклад, уявіть, що ви хочете отримати всі публікації блогу, які **не** мають коментарів. Для цього ви можете передати назву відношення методам `doesntHave` та `orDoesntHave`:

```php
use App\Models\Post;

$posts = Post::doesntHave('comments')->get();
```

Якщо вам потрібно ще більше можливостей, ви можете використовувати методи `whereDoesntHave` та `orWhereDoesntHave`, щоб додати додаткові обмеження запита на ваші `doesntHave`-запити, наприклад, перевірити вміст коментаря:

```php
use Illuminate\Database\Eloquent\Builder;

$posts = Post::whereDoesntHave('comments', function (Builder $query) {
	$query->where('content', 'like', 'code%');
})->get();
```

Ви можете використовувати "крапкову нотацію", щоб виконати запит до вкладеного відношення. Наприклад, наступний запит отримає всі пости, які не мають коментарів; однак пости з коментарями незабанених авторів будуть включені в результати:

```php
use Illuminate\Database\Eloquent\Builder;

$posts = Post::whereDoesntHave('comments.author', function (Builder $query) {
	$query->where('banned', 0);
})->get();
```

<a name="querying-morph-to-relationships"></a>

### Запит поліморфних відношень Morph To

Щоб дізнатися про існування поліморфних відношень «один-до», можна використовувати методи `whereHasMorph` і `whereDoesntHaveMorph`. Ці методи приймають назву відношення першим аргумент. Далі методи приймають імена пов’язаних моделей, які ви бажаєте включити в запит. Нарешті, ви можете надати замикання, яке обмежує запит відношення:

```php
use App\Models\Comment;
use App\Models\Post;
use App\Models\Video;
use Illuminate\Database\Eloquent\Builder;

// Отримати коментарі, пов'язані з постами або відео із заголовком, наприклад `code%` ...
$comments = Comment::whereHasMorph(
	'commentable',
	[Post::class, Video::class],
	function (Builder $query) {
		$query->where('title', 'like', 'code%');
	}
)->get();

// Отримати коментарі, пов’язані з публікаціями, назва яких не відповідає `code%` ...
$comments = Comment::whereDoesntHaveMorph(
	'commentable',
	Post::class,
	function (Builder $query) {
		$query->where('title', 'like', 'code%');
	}
)->get();
```

Час від часу вам може знадобитися додати обмеження запиту на основі «типу» пов’язаної поліморфної моделі. Замикання, передане методу `whereHasMorph`, може отримати значення `$type` як другий аргумент. Цей аргумент дозволяє вам перевірити "тип" запита, який створюється:

```php
use Illuminate\Database\Eloquent\Builder;

$comments = Comment::whereHasMorph(
	'commentable',
	[Post::class, Video::class],
	function (Builder $query, $type) {
		$column = $type === Post::class ? 'content' : 'title';

		$query->where($column, 'like', 'code%');
	}
)->get();
```

<a name="querying-all-morph-to-related-models"></a>

#### Запит всіх пов’язаних моделей

Замість того, щоб передавати масив можливих поліморфних моделей, ви можете вказати `*` як значення підстановки. Це вкаже Laravel отримати всі можливі поліморфні типи з бази даних. Laravel виконає додатковий запит, щоб виконати цю операцію:

```php
    use Illuminate\Database\Eloquent\Builder;

    $comments = Comment::whereHasMorph('commentable', '*', function (Builder $query) {
        $query->where('title', 'like', 'foo%');
    })->get();
```

<a name="aggregating-related-models"></a>

## Агрегування пов'язаних моделей

<a name="counting-related-models"></a>

### Підрахунок пов'язаних моделей

Іноді потрібно підрахувати кількість зв'язаних моделей для відношення, не завантажуючи моделі. Для цього можна використовувати метод `withCount`. Метод `withCount` додасть атрибут `{relation}_count` до отриманих моделей:

```php
use App\Models\Post;

$posts = Post::withCount('comments')->get();

foreach ($posts as $post) {
	echo $post->comments_count;
}
```

Передаючи масив методу `withCount`, ви можете додати «лічильники» для кількох відношень, а також додати додаткові обмеження до запитів:

```php
use Illuminate\Database\Eloquent\Builder;

$posts = Post::withCount(['votes', 'comments' => function (Builder $query) {
	$query->where('content', 'like', 'code%');
}])->get();

echo $posts[0]->votes_count;
echo $posts[0]->comments_count;
```

Ви також можете використовувати псевдонім результата підрахунка відношень, дозволивши кілька підрахунків для одного і того ж відношення:

```php
use Illuminate\Database\Eloquent\Builder;

$posts = Post::withCount([
	'comments',
	'comments as pending_comments_count' => function (Builder $query) {
		$query->where('approved', false);
	},
])->get();

echo $posts[0]->comments_count;
echo $posts[0]->pending_comments_count;
```

<a name="deferred-count-loading"></a>

#### Відкладене завантаження підрахунка пов'язаних моделей

Використовуючи метод `loadCount`, ви можете завантажити кількість відношень після того, як батьківська модель вже була отримана:

```php
$book = Book::first();

$book->loadCount('genres');
```

Якщо вам потрібно встановити додаткові обмеження для запита на підрахунок, ви можете передати масив із ключами відношень, які ви хочете підрахувати. Значеннями масива мають бути замикання, які отримують екземпляр конструктора запитів:

```php
$book->loadCount(['reviews' => function ($query) {
	$query->where('rating', 5);
}])
```

<a name="relationship-counting-and-custom-select-statements"></a>

#### Підрахунок відношень та оператори користувача `SELECT`

Якщо ви об’єднуєте `withCount` із оператором `select`, переконайтеся, що ви викликаєте `withCount` після методу `select`:

```php
$posts = Post::select(['title', 'body'])
	->withCount('comments')
	->get();
```

<a name="other-aggregate-functions"></a>

### Інші агрегатні функції

Окрім метода `withCount`, Eloquent надає методи `withMin`, `withMax`, `withAvg`, `withSum`, і `withExists` . Ці методи додадуть атрибут `{relation}_{function}_{column}` до ваших результуючих моделей:

```php
use App\Models\Post;

$posts = Post::withSum('comments', 'votes')->get();

foreach ($posts as $post) {
	echo $post->comments_sum_votes;
}
```

Якщо ви бажаєте отримати доступ до результата агрегатної функції за допомогою іншого імені, ви можете вказати власний псевдонім:

```php
$posts = Post::withSum('comments as total_comments', 'votes')->get();

foreach ($posts as $post) {
	echo $post->total_comments;
}
```

Як і метод `loadCount`, доступні також відкладені версії цих методів. Ці додаткові агрегатні операції можна виконувати на моделях Eloquent, які вже були отримані:

```php
$post = Post::first();

$post->loadSum('comments', 'votes');
```

Якщо ви поєднуєте ці агрегатні методи з оператором `select`, переконайтеся, що ви викликаєте агрегатні методи після методу `select`:

```php
$posts = Post::select(['title', 'body'])
				->withExists('comments')
				->get();
```

<a name="counting-related-models-on-morph-to-relationships"></a>

### Підрахунок пов'язаних відношень моделей Morph To

Якщо ви хочете завантажити поліморфне відношення «один-до», а також лічильники пов’язаної моделі для різних сутностей, які можуть бути повернуті цим зв’язком, то ви можете використовувати метод `with` у поєднанні з відношеннями `morphTo` – метод `morphWithCount`.

У цьому прикладі припустимо, що моделі `Photo` та `Post` можуть створювати моделі `ActivityFeed`. Ми припустимо, що модель `ActivityFeed` визначає поліморфне відношення "один-до" з ім'ям `parentable`, що дозволяє нам отримати батьківську модель `Photo` або `Post` для певного екземпляра `ActivityFeed`. Крім того, припустимо, що `Photo` моделі «мають багато» `Tag`, а моделі публікацій «мають багато» моделей `Comment`.

Тепер уявімо, що ми хочемо отримати екземпляри `ActivityFeed` і завантажувати `parentable` моделі для кожного екземпляра `ActivityFeed`. Крім того, ми хочемо отримати кількість тегів, які пов’язані з кожною батьківською фотографією, і кількість коментарів, які пов’язані з кожною батьківською публікацією:

```php
use Illuminate\Database\Eloquent\Relations\MorphTo;

$activities = ActivityFeed::with([
	'parentable' => function (MorphTo $morphTo) {
		$morphTo->morphWithCount([
			Photo::class => ['tags'],
			Post::class => ['comments'],
		]);
	}])->get();
```

<a name="morph-to-deferred-count-loading"></a>

#### Відкладене завантаження підрахунка пов'язаних відношень моделей `morphTo`

Припустимо, що ми вже отримали набір моделей `ActivityFeed` і тепер хочемо завантажити лічильники вкладених зв’язків для різних `parentable` моделей, пов’язаних з `ActivityFeed`. Для цього можна використати метод `loadMorphCount`:

```php
$activities = ActivityFeed::with('parentable')->get();

$activities->loadMorphCount('parentable', [
	Photo::class => ['tags'],
	Post::class => ['comments'],
]);
```

<a name="eager-loading"></a>

## Нетерпляче завантаження

Під час доступу до зв’язків Eloquent як до властивостей, пов’язані моделі «завантажуються відкладено». Це означає, що дані відношення фактично не завантажуються, доки ви вперше не отримаєте доступ до властивості. Однак Eloquent може «нетерпляче завантажувати» відношення під час запита батьківської моделі. Нетерпляче завантаження спрощує проблему запита "N + 1". Щоб проілюструвати проблему запита "N + 1", розглянемо модель `Book`, яка «належить до» моделі `Author`:

```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class Book extends Model
{
	/**
	 * Знайти автора, який написав книгу.
	 */
	public function author()
	{
		return $this->belongsTo(Author::class);
	}
}
```

Тепер, давайте отримаємо всі книги та їх авторів:

```php
use App\Models\Book;

$books = Book::all();

foreach ($books as $book) {
	echo $book->author->name;
}
```

Цей цикл виконає один запит для отримання всіх книг у таблиці бази даних, а потім ще один запит для кожної книги, щоб отримати автора книги. Отже, якщо у нас є 25 книг, наведений вище код запустить 26 запитів: один для оригінальної книги та 25 додаткових запитів для отримання автора кожної книги.

На щастя, ми можемо використовувати нетерпляче завантаження, щоб скоротити цю операцію лише до двох запитів. Під час створення запита ви можете вказати, які відношенння слід завантажувати за допомогою методу `with`:

```php
$books = Book::with('author')->get();

foreach ($books as $book) {
	echo $book->author->name;
}
```

Для цієї операції буде виконано лише два запити – один запит для отримання всіх книг і один запит для отримання всіх авторів для всіх книг:

```sql
select * from books

select * from authors where id in (1, 2, 3, 4, 5, ...)
```

<a name="eager-loading-multiple-relationships"></a>

#### Нетерпляче завантаження множинних відношень

Іноді потрібно завантажити кілька різних відношень. Для цього просто передайте масив відношень методу `with` :

```php
$books = Book::with(['author', 'publisher'])->get();
```

<a name="nested-eager-loading"></a>

#### Вкладене нетерпляче завантаження

Щоб нетерпляче завантажити відношення відношень, ви можете використати «точкову нотацію». Наприклад, давайте завантажимо всіх авторів книги та всі особисті контакти авторів:

```php
$books = Book::with('author.contacts')->get();
```

Крім того, ви можете вказати вкладені нетерпляче завантажені відношення, надавши вкладений масив методу `with`, який може бути зручним під час нетерплячого завантаження кількох вкладених відношень:

```php
$books = Book::with([
	'author' => [
		'contacts',
		'publisher',
	],
])->get();
```

<a name="nested-eager-loading-morphto-relationships"></a>

#### Вкладене нетерпляче завантаження відношень `morphTo`

Якщо ви бажаєте швидко завантажити поліморфне відношення `morphTo`, а також вкладені відношення для різних сутностей, які можуть бути повернуті цим відношенням, ви можете використовувати метод `with` у поєднанні з методами відношень `morphTo` і `morphWith`. Щоб проілюструвати цей метод, розглянемо таку модель:

```php
<?php

use Illuminate\Database\Eloquent\Model;

class ActivityFeed extends Model
{
	/**
	 * Отримати батьківський запис стрічки активності.
	 */
	public function parentable()
	{
		return $this->morphTo();
	}
}

```

У цьому прикладі припустимо, що моделі `Event`, `Photo`, та `Post` можуть створювати моделі `ActivityFeed`. Припустимо, що моделі Event належать моделі `Calendar`, моделі `Photo` пов'язані з моделями `Tag`, а моделі `Post` належать моделі `Author`.

Використовуючи ці визначення моделей та відношення, ми можемо отримати екземпляри моделі `ActivityFeed` та нетерпляче завантажити всі батьківські `parentable` моделі та їх відповідні вкладені відношення:

```php
use Illuminate\Database\Eloquent\Relations\MorphTo;

$activities = ActivityFeed::query()
	->with(['parentable' => function (MorphTo $morphTo) {
		$morphTo->morphWith([
			Event::class => ['calendar'],
			Photo::class => ['tags'],
			Post::class => ['author'],
		]);
	}])->get();
```

<a name="eager-loading-specific-columns"></a>

#### Нетерпляче завантаження певних стовпців

Можливо, вам не завжди знадобляться всі стовпці з відншень, які ви отримуєте. З цієї причини Eloquent дозволяє вказати, які стовпці відношення ви хочете отримати:

```php
    $books = Book::with('author:id,name,book_id')->get();
```

> **Warning**  
> Використовуючи цей функціонал, ви завжди повинні включати стовпець `id` та будь-які відповідні стовпці зовнішнього ключа до списку стовпців, які ви хочете отримати.

<a name="eager-loading-by-default"></a>

#### Нетерпеляче завантаження за замовчуванням

Іноді потрібне постійне завантаження деяких відношень при вийманні моделі. Для цього ви можете визначити властивість `$with` у моделі:

```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class Book extends Model
{
	/**
	 * Відношення, які завжди мають бути завантажені.
	 *
	 * @var array
	 */
	protected $with = ['author'];

	/**
	 * Отримати автор книги.
	 */
	public function author()
	{
		return $this->belongsTo(Author::class);
	}

	/**
	 * Отримати жанр книги.
	 */
	public function genre()
	{
		return $this->belongsTo(Genre::class);
	}
}
```

Якщо ви хочете видалити елемент із властивості `$with` для одного запита, ви можете використати метод `without`:

```php
$books = Book::without('author')->get();
```

Якщо ви бажаєте перевизначити всі елементи у властивості `$with` для одного запита, ви можете використати метод `withOnly`:

```php
$books = Book::withOnly('genre')->get();
```

<a name="constraining-eager-loads"></a>

### Обмеження нетерплячих завантажень

Іноді потрібне нетерпляче завантаження відношень із зазначенням додаткової умови для запита нетерплячого завантаження. Ви можете досягти цього, передавши масив відношень у метод `with`, де ключ масива є ім’ям відношення, а значення масива є замикання, яке додає додаткові обмеження до запита на швидке завантаження:

```php
use App\Models\User;

$users = User::with(['posts' => function ($query) {
	$query->where('title', 'like', '%code%');
}])->get();
```

У цьому прикладі Eloquent завантажуватиме лише ті пости, стовпець `title` яких містить слова `code`. Ви можете викликати інші методи [конструктора запитів](queries.md), щоб додатково налаштувати операцію швидкого завантаження:

```php
$users = User::with(['posts' => function ($query) {
	$query->orderBy('created_at', 'desc');
}])->get();
```

> **Warning**  
> Методи `limit` і `take` постачальника запитів не можна використовувати при обмеженні нетерплячого завантаження.

<a name="constraining-eager-loading-of-morph-to-relationships"></a>

#### Обмеження нетерплячого завантаження відношень `morphTo`

Якщо ви бажаєте завантажити відношення morphTo, Eloquent виконає кілька запитів, щоб отримати кожен тип пов’язаної моделі. Ви можете додати додаткові обмеження до кожного з цих запитів, використовуючи метод `constrain` поліморфного відношення `MorphTo`:

```php
use Illuminate\Database\Eloquent\Builder;
use Illuminate\Database\Eloquent\Relations\MorphTo;

$comments = Comment::with(['commentable' => function (MorphTo $morphTo) {
	$morphTo->constrain([
		Post::class => function (Builder $query) {
			$query->whereNull('hidden_at');
		},
		Video::class => function (Builder $query) {
			$query->where('type', 'educational');
		},
	]);
}])->get();
```

У цьому прикладі Eloquent завантажуватиме лише ті пости, які не були приховані, а відео тільки з `type` як "освітнє".

<a name="lazy-eager-loading"></a>

### Нетерпляче пост-завантаження

Іноді потрібно завантажити нетерпляче відношення тільки після отримання батьківської моделі. Наприклад, це може бути корисно, якщо вам потрібно динамічно вирішувати, чи завантажувати пов'язані моделі:

```php
use App\Models\Book;

$books = Book::all();

if ($someCondition) {
	$books->load('author', 'publisher');
}
```

Якщо вам потрібно встановити додаткові обмеження запиту нетерплячого завантаження, ви можете передати масив з ключем відношень, які ви хочете завантажити. Значення масиву мають бути екземплярами замикання, які отримають екземпляр запита:

```php
$author->load(['books' => function ($query) {
	$query->orderBy('published_date', 'asc');
}]);
```

Щоб завантажити відношення лише тоді, коли воно ще не завантажено, використовуйте метод `loadMissing`:

```php
$book->loadMissing('author');
```

<a name="nested-lazy-eager-loading-morphto"></a>

#### Вкладене нетерпляче пост-завантаження та відношення `morphTo`

Якщо ви бажаєте швидко завантажити відношення `morphTo`, а також вкладені відношення для різних сутностей, які можуть бути повернуті цим зв’язком, ви можете скористатися методом `loadMorph`.

Цей метод приймає ім’я відношення `morphTo` як перший аргумент, а масив пар модель/відношення – як другий аргумент. Щоб проілюструвати цей метод, розглянемо таку модель:

```php
<?php

use Illuminate\Database\Eloquent\Model;

class ActivityFeed extends Model
{
	/**
	 * Отримати батьківський елемент запису стрічки активності.
	 */
	public function parentable()
	{
		return $this->morphTo();
	}
}
```

У цьому прикладі припустимо, що моделі `Event`, `Photo`, і `Post` можуть створювати моделі `ActivityFeed`. Крім того, припустимо, що моделі `Event` належать до моделі `Calendar`, моделі фотографій пов’язані з моделями `Tag`, а моделі `Post` належать до моделі `Author`.

Використовуючи ці визначення моделей і відношення, ми можемо отримати екземпляри моделі `ActivityFeed` і нетерпляче завантажувати всі батьківські моделі та їхні відповідні вкладені відношення:

```php
$activities = ActivityFeed::with('parentable')
	->get()
	->loadMorph('parentable', [
		Event::class => ['calendar'],
		Photo::class => ['tags'],
		Post::class => ['author'],
	]);
```

<a name="preventing-lazy-loading"></a>

### Запобігання відкладеному завантаженню

Як обговорювалося раніше, нетерпляче завантаження відношень найчастіше забезпечує значний виграш у продуктивності вашого додатку. Тому, якщо хочете, ви можете вкзатати Laravel завжди попереджувати відкладене завантаження відношень. Щоб досягти цього, ви можете викликати метод `preventLazyLoading`, запропонований базовим класом моделі Eloquent. Як правило, ви повинні викликати цей метод у методі `boot` класу `AppServiceProvider` вашого додатка.

Метод `preventLazyLoading` приймає необов’язковий логічний аргумент, який вказує, чи слід попередити відкладене завантаження. Наприклад, ви можете попередити відкладене завантаження тільки у не експлуатаційних оточеннях, щоб ваш додаток в експлуатаційному оточенні продовжував нормально функціонувати, навіть якщо в коді випадково присутнє відкладене завантаження відношення:

```php
use Illuminate\Database\Eloquent\Model;

/**
 * Завантаження будь-яких служб додатка.
 *
 * @return void
 */
public function boot()
{
    Model::preventLazyLoading(! $this->app->isProduction());
}
```

Після попередження відкладеного завантаження, Eloquent буде генерувати виняток `Illuminate\Database\LazyLoadingViolationException`, коли ваш додаток спробує відкласти завантаження будь-якого відношення Eloquent.

Ви можете налаштувати поведінку порушень відкладеного завантаження за допомогою методу `handleLazyLoadingViolationsUsing`. Наприклад, використовуючи цей метод, ви можете вказати лише реєструвати порушення відкладеного завантаження, а не переривати виконання додатка з винятками:

```php
Model::handleLazyLoadingViolationUsing(function ($model, $relation) {
    $class = get_class($model);

    info("Attempted to lazy load [{$relation}] on model [{$class}].");
});
```

<a name="inserting-and-updating-related-models"></a>

## Вставка та оновлення пов'язаних моделей

<a name="the-save-method"></a>

### Метод `save`

Eloquent пропонує зручні методи додавання нових моделей до відношень. Наприклад, можливо, вам потрібно додати новий коментар до публікації. Замість того, щоб вручну встановлювати атрибут `post_id` у моделі `Comment`, ви можете вставити коментар за допомогою метода відношення `save`:

```php
use App\Models\Comment;
use App\Models\Post;

$comment = new Comment(['message' => 'A new comment.']);

$post = Post::find(1);

$post->comments()->save($comment);
```

Зверніть увагу, що ми не отримали доступ до відношення `comments` як до динамічної властивості. Замість цього ми викликали метод `comments`, щоб отримати екземпляр відношення. Метод `save` автоматично додасть відповідне значення `post_id` до нової моделі `Comment`.

Якщо вам потрібно зберегти кілька зв'язаних моделей, ви можете використовувати метод `saveMany`:

```php
$post = Post::find(1);

$post->comments()->saveMany([
	new Comment(['message' => 'A new comment.']),
	new Comment(['message' => 'Another new comment.']),
]);
```

Методи `save` і `saveMany` збережуть передані екземпляри моделі. Ці методи не будуть додавати нові збережені моделі до будь-яких раніше завантажених у батьківську модель відношень, які зберігаються в пам'яті. Якщо ви плануєте отримати доступ до відношень після використання методів `save` і `saveMany`, ви можете використовувати метод `refresh` для перезавантаження моделі та її відношень:

```php
$post->comments()->save($comment);

$post->refresh();

// Усі коментарі, включаючи нещодавно збережений коментар...
$post->comments;
```

<a name="the-push-method"></a>

#### Рекурсивне збереження моделей та відношень

Якщо ви бажаєте зберегти свою модель і всі пов’язані з нею відношення, ви можете скористатися методом `push`. У цьому прикладі буде збережено модель `Post`, а також її коментарі разом з авторами:

```php
$post = Post::find(1);

$post->comments[0]->message = 'Message';
$post->comments[0]->author->name = 'Author Name';

$post->push();
```

<a name="the-create-method"></a>

### Метод `create`

На додаток до методів `save` і `saveMany` ви також можете використовувати метод `create`, який приймає масив атрибутів, створює модель і вставляє її в базу даних. Різниця між `save` і `create` полягає в тому, що `save` приймає повний екземпляр моделі Eloquent, тоді як `create` приймає звичайний масив PHP. Новостворену модель буде повернено методом `create`:

```php
use App\Models\Post;

$post = Post::find(1);

$comment = $post->comments()->create([
	'message' => 'A new comment.',
]);
```

Ви можете використовувати метод `createMany` для створення кількох пов’язаних моделей:

```php
$post = Post::find(1);

$post->comments()->createMany([
	['message' => 'A new comment.'],
	['message' => 'Another new comment.'],
]);
```

Ви також можете використовувати методи `findOrNew`, `firstOrNew`, `firstOrCreate`, і `updateOrCreate` для [створення та оновлення відношень моделей](eloquent.md#upserts).

> **Note**  
> Перед використанням метода `create` обов'язково ознайомтесь із документацією про [масове присвоєння](eloquent.md#mass-assignment) атрибутів.

<a name="updating-belongs-to-relationships"></a>

### Оновлення відношень Один До

Якщо ви хочете призначити дочірню модель новій батьківській моделі, ви можете скористатися методом `associate`. У цьому прикладі модель `User` визначає зв’язок `belongsTo` до моделі `Account` Цей асоційований метод встановить зовнішній ключ у дочірній моделі:

```php
use App\Models\Account;

$account = Account::find(10);

$user->account()->associate($account);

$user->save();
```

Щоб видалити батьківську модель із дочірньої моделі, ви можете використати метод `dissociate`. Цей метод встановить зовнішній ключ відношення на `null`:

```php
$user->account()->dissociate();

$user->save();
```

<a name="updating-many-to-many-relationships"></a>

### Відношення «багато до багатьох».

<a name="attaching-detaching"></a>

#### Прикріплення / Від’єднання

Eloquent також надає методи, які роблять роботу з відношеннями «багато до багатьох» зручнішими. Наприклад, уявімо, що користувач може мати багато ролей, а роль може мати багато користувачів. Ви можете використовувати метод `attach`, щоб прикріпити роль до користувача, вставивши запис у проміжну таблицю відношень:

```php
use App\Models\User;

$user = User::find(1);

$user->roles()->attach($roleId);
```

Під час приєднання відношення до моделі ви також можете передати масив додаткових даних, які потрібно вставити в проміжну таблицю:

```php
$user->roles()->attach($roleId, ['expires' => $expires]);
```

Іноді може знадобитися видалити роль користувача. Щоб видалити запис відношення «багато-до-багатьох», використовуйте метод `detach`. Метод `detach` видалить відповідний запис із проміжної таблиці; однак обидві моделі залишаться в базі даних:

```php
// Відокремити одну роль від користувача...
$user->roles()->detach($roleId);

// Від’єднати всі ролі від користувача...
$user->roles()->detach();
```

Для зручності `attach` та `detach` також приймають масиви IDs як вхідні дані:

```php
$user = User::find(1);

$user->roles()->detach([1, 2, 3]);

$user->roles()->attach([
	1 => ['expires' => $expires],
	2 => ['expires' => $expires],
]);
```

<a name="syncing-associations"></a>

#### Синхронізація асоціацій

Ви також можете використовувати метод `sync` для створення асоціацій «багато-до-багатьох». Метод `sync` приймає масив ідентифікаторів для розміщення в проміжній таблиці. Всі ідентифікатори, яких немає в заданому масиві, буде видалено з проміжної таблиці. Отже, після завершення цієї операції в проміжній таблиці будуть існувати лише ідентифікатори з заданого масиву:

```php
$user->roles()->sync([1, 2, 3]);
```

Ви також можете передати додаткові значення проміжній таблиці з ідентифікаторами:

```php
$user->roles()->sync([1 => ['expires' => true], 2, 3]);
```

Якщо ви хочете вставити ті самі значення проміжної таблиці для кожного синхронізованого ідентифікатора моделі, то ви можете використовувати метод `syncWithPivotValues`:

```php
$user->roles()->syncWithPivotValues([1, 2, 3], ['active' => true]);
```

Якщо ви не хочете відокремлювати існуючі відношення, ідентифікатори яких відсутні в переданому масиві, ви можете використовувати метод `syncWithoutDetaching` :

```php
$user->roles()->syncWithoutDetaching([1, 2, 3]);
```

<a name="toggling-associations"></a>

#### Переключення асоціацій відношень Багато до Багатьох

Відношення «багато-до-багатьох» також містить метод `toggle`, який «перемикає» статус приєднання зазначених ідентифікаторів зв'язаних моделей. Якщо переданий ідентифікатор приєднано, він буде від'єднаний. Аналогічно, якщо він в даний час від'єднаний, він буде приєднаний:

```php
$user->roles()->toggle([1, 2, 3]);
```

<a name="updating-a-record-on-the-intermediate-table"></a>

#### Оновлення запису проміжної таблиці відношень Багато до Багатьох

Якщо вам потрібно оновити існуючий рядок у проміжній таблиці ваших відношень, то ви можете використовувати метод `updateExistingPivot`. Цей метод приймає зовнішній ключ проміжного записа та масив атрибутів для оновлення:

```php
$user = User::find(1);

$user->roles()->updateExistingPivot($roleId, [
	'active' => false,
]);
```

<a name="touching-parent-timestamps"></a>

## Зачіпання Батьківських Міток Часу

Коли в моделі визначено методи `belongsTo` або `belongsToMany` по відношенню до іншої моделі, наприклад `Comment`, яка належить `Post`, то іноді буває необхідно оновити батьківську часову мітку при оновленні дочірньої моделі.

Наприклад, коли модель `Comment` оновлюється, ви можете автоматично зачіпити часові мітки `updated_at` батьківської моделі `Post`, щоб вона була встановлена ​​на поточну дату і час. Для цього ви можете додати властивість `touches` до дочірньої моделі, що містить імена відношень, для яких повинні оновлюватися часові мітки `updated_at` при оновленні дочірньої моделі:

```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class Comment extends Model
{
	/**
	 * Всі відношення, часові мітки яких мають бути порушені.
	 *
	 * @var array
	 */
	protected $touches = ['post'];

	/**
	 * Отримати пост, до якого належить коментар.
	 */
	public function post()
	{
		return $this->belongsTo(Post::class);
	}
}
```

> **Warning**  
> Мітки часу батьківської моделі оновлюватимуться, лише якщо дочірню модель оновлено за допомогою метода `save` Eloquent.
