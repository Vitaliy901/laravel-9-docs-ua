# Консоль Artisan

- [Вступ](#introduction)
  - [Тінкер (REPL)](#tinker)
- [Написання команд](#writing-commands)
  - [Генерація команд](#generating-commands)
  - [Структура команди](#command-structure)
  - [Анонімні команди](#closure-commands)
- [Визначення даних, які вводяться](#defining-input-expectations)
  - [Аргументи](#arguments)
  - [Параметри](#options)
  - [Масиви даних](#input-arrays)
  - [Опис даних, які вводяться](#input-descriptions)
- [Введення/виведення команди](#command-io)
  - [Отримання вхідних даних](#retrieving-input)
  - [Запит на введення даних](#prompting-for-input)
  - [Виведення даних](#writing-output)
- [Реєстрація команд](#registering-commands)
- [Програмне виконання команд](#programmatically-executing-commands)
  - [Виклик команд з інших команд](#calling-commands-from-other-commands)
- [Обробка сигналів](#signal-handling)
- [Налаштування заготовок](#stub-customization)
- [Події](#events)

<a name="introduction"></a>

## Вступ

Artisan — це інтерфейс командного рядка, що входить до складу Laravel. Artisan існує в корені вашого додатка як сценарій `artisan` і надає ряд корисних команд, які можуть допомогти вам під час створення додатка. Щоб переглянути список всіх доступних команд Artisan, ви можете скористатися командою `list`:

```shell
php artisan list
```

Кожна команда також містить екран «довідки», який відображає та описує доступні аргументи та параметри команди. Щоб переглянути екран довідки, поставте перед назвою команди `help`:

```shell
php artisan help migrate
```

<a name="laravel-sail"></a>

#### Laravel Sail

Якщо ви використовуєте [Laravel Sail](sail.md) як локальне середовище розробки, не забувайте використовувати командний рядок `sail` для виклику команд Artisan. Sail виконуватиме ваші команди Artisan у контейнерах Docker вашої програми:

```shell
./vendor/bin/sail artisan list
```

<a name="tinker"></a>

### Tinker (REPL)

Laravel Tinker — це потужний REPL для фреймворка Laravel, що підтримується пакетом [PsySH](https://github.com/bobthecow/psysh).

<a name="installation"></a>

#### Встановлення

Всі додатки Laravel включають Tinker за замовчуванням. Однак ви можете встановити Tinker за допомогою Composer, якщо ви попередньо видалили його зі свого додатку:

```shell
composer require laravel/tinker
```

> **Note**  
> Шукаєте графічний інтерфейс для взаємодії з вашим додатком Laravel? Перевірте [Tinkerwell](https://tinkerwell.app)!

<a name="usage"></a>

#### Використання

Tinker дозволяє вам взаємодіяти з усім додатком Laravel у командному рядку, включаючи моделі Eloquent, завдання, події тощо. Щоб увійти в середовище Tinker, виконайте `tinker` команду Artisan:

```shell
php artisan tinker
```

Ви можете опублікувати файл конфігурації Tinker за допомогою команди `vendor:publish`:

```shell
php artisan vendor:publish --provider="Laravel\Tinker\TinkerServiceProvider"
```

> **Warning**  
> Глобальний помічник `dispatch` та метод `dispatch` класа `Dispatchable` залежать від "garbage collection" для розміщення завдання у чергу. Отже, при використанні Tinker ви повинні використовувати `Bus::dispatch` або `Queue::push` для надсилання завдань.

<a name="command-allow-list"></a>

#### Список дозволених команд

Tinker використовує список "дозволених" команд, щоб визначити, які команди Artisan дозволено виконувати в його оболонці. За замовчуванням ви можете запускати команди `clear-compiled`, `down`, `env`, `inspire`, `migrate`, `optimize`, і `up`. Якщо ви хочете дозволити більше команд, ви можете додати їх до масиву команд у вашому конфігураційному файлі tinker.php:

```php
'commands' => [
    // App\Console\Commands\ExampleCommand::class,
],
```

<a name="classes-that-should-not-be-aliased"></a>

#### Класи, які не повинні мати псевдоніми

Як правило, Tinker автоматично створює псевдоніми для класів, коли ви взаємодієте з ними в Tinker. Однак ви можете забажати ніколи не використовувати псевдоніми для деяких класів. Ви можете зробити це, перерахувавши класи в масиві `dont_alias` вашого файлу конфігурації `tinker.php`:

```php
'dont_alias' => [
    App\Models\User::class,
],
```

<a name="writing-commands"></a>

## Написання команд

На додаток до команд, наданих з Artisan, ви можете створювати власні команди. Команди зазвичай зберігаються в каталозі `app/Console/Commands`; однак ви можете обрати власне місце зберігання, якщо ці команди можуть бути завантажені менеджером Composer.

<a name="generating-commands"></a>

### Генерація команд

Щоб створити нову команду, ви можете використати Artisan команду `make:command`. Ця команда створить новий клас команд у каталозі `app/Console/Commands`. Не хвилюйтеся, якщо цей каталог не існує у вашому додатку – він буде створений під час першого запуску команди `make:command` Artisan:

```shell
php artisan make:command SendEmails
```

<a name="command-structure"></a>

### Структура команди

Після створення команди ви повинні визначити відповідні значення для властивостей `signature` і `description` класа. Ці властивості використовуватимуться під час відображення вашої команди на `list` екрані. Властивість `signature` також дозволяє вам визначити [дані команд, які вводяться](#defining-input-expectations). Метод `handle` буде викликаний під час виконання вашої команди. Ви можете розмістити свою командну логіку в цьому методі.

Розглянемо приклад команди. Зверніть увагу, що ми можемо запросити будь-які необхідні залежності метода `handle` команди. [Контейнер служб](container.md) Laravel автоматично впровадить всі залежності, типи яких оголошені у цьому методі:

```php
    <?php

    namespace App\Console\Commands;

    use App\Models\User;
    use App\Support\DripEmailer;
    use Illuminate\Console\Command;

    class SendEmails extends Command
    {
        /**
         * Назва та сигнатура консольної команди.
         *
         * @var string
         */
        protected $signature = 'mail:send {user}';

        /**
         * Опис консольної команди.
         *
         * @var string
         */
        protected $description = 'Send a marketing email to a user';

        /**
         * Виконайте консольну команду.
         *
         * @param  \App\Support\DripEmailer  $drip
         * @return mixed
         */
        public function handle(DripEmailer $drip)
        {
            $drip->send(User::find($this->argument('user')));
        }
    }
```

> **Note**  
> Хорошою практикою повторного використання коду вважається створення «простих» консольних команд із делегуванням своїх завдань службам додатка. Зверніть увагу на те, що у наведеному вище прикладі ми додаємо клас обслуговування, щоб виконувати «важку роботу» надсилання електронних листів.

<a name="closure-commands"></a>

### Анонімні команди

Команди на основі замикання є альтернативою для консольних команд як класів. Подібно до того, як замикання маршрутів є альтернативою контролерам, думайте про замикання команд як про альтернативу класам команд. У методі `commands` вашого файла `app/Console/Kernel.php` Laravel завантажує файл `routes/console.php`:

```php
/**
 * Зареєструйте команди на основі замикання для додатка.
 *
 * @return void
 */
protected function commands()
{
    require base_path('routes/console.php');
}
```

Незважаючи на те, що цей файл не визначає маршрути HTTP, він визначає консольні точки входу (маршрути) у ваш додаток. У цьому файлі ви можете визначити всі консольні команди на основі замикання за допомогою метода `Artisan::command`. Метод `command` приймає два аргументи: [підпис команди](#defining-input-expectations) та замикання, яке отримує аргументи та параметри команди:

```php
Artisan::command('mail:send {user}', function ($user) {
    $this->info("Sending email to: {$user}!");
});
```

Замикання прив’язане до базового екземпляра команди, тому ви маєте повний доступ до всіх допоміжних методів, до яких зазвичай маєте доступ у створеному класі команд.

<a name="type-hinting-dependencies"></a>

#### Типізація залежностей

Окрім отримання аргументів та параметрів, замикання анонімної команди також приймає додаткові залежності з [контейнером служби](container.md), які необхідні для впровадження:

```php
use App\Models\User;
use App\Support\DripEmailer;

Artisan::command('mail:send {user}', function (DripEmailer $drip, $user) {
    $drip->send(User::find($user));
});
```

<a name="closure-command-descriptions"></a>

#### Описи анонімних команд

Визначаючи команду на основі замикання, ви можете використовувати метод `purpose`, щоб додати опис до команди. Цей опис відображатиметься під час запуску `php artisan list` або команди `php artisan help`:

```php
Artisan::command('mail:send {user}', function ($user) {
    // ...
})->purpose('Send a marketing email to a user');
```

<a name="defining-input-expectations"></a>

## Визначення даних, які вводяться

Під час написання консольних команд зазвичай збирають дані від користувача за допомогою аргументів або параметрів. Laravel дозволяє дуже зручно визначати введення, яке ви очікуєте від користувача, використовуючи властивість `signature` у ваших командах. Властивість `signature` дозволяє вам визначати ім’я, аргументи та параметри для команди в єдиному виразному синтаксисі, схожому на маршрут.

<a name="arguments"></a>

### Аргументи

Всі надані користувачем аргументи та параметри загортаються у фігурні дужки. У наступному прикладі команда визначає один обов’язковий аргумент: `user`:

```php
/**
 * Назва та підпис консольної команди.
 *
 * @var string
 */
protected $signature = 'mail:send {user}';
```

Ви також можете зробити аргументи необов’язковими або визначити значення за замовчанням для аргументів:

```php
// Необов'язковий аргумент...
'mail:send {user?}'

// Необов'язковий аргумент зі значенням за замовчанням...
'mail:send {user=foo}'
```

<a name="options"></a>

### Параметри

Параметри, як і аргументи, є різновидом користувацького введення. Параметри починаються двома дефісами (`--`), якщо вони надаються через командний рядок. Існує два типи параметрів: ті, що отримують значення, і ті, що не отримують. Параметри, які не отримують значення, служать логічним "перемикачем". Давайте розглянемо приклад такого варіанту:

```php
/**
 * Назва та підпис консольної команди.
 *
 * @var string
 */
protected $signature = 'mail:send {user} {--queue}';
```

У цьому прикладі під час виклику команди Artisan можна вказати перемикач `--queue`. Якщо передано перемикач `--queue`, значення параметра буде `true`. В іншому випадку значення буде `false`:

```shell
php artisan mail:send 1 --queue
```

<a name="options-with-values"></a>

#### Параметри зі значеннями

Далі розглянемо параметр, який очікує значення. Якщо користувач повинен вказати значення для параметра, ви повинні додати до назви суфікс `=`:

```php
/**
 * Назва та підпис консольної команди.
 *
 * @var string
 */
protected $signature = 'mail:send {user} {--queue=}';
```

У цьому прикладі користувач може передати значення для параметра таким чином. Якщо параметр не вказано під час виклику команди, його значення буде `null`:

```shell
php artisan mail:send 1 --queue=default
```

Ви можете призначити параметрам значення за замовчуванням, вказавши значення після назви параметра. Якщо користувач не передасть значення параметру, буде використано значення за замовчуванням:

```php
'mail:send {user} {--queue=default}'
```

<a name="option-shortcuts"></a>

#### Псевдоніми параметрів

Щоб призначити псевдонім під час визначення параметра, ви можете вказати його перед назвою опції та використати `|` символ як дільник, щоб відокремити псевдонім від повної назви параметра:

```php
    'mail:send {user} {--Q|queue}'
```

Під час виклику команди у вашому терміналі псевдоніми параметрів повинні мати префікс із одним дефісом:

```shell
php artisan mail:send 1 -Q
```

<a name="input-arrays"></a>

### Вхідні масиви

Якщо ви бажаєте визначити аргументи або параметри, які очікуватимуть масив даних, ви можете використовувати символ `*`. По-перше, давайте подивимося на приклад, в якому аргуметн визначається як масив даних:

```php
'mail:send {user*}'
```

При виклику цього метода аргументи `user` можуть передаватися послідовно в командний рядок. Наприклад, наступна команда встановить значення `user` як масив зі значеннями 1 та 2:

```shell
php artisan mail:send 1 2
```

Символ `*` можна комбінувати з необов'язковим визначенням аргумента, щоб дозволити нуль або більше екземплярів аргумента:

```php
'mail:send {user?*}'
```

<a name="option-arrays"></a>

#### Масиви параметрів

Під час визначення параметра, який очікує декілька вхідних значень, перед кожним значенням параметра, переданим командою, має бути префікс назви параметра:

```php
'mail:send {--id=*}'
```

Таку команду можна викликати шляхом передачі кількох аргументів `--id`:

```shell
php artisan mail:send --id=1 --id=2
```

<a name="input-descriptions"></a>

### Описи введених даних

Ви можете призначити описи вхідним аргументам і параметрам, відокремивши назву аргументу від описа двокрапкою. Якщо вам потрібен додатковий простір для визначення вашої команди, не соромтеся розподілити визначення між кількома рядками:

```php
/**
 * Назва та підпис консольної команди.
 *
 * @var string
 */
protected $signature = 'mail:send
                        {user : The ID of the user}
                        {--queue : Whether the job should be queued}';
```

<a name="command-io"></a>

## Введення/виведення команди

<a name="retrieving-input"></a>

### Отримання вхідних даних

Під час виконання вашої команди вам, ймовірно, знадобиться отримати доступ до значень аргументів і параметрів, прийнятих вашою командою. Для цього ви можете використовувати методи `argument` і `option`. Якщо аргумент або параметр не існує, буде повернено значення `null`:

```php
/**
 * Виконайте консольну команду
 *
 * @return int
 */
public function handle()
{
    $userId = $this->argument('user');

    //
}
```

Якщо вам потрібно отримати всі аргументи як `array`, викличте метод `arguments`:

```php
$arguments = $this->arguments();
```

Параметри можна отримати так само легко, як і аргументи, використовуючи метод `option`. Щоб отримати всі параметри як масив, викличте метод `options`:

```php
// Отримати певний параметр...
$queueName = $this->option('queue');

// Отримати всі параметри у вигляді масиву...
$options = $this->options();
```

<a name="prompting-for-input"></a>

### Запит на введення даних

Окрім відображення вихідних даних, ви також можете попросити користувача надати вхідні дані під час виконання вашої команди. Метод `ask` запропонує користувачу виначене запитання, прийме його введення, а потім поверне введені ним дані назад до вашої команди:

```php
/**
 * Виконайте консольну команду.
 *
 * @return mixed
 */
public function handle()
{
    $name = $this->ask('What is your name?');
}
```

Метод `secret` подібний до `ask`, але введені користувачем дані не будуть видимі під час введення в консолі. Цей метод корисний, коли запитують конфіденційну інформацію, наприклад паролі:

```php
$password = $this->secret('What is the password?');
```

<a name="asking-for-confirmation"></a>

#### Запит на підтвердження

Якщо вам потрібно попросити користувача про просте підтвердження «так чи ні», ви можете скористатися методом `confirm`. За замовчуванням цей метод повертає `false`. Однак, якщо користувач введе `y` або `yes` у ​​відповідь на запит, метод поверне `true`.

```php
if ($this->confirm('Do you wish to continue?')) {
    //
}
```

Якщо необхідно, ви можете вказати, що запит підтвердження має повертати значення `true` за замовчуванням, передавши `true` як другий аргумент методу `confirm`:

```php
if ($this->confirm('Do you wish to continue?', true)) {
    //
}
```

<a name="auto-completion"></a>

#### Автозавершення

Метод `anticipate` можна використовувати для забезпечення автоматичного завершення можливих варіантів. Користувач все ще може дати будь-яку відповідь, незалежно від підказок автозавершення:

```php
    $name = $this->anticipate('What is your name?', ['Taylor', 'Dayle']);
```

Крім того, ви можете передати замикання як другий аргумент методу `anticipate`. Замикання буде викликано кожного разу, коли користувач вводить символ. Замикання має приймати рядковий параметр, що містить введені користувачем дані, і повертати масив параметрів для автозавершення:

```php
$name = $this->anticipate('What is your address?', function ($input) {
    // Повернути параметри автозаповнення...
});
```

<a name="multiple-choice-questions"></a>

#### Запитання з можливістю обрати відповідь

Якщо вам потрібно надати користувачеві заздалегідь визначений набір варіантів під час постановки запитання, ви можете скористатися методом `choice`. Ви можете встановити індекс масива значення за замовчуванням, який повертатиметься, якщо не обрано жодного параметра, передавши індекс як третій аргумент методу:

```php
$name = $this->choice(
    'What is your name?',
    ['Taylor', 'Dayle'],
    $defaultIndex
);
```

Крім того, метод `choice` приймає необов’язковий четвертий і п’ятий аргументи для визначення максимальної кількості спроб вибрати дійсну відповідь і чи дозволено багаторазовий вибір:

```php
$name = $this->choice(
    'What is your name?',
    ['Taylor', 'Dayle'],
    $defaultIndex,
    $maxAttempts = null,
    $allowMultipleSelections = false
);
```

<a name="writing-output"></a>

### Виведення данних

Щоб надіслати вихідні дані на консоль, ви можете використовувати методи `line`, `info`, `comment`, `question`, `warn`, і `error`. Кожен із цих методів використовуватиме відповідні кольори ANSI для своєї мети. Наприклад, відобразимо деяку загальну інформацію для користувача. Як правило, метод `info` відображатиметься на консолі як текст зеленого кольору:

```php
/**
 * Виконайте консольну команду.
 *
 * @return mixed
 */
public function handle()
{
    // ...

    $this->info('The command was successful!');
}
```

Щоб відобразити повідомлення про помилку, використовуйте метод `error`. Текст повідомлення про помилку зазвичай відображається червоним кольором:

```php
$this->error('Something went wrong!');
```

Ви можете використовувати метод `line` для відображення простого незабарвленого тексту:

```php
$this->line('Display this on the screen');
```

Ви можете використовувати метод `newLine` для відображення порожнього рядка:

```php
// Напишіть один порожній рядок...
$this->newLine();

// Напишіть три порожні рядки...
$this->newLine(3);
```

<a name="tables"></a>

#### Таблиці

Метод `table` дозволяє легко і правильно форматувати кілька рядків/стовпців даних. Все, що вам потрібно зробити, це вказати назви стовпців і дані для таблиці, і Laravel автоматично розрахує для вас відповідну ширину та висоту таблиці:

```php
use App\Models\User;

$this->table(
    ['Name', 'Email'],
    User::all(['name', 'email'])->toArray()
);
```

<a name="progress-bars"></a>

#### Індикатори прогресу

Для тривалих завдань може бути корисним показ індикатора виконання, який інформує користувачів про те, наскільки виконано завдання. Використовуючи метод `withProgressBar`, Laravel відображатиме індикатор прогресу та просуватиме прогрес для кожної ітерації на задане ітераційне значення:

```php
use App\Models\User;

$users = $this->withProgressBar(User::all(), function ($user) {
    $this->performTask($user);
});
```

Іноді вам може знадобитися більше ручного контролю над тим, як розгортається індикатор прогресу. По-перше, визначте загальну кількість кроків, які буде проходити процес. Потім перемістіть індикатор прогресу після обробки кожного елемента:

```php
$users = App\Models\User::all();

$bar = $this->output->createProgressBar(count($users));

$bar->start();

foreach ($users as $user) {
    $this->performTask($user);

    $bar->advance();
}

$bar->finish();
```

> **Note**  
> Для отримання додаткових параметрів перегляньте [документацію компонента Symfony Progress Bar](https://symfony.com/doc/current/components/console/helpers/progressbar.html).

<a name="registering-commands"></a>

## Реєстрація команд

Всі консольні команди зареєстровано в класі `App\Console\Kernel`, який є «ядром консолі» вашого додатка. У методі `commands` цього класу ви побачите виклик метода `load` ядра. Метод `load` сканує каталог `app/Console/Commands` і автоматично реєструє кожну команду, яку він містить, до Artisan. Ви навіть можете робити додаткові виклики метода `load` для сканування інших каталогів на наявність команд Artisan:

```php
/**
 * Зареєструйте команди для додатка.
 *
 * @return void
 */
protected function commands()
{
    $this->load(__DIR__.'/Commands');
    $this->load(__DIR__.'/../Domain/Orders/Commands');

    // ...
}
```

За потреби ви можете вручну зареєструвати команди, додавши назву класа команди до властивості `$commands` у своєму класі `App\Console\Kernel`. Якщо ця властивість ще не визначена у вашому ядрі, вам слід визначити її вручну. Під час завантаження Artisan всі команди, перелічені в цій властивості, будуть доступні у [контейнері служб](container.md) та зареєстровані в Artisan:

```php
protected $commands = [
    Commands\SendEmails::class
];
```

<a name="programmatically-executing-commands"></a>

## Програмне виконання команд

Іноді вам може знадобитися виконати команду Artisan поза CLI. Наприклад, ви можете виконати команду Artisan з маршруту або контролера. Для цього можна використати метод `call` фасада `Artisan`. Метод `call` приймає назву підпису команди, або назву класу першим аргументом, і масив параметрів команди другим аргументом. Буде повернено код виходу:

```php
use Illuminate\Support\Facades\Artisan;

Route::post('/user/{user}/mail', function ($user) {
    $exitCode = Artisan::call('mail:send', [
        'user' => $user, '--queue' => 'default'
    ]);

    //
});
```

Крім того, ви можете передати всю команду Artisan методу `call` як рядок:

```php
Artisan::call('mail:send 1 --queue=default');
```

<a name="passing-array-values"></a>

#### Передача масива значень

Якщо ваша команда визначає параметр, який приймає масив, ви можете передати цьому параметру масив значень:

```php
use Illuminate\Support\Facades\Artisan;

Route::post('/mail', function () {
    $exitCode = Artisan::call('mail:send', [
        '--id' => [5, 13]
    ]);
});
```

<a name="passing-boolean-values"></a>

#### Передача логічних значень

Якщо вам потрібно вказати значення параметра, який не приймає рядкових значень, як-от прапорець --force у команді migrate:refresh, вам слід передати значення `true` або `false` як значення параметра:

```php
$exitCode = Artisan::call('migrate:refresh', [
    '--force' => true,
]);
```

<a name="queueing-artisan-commands"></a>

#### Черги команд Artisan

Використовуючи метод `queue` фасада Artisan, ви навіть можете поставити команди Artisan у чергу, щоб вони оброблялися вашими [обробниками черги](queues.md) у фоновому режимі. Перш ніж використовувати цей метод, переконайтеся, що ви налаштували свою чергу та запустили слухача черги:

```php
use Illuminate\Support\Facades\Artisan;

Route::post('/user/{user}/mail', function ($user) {
    Artisan::queue('mail:send', [
        'user' => $user, '--queue' => 'default'
    ]);

    //
});
```

Використовуючи методи `onConnection` і `onQueue`, ви можете вказати підключення або чергу, до якої має бути надіслана команда Artisan:

```php
Artisan::queue('mail:send', [
    'user' => 1, '--queue' => 'default'
])->onConnection('redis')->onQueue('commands');
```

<a name="calling-commands-from-other-commands"></a>

### Виклик команд з інших команд

Іноді ви можете викликати інші команди з існуючої команди Artisan. Ви можете зробити це за допомогою метода `call`. Цей метод `call` приймає назву команди та масив аргументів / параметрів команди:

```php
/**
 * Виконання консольних команд.
 *
 * @return mixed
 */
public function handle()
{
    $this->call('mail:send', [
        'user' => 1, '--queue' => 'default'
    ]);

    //
}
```

Якщо ви хочете викликати іншу консольну команду в тихому режимі, використовуйте метод `callSilently`. Метод `callSilently` має ту саму сигнатуру, що й метод call:

```php
$this->callSilently('mail:send', [
    'user' => 1, '--queue' => 'default'
]);
```

<a name="signal-handling"></a>

## Обробка сигналів

Компонент Symfony Console, який підтримує консоль Artisan, дозволяє вам вказати, які [сигнали процесу](<https://ru.wikipedia.org/wiki/Сигнал_(Unix)>) (якщо такі є) може обробляти ваша команда. Наприклад, ви можете вказати, що ваша команда обробляє сигнали `SIGINT` and `SIGTERM`.

Щоб почати, вам слід реалізувати інтерфейс `Symfony\Component\Console\Command\SignalableCommandInterface` у вашому класі команд Artisan. Для цього інтерфейсу потрібно визначити два методи: `getSubscribedSignals` і `handleSignal`:

```php
<?php

use Symfony\Component\Console\Command\SignalableCommandInterface;

class StartServer extends Command implements SignalableCommandInterface
{
    // ...

    /**
     * Отримайте список сигналів, які обробляє команда.
     *
     * @return array
     */
    public function getSubscribedSignals(): array
    {
        return [SIGINT, SIGTERM];
    }

    /**
     * Обробка вхідного сигналу.
     *
     * @param  int  $signal
     * @return void
     */
    public function handleSignal(int $signal): void
    {
        if ($signal === SIGINT) {
            $this->stopServer();

            return;
        }
    }
}
```

Як і слід було очікувати, метод `getSubscribedSignals` має повертати масив сигналів, які може обробити ваша команда, тоді як метод `handleSignal` отримує сигнал і може відповідати відповідним чином.

<a name="stub-customization"></a>

## Налаштування заготовок

Команди `make` консолі Artisan використовуються для створення різноманітних класів, таких як контроллери, завдання, міграції та тести. Ці класи створюються за допомогою файлів-заготовок, які заповнюються значеннями на основі введених вами даних. Однак ви можете внести невеликі зміни до файлів, створених Artisan. Щоб досягти цього, ви можете використати команду `stub:publish`, для публікації найпоширеніших заготовок у вашому додатку, які потім ви можете налаштувати:

```shell
php artisan stub:publish
```

Опубліковані заготовки будуть розташовані в каталозі `stubs` у корені вашого додатка. Будь-які зміни, які ви вносите в ці заготовки, будуть відображені під час створення відповідних класів за допомогою команд `make` Artisan.

<a name="events"></a>

## Події

Під час виконання команд Artisan надсилає три події: `Illuminate\Console\Events\ArtisanStarting`, `Illuminate\Console\Events\CommandStarting` і `Illuminate\Console\Events\CommandFinished`. Подія `ArtisanStarting` надсилається негайно, коли Artisan починає працювати. Далі подія CommandStarting надсилається безпосередньо перед виконанням команди. Нарешті, подія `CommandFinished` надсилається, коли команда завершує виконання.
