# HTTP сесія

- [Вступ](#introduction)
  - [Налаштування](#configuration)
  - [Попередня підготовка драйверів](#driver-prerequisites)
- [Взаємодія з сесією](#interacting-with-the-session)
  - [Отримання даних](#retrieving-data)
  - [Збереження даних](#storing-data)
  - [Тимчасові дані](#flash-data)
  - [Видалення даних](#deleting-data)
  - [Перевизначення ID сесії](#regenerating-the-session-id)
- [Блокування сесії](#session-blocking)
- [Додавання власних драйверів сесії](#adding-custom-session-drivers)
  - [Реалізація власного драйвера](#implementing-the-driver)
  - [Реєстрація власного драйвера](#registering-the-driver)

<a name="introduction"></a>

## Вступ

Оскільки додатки, які використовують HTTP, не мають стану, сесії забезпечують спосіб зберігання інформації про користувача між декількома запитами. Ця інформація про користувача зазвичай розміщується в постійному сховищі/сервері, доступ до якого можна отримати з наступних запитів.

Laravel пропонує безліч різних типів сховищ сесій, доступ до яких здійснюється через виразний уніфікований API. Здійснено підтримку популярних типів сховищ, таких як [Memcached](https://memcached.org), [Redis](https://redis.io) та база даних.

<a name="configuration"></a>

### Налаштування

Конфігураційний файл сесії вашого додатка зберігається в `config/session.php`. Перегляньте доступні для вас параметри в цьому файлі. За замовчуванням Laravel налаштовано на використання драйвера `file` сесії, який добре працюватиме для багатьох додатків. Якщо ваш додаток розподілятиме навантаження на декількох веб-серверах, вам слід обрати централізоване сховище, до якого матимуть доступ всі сервери, наприклад Redis або базу даних.

Параметр конфігурації `driver` сесії визначає, де будуть зберігатися дані сеанса для кожного запита. Laravel поставляється з кількома чудовими драйверами з коробки:

<div class="content-list" markdown="1">

- `file` - сесії зберігаються в `storage/framework/sessions`.
- `cookie` - сесії зберігаються в безпечних зашифрованих файлах cookie.
- `database` - сесії зберігаються в реляційній базі даних.
- `memcached` / `redis` - сеанси зберігаються в одному з цих швидких сховищ на основі кешу.
- `dynamodb` - сесії зберігаються в AWS DynamoDB.
- `array` - сесії зберігаються в масиві PHP і не будуть збережені.

</div>

> **Note**  
> Драйвер масива в основному використовується під час [тестування](testing.md), та запобігає збереженню даних, які знаходяться в сесії.

<a name="driver-prerequisites"></a>

### Попередня підготовка драйверів

<a name="database"></a>

#### База даних

Під час використання драйвера сесії `database`, вам потрібно буде створити таблицю, яка містить записи сесії. Приклад оголошення `Schema` для таблиці можна знайти нижче:

```php
Schema::create('sessions', function ($table) {
    $table->string('id')->primary();
    $table->foreignId('user_id')->nullable()->index();
    $table->string('ip_address', 45)->nullable();
    $table->text('user_agent')->nullable();
    $table->text('payload');
    $table->integer('last_activity')->index();
});
```

Ви можете використати команду Artisan `session:table` для створення цієї міграції. Щоб дізнатися більше про міграцію бази даних, ви можете переглянути повну [документацію щодо міграції](migrations.md):

```shell
php artisan session:table

php artisan migrate
```

<a name="redis"></a>

#### Redis

Перш ніж використовувати сесії Redis разом з Laravel, вам потрібно буде встановити розширення PHP PhpRedis через PECL або встановити пакет `predis/predis` (~1.0) через Composer. Для отримання додаткової інформації про налаштування Redis зверніться до [документації Laravel Redis](redis.md#configuration).

> **Note**  
> В конфігураційному файлі `session.php` можна використовувати параметр `connection`, щоб вказати, яке з’єднання Redis використовується сеансом.

<a name="interacting-with-the-session"></a>

## Взаємодія з сесією

<a name="retrieving-data"></a>

### Отримання даних

В Laravel є два основні способи роботи з даними сісії: глобальний помічник `session` та через екземпляр `Request`. По-перше, давайте подивимося на доступ до сісії через екземпляр `Request`, тип якого можна визначити в замиканні маршрута або в методі контроллера. Пам’ятайте, що залежності метода контролера автоматично впроваджуються за допомогою [контейнер служби](container.md) Laravel:

```php
<?php

namespace App\Http\Controllers;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;

class UserController extends Controller
{
    /**
     * Показати профіль даного користувача.
     *
     * @param  Request  $request
     * @param  int  $id
     * @return Response
     */
    public function show(Request $request, $id)
    {
        $value = $request->session()->get('key');

        //
    }
}
```

Коли ви отримуєте елемент з сесії, ви також можете передати значення за замовчуванням другим аргументом методу `get`. Буде повернуто значення за замовчуванням, якщо вказаний ключ не існує в сесії.

```php
$value = $request->session()->get('key', 'default');

$value = $request->session()->get('key', function () {
    return 'default';
});
```

<a name="the-global-session-helper"></a>

#### Глобальний помічник `session`

Ви також можете використовувати глобальну PHP функцію `session` для отримання та зберігання даних в сесії. Коли помічник `session` викликається з одним рядковим аргументом, він віддасть значення по цьому ключу з сесії. Коли помічник викликається з масивом пар ключ/значення, ці значення будуть збережені в сесії:

```php
Route::get('/home', function () {
    // Отримати частину даних з сесії...
    $value = session('key');

    // Визначення значення за замовчуванням...
    $value = session('key', 'default');

    // Збереження частини даних в сесію...
    session(['key' => 'value']);
});
```

> **Note**  
> Існує невелика практична різниця між використанням сесії через екземпляр запита HTTP, та використанням глобального помічника `session`. Обидва методи [тестуються](testing.md) за допомогою метода `assertSessionHas`, який доступний у всіх ваших тестових випадках.

<a name="retrieving-all-session-data"></a>

#### Отримання всіх даних сесії

Якщо ви хочете отримати всі дані з сесії, ви можете скористатися методом `all`:

```php
$data = $request->session()->all();
```

<a name="determining-if-an-item-exists-in-the-session"></a>

#### Визначення наявності елемента в сесії

Щоб визначити, чи присутній елемент в сесії, ви можете використати метод `has`. Метод `has` повертає `true`, якщо елемент присутній і не дорівнює `null`:

```php
if ($request->session()->has('users')) {
    //
}
```

Щоб визначити, чи присутній елемент в сесії, навіть якщо його значення дорівнює `null`, ви можете використати метод `exists`:

```php
if ($request->session()->exists('users')) {
    //
}
```

Щоб визначити, чи елемент відсутній в сесії, ви можете використати метод `missing`. Метод `missing` повертає `true`, якщо елемент відсутній:

```php
if ($request->session()->missing('users')) {
    //
}
```

<a name="storing-data"></a>

### Збереження даних

Щоб зберегти дані в сеансі, ви зазвичай використовуєте метод `put` екземпляра запита або глобальний помічник `session`:

```php
// За допомогою екземпляра запита...
$request->session()->put('key', 'value');

// За допомогою глобального помічника "session"...
session(['key' => 'value']);
```

<a name="pushing-to-array-session-values"></a>

#### Додавання в масив значень сесії

Метод `push` можна використовувати для додавання нового значення до існуючого значення сессії, яке є масивом. Наприклад, якщо ключ `user.teams` містить масив імен команд, ви можете ввести нове значення в масив таким чином:

```php
$request->session()->push('user.teams', 'developers');
```

<a name="retrieving-deleting-an-item"></a>

#### Отримання з видалення елемента

Метод `pull` отримає та видалить елемент з сесії в одному виразі:

```php
$value = $request->session()->pull('key', 'default');
```

<a name="#incrementing-and-decrementing-session-values"></a>

#### Збільшення та зменшення окремих значень в сесії

Якщо ваші дані сісії містять ціле число, яке ви бажаєте збільшити або зменшити, ви можете скористатися методами `increment` and `decrement`:

```php
$request->session()->increment('count');

$request->session()->increment('count', $incrementBy = 2);

$request->session()->decrement('count');

$request->session()->decrement('count', $decrementBy = 2);
```

<a name="flash-data"></a>

### Тимчасові дані

Іноді ви можете захотіти зберегти елементи в сесії лише для наступного запита. Ви можете зробити це за допомогою метода `flash`. Дані, збережені в сесії за допомогою цього метода, будуть доступні одразу та під час наступного запита HTTP. Після того як відбудеться наступний запит HTTP, тимчасові дані будуть видалені. Тимчасові дані в першу чергу корисні для короткочасних повідомлень про статус:

```php
$request->session()->flash('status', 'Task was successful!');
```

Якщо вам потрібно зберегти ваші тимчасові дані для декількох запитів, ви можете використати метод `reflash` , який збереже всі тимчасові дані для додаткового запита. Якщо вам потрібно лише зберегти певні тимчасові дані, ви можете скористатися методом `keep`:

```php
$request->session()->reflash();

$request->session()->keep(['username', 'email']);
```

Щоб зберегти тимчасові дані лише для поточного запита, ви можете використати метод `now`:

```php
$request->session()->now('status', 'Task was successful!');
```

<a name="deleting-data"></a>

### Видалення даних

Метод `forget` видалить частину даних з сесії. Якщо ви хочете видалити всі дані з сесії, ви можете скористатися методом `flush`:

```php
// Видалити окремий ключ...
$request->session()->forget('name');

// Видалити декілька ключів...
$request->session()->forget(['name', 'status']);

// Видалення всіх даних з сесії...
$request->session()->flush();
```

<a name="regenerating-the-session-id"></a>

### Перевизначення ID сесії

Повторне генерування ID сесії часто використовується, щоб попередити експлоатаційні атаки зловмисників на [фіксовану сесію](https://owasp.org/www-community/attacks/Session_fixation) вашого додатка.

Laravel автоматично відновлює ID сесії під час автентифікації, якщо ви використовуєте один із [стартових наборів додатка](starter-kits.md) Laravel або [Laravel Fortify](fortify.md); однак, якщо вам потрібно вручну повторно перевизначити ID сесії, ви можете скористатися методом `regenerate`:

```php
$request->session()->regenerate();
```

Якщо вам потрібно повторно згенерувати ID сесії та видалити всі дані з сесії в одному визначенні, ви можете використати метод `invalidate`:

```php
$request->session()->invalidate();
```

<a name="session-blocking"></a>

## Блокування сесії

> **Warning**  
> Щоб використовувати блокування сесії, ваш додаток має використовувати драйвер кеша, який підтримує [атомарне блокування](cache.md#atomic-locks). На даний час такими драйверами кешу є `memcached`, `dynamodb`, `redis`, та `database`.

За замовчуванням Laravel дозволяє конкурентне виконання запитів, які використовують ту саму сесію. Так, наприклад, якщо ви використовуєте HTTP-бібліотеку JavaScript, щоб зробити два HTTP-запити до вашого додатка, обидва запита будуть виконуватися одночасно. Для багатьох додатків це не проблема; однак у деяких додатках, які виконують запити із записом даних в сесію та до двох різних кінцевих точок додатка, може статися втрата даних сесії.

Щоб пом’якшити це, Laravel надає функціональність, яка дозволяє обмежити одночасні запити для певної сесії. Щоб почати, ви можете просто зв’язати метод `block` з вашим визначенням маршрута. У цьому прикладі вхідний запит, який надходить до кінцевої точки `/profile` отримає блокування сесії. Поки це блокування утримується, будь-які вхідні запити до кінцевих точок `/profile` або `/order`, які мають однаковий ID сесії, чекатимуть завершення виконання першого запита, перш ніж продовжити виконання:

```php
Route::post('/profile', function () {
    //
})->block($lockSeconds = 10, $waitSeconds = 10)

Route::post('/order', function () {
    //
})->block($lockSeconds = 10, $waitSeconds = 10)
```

Метод `block` приймає два необов'язкові аргументи. Перший аргумент, прийнятий методом `block`, — це максимальна кількість секунд, протягом якої має утримуватися блокування сесії, перш ніж її буде звільнено. Звичайно, якщо запит завершить виконання раніше цього часу, блокування буде знято раніше.

Другим аргументом, прийнятим методом `block`, є кількість секунд, протягом яких запит має чекати під час спроби отримати блокування сесії. Виняток `Illuminate\Contracts\Cache\LockTimeoutException` буде створено, якщо запит не зможе отримати блокування сеансу протягом заданої кількості секунд.

Якщо жоден із цих аргументів не передано, блокування буде отримано максимум на 10 секунд, а запити чекатимуть максимум 10 секунд, намагаючись отримати блокування:

```php
Route::post('/profile', function () {
    //
})->block()
```

<a name="adding-custom-session-drivers"></a>

## Додавання власних драйверів сесії

<a name="implementing-the-driver"></a>

#### Реалізація власного драйвера

Якщо жоден із існуючих драйверів сесії не відповідає потребам вашого додатка, Laravel дає змогу написати власного виконавця сесії. Ваш спеціальний драйвер сесії має реалізовувати вбудований у PHP `SessionHandlerInterface`. Цей інтерфейс містить лише декілька простих методів. Приклад реалізація MongoDB виглядає так:

```php
<?php

namespace App\Extensions;

class MongoSessionHandler implements \SessionHandlerInterface
{
    public function open($savePath, $sessionName) {}
    public function close() {}
    public function read($sessionId) {}
    public function write($sessionId, $data) {}
    public function destroy($sessionId) {}
    public function gc($lifetime) {}
}
```

> **Note**  
> Laravel не постачається з каталогом, який містить ваші розширень. Ви можете розмістити їх у будь-якому зручному місці. В цьому прикладі ми створили каталог `Extensions` для розміщення `MongoSessionHandler`.

Оскільки мета цих методів одразу не зрозуміла, давайте швидко розглянемо, що робить кожен з методів:

<div class="content-list" markdown="1">

- Метод `open` зазвичай використовується в файлових системах зберігання сесій. Оскільки Laravel поставляється з драйвером файлової сесії, вам рідко потрібно буде щось додавати в цей метод. Ви можете просто залишити цей метод пустим.
- Метод `close`, як і метод `open`, також зазвичай можна не враховувати. Для більшості драйверів це не потрібно.
- Метод `read` повинен повертати рядкову версію даних сесії, яка відповідає даному `$sessionId`. Немає необхідності виконувати будь-яку серіалізацію чи інше кодування під час отримання або зберігання даних сесії у вашому драйвері, оскільки Laravel виконає серіалізацію за вас.
- Метод `write` повинен записати наданий рядок `$data`, пов’язаний з `$sessionId`, у певну постійну систему зберігання, таку як MongoDB або іншу систему зберігання на ваш вибір. Знову ж таки, ви не повинні виконувати будь-яку серіалізацію - Laravel впорається з цим за вас.
- Метод `destroy` має видалити дані, пов’язані з `$sessionId`, з постійного сховища.
- Метод `gc` має знищити всі дані сесії, які старші за наданий `$lifetime`, який є міткою часу UNIX. Для систем із самозавершенням, таких як Memcached і Redis, цей метод можна залишити порожнім.

</div>

<a name="registering-the-driver"></a>

#### Реєстрація власного драйвера

Після того як драйвер був реалізований ви готові зареєструвати його в Laravel. Щоб додати додаткові драйвери до серверної частини сесії Laravel, ви можете скористатися методом `extend`, наданий [фасадом](facades.md) `Session`. Ви повинні викликати метод `extend` з метода `boot` [постачальника служб](providers.md). Ви можете зробити це з існуючого `App\Providers\AppServiceProvider` або створити абсолютно нового постачальника:

```php
<?php

namespace App\Providers;

use App\Extensions\MongoSessionHandler;
use Illuminate\Support\Facades\Session;
use Illuminate\Support\ServiceProvider;

class SessionServiceProvider extends ServiceProvider
{
    /**
     * Зареєструйте будь-які сервіси додатка.
     *
     * @return void
     */
    public function register()
    {
        //
    }

    /**
     * Завантажте будь-які служби додатка.
     *
     * @return void
     */
    public function boot()
    {
        Session::extend('mongo', function ($app) {
            // Повернути реалізацію SessionHandlerInterface...
            return new MongoSessionHandler;
        });
    }
}
```

Щойно драйвер сесії буде зареєстрований, ви можете використовувати драйвер `mongo` у вашому конфігураційному файлі `config/session.php`.
