# Laravel Sanctum

- [Вступ](#introduction)
    - [Як це працює](#how-it-works)
- [Встановлення](#installation)
- [Конфігурація](#configuration)
    - [Перевизначення моделей за замовчуванням](#overriding-default-models)
- [Автентифікація токенів API](#api-token-authentication)
    - [Видача токенів API](#issuing-api-tokens)
    - [Повноваження токенів](#token-abilities)
    - [Захист маршрутів](#protecting-routes)
    - [Відхилення токенів](#revoking-tokens)
    - [Термін дії токена](#token-expiration)
- [Автентифікація SPA](#spa-authentication)
    - [Конфігурація](#spa-configuration)
    - [Автентифікація](#spa-authenticating)
    - [Захист маршрутів](#protecting-spa-routes)
    - [Авторизація приватних каналів мовлення](#authorizing-private-broadcast-channels)
- [Аутентифікація мобільних додатків](#mobile-application-authentication)
    - [Видача токенів API](#issuing-mobile-api-tokens)
    - [Захист маршрутів](#protecting-mobile-api-routes)
    - [Відхилення токенів](#revoking-mobile-api-tokens)
- [Тестування](#testing)

<a name="introduction"></a>
## Вступ

[Laravel Sanctum](https://github.com/laravel/sanctum) надає легку систему автентифікації для SPA (односторінкових програм), мобільних додатків і простих API на основі токенів. Sanctum дозволяє кожному користувачеві вашого додатку генерувати кілька токенів API для їхнього облікового запису. Цим токенам можуть бути надані повноваження/області, які визначають, які дії дозволено виконувати токенам.

<a name="how-it-works"></a>
### Як це працює

Laravel Sanctum існує для вирішення двох окремих проблем. Давайте обговоримо кожену, перш ніж копати глибше в бібліотеці.

<a name="how-it-works-api-tokens"></a>
#### API токени

По-перше, Sanctum — це простий пакет, який можна використовувати для видачі токенів API своїм користувачам без складнощів OAuth. Цей функціонал реалізований на GitHub та інших додатках, які видають «токени особистого доступу». Наприклад, уявіть, що в «налаштуваннях облікового запису» вашого додатка є екран, на якому користувач може створити токен API для свого облікового запису. Ви можете використовувати Sanctum для створення та керування цими токенами. Ці токени зазвичай мають дуже тривалий термін дії (роки), але користувач може вручну відкликати їх у будь-який час.

Laravel Sanctum пропонує цей функціонал через збереження токенів API користувача в єдиній таблиці бази даних та аутентифікуючи вхідні HTTP-запити через заголовок `Authorization`, який повинен містити дійсний токен API.

<a name="how-it-works-spa-authentication"></a>
#### Коротко про аутентифікацію SPA

По-друге, Sanctum існує, щоб запропонувати простий спосіб автентифікації односторінкових додатків (SPA), яким потрібно спілкуватися з API на базі Laravel. Ці SPA можуть існувати в тому самому сховищі, що й ваш додаток Laravel, або бути цілком окремим репозиторієм, наприклад, SPA, створеним за допомогою Vue CLI або програми Next.js.

Для цього функціоналу Sanctum не використовує жодних токенів. Натомість Sanctum використовує вбудовані в Laravel служби автентифікації сесії на основі файлів cookie. Зазвичай для цього Sanctum використовує захист `web` автентифікації Laravel. Він забезпечує переваги захисту CSRF, автентифікації сеансу, а також захищає від витоку облікових даних автентифікації через XSS.

Sanctum намагатиметься автентифікуватись лише за допомогою файлів cookie, якщо вхідний запит надходить із вашого власного інтерфейсу SPA. Коли Sanctum перевіряє вхідний HTTP-запит, він спочатку перевіряє наявність файлу cookie автентифікації, а якщо його немає, Sanctum перевіряє заголовок `Authorization` на дійсний токен API.

> {tip} Цілком нормально використовувати Sanctum тільки для автентифікації токена API або тільки для автентифікації SPA. Той факт, що ви використовуєте Sanctum, не означає, що ви повинні використовувати обидва функціонали, які він пропонує.

<a name="installation"></a>
## Встановлення

> {tip} Найновіші версії Laravel вже містять Laravel Sanctum. Однак, якщо файл composer.json вашого додатку не містить `laravel/sanctum`, ви можете виконати інструкції встановлення, які наведені нижче.

Ви можете встановити Laravel Sanctum через менеджер пакетів Composer:

```shell
composer require laravel/sanctum
```
Далі вам слід опублікувати файли конфігурації та міграції Sanctum за допомогою команди `vendor:publish` Artisan. Конфігураційний файл `sanctum` буде розміщено в каталозі `config` дадатку:

```shell
php artisan vendor:publish --provider="Laravel\Sanctum\SanctumServiceProvider"
```
Нарешті, вам слід запустити міграцію бази даних. Sanctum створить одну таблицю бази даних для зберігання маркерів API:

```shell
php artisan migrate
```
Далі, якщо ви плануєте використовувати Sanctum для автентифікації SPA, вам слід додати посередника Sanctum до вашої групи посередникв `api` у файлі app/Http/Kernel.php вашої програми:

```php
'api' => [
	\Laravel\Sanctum\Http\Middleware\EnsureFrontendRequestsAreStateful::class,
	'throttle:api',
	\Illuminate\Routing\Middleware\SubstituteBindings::class,
],
```

<a name="migration-customization"></a>
#### Налаштування міграції

Якщо ви не збираєтеся використовувати стандартні міграції Sanctum, вам слід викликати метод `App\Providers\AppServiceProvider` у методі `register` вашого класу App\Providers\AppServiceProvider. Ви можете експортувати стандартні міграції, виконавши таку команду: php artisan

```shell
php artisan vendor:publish --tag=sanctum-migrations
```
<a name="configuration"></a>
## Конфігурація

<a name="overriding-default-models"></a>
### Перевизначення моделей за замовчуванням

Хоча це зазвичай не потрібно, ви можете розширити модель `PersonalAccessToken`, яка використовується Sanctum для внутрішнього використання:

```php
use Laravel\Sanctum\PersonalAccessToken as SanctumPersonalAccessToken;

class PersonalAccessToken extends SanctumPersonalAccessToken
{
	// ...
}
```
Потім ви можете наказати Sanctum використовувати вашу спеціальну модель за допомогою методу `usePersonalAccessTokenModel`, наданого Sanctum. Як правило, ви повинні викликати цей метод у методі `boot` одного з провайдерів вашого додатку:

```php
use App\Models\Sanctum\PersonalAccessToken;
use Laravel\Sanctum\Sanctum;

/**
 * Завантаження будь-яких служб додатка.
 *
 * @return void
 */
public function boot()
{
	Sanctum::usePersonalAccessTokenModel(PersonalAccessToken::class);
}
```

<a name="api-token-authentication"></a>
## Автентифікація токенів API

> {tip} Ви не повинні використовувати токени API для автентифікації власного SPA. Натомість використовуйте вбудований [функціонал автентифікації SPA ](#spa-authentication). Sanctum.

<a name="issuing-api-tokens"></a>
### Видача токенів API

Sanctum дозволяє видавати токени API/особисті токени доступу, які можна використовувати для автентифікації запитів API до вашого додатку. Під час виконання запитів із використанням токенів API, токен має бути включений у заголовок `Authorization` як `Bearer` токен.

Щоб розпочати випуск токенів для користувачів, ваша модель `User` має використовувати `trait` `Laravel\Sanctum\HasApiTokens`:

```php
use Laravel\Sanctum\HasApiTokens;

class User extends Authenticatable
{
	use HasApiTokens, HasFactory, Notifiable;
}
```
Щоб випустити токен, ви можете використати метод `createToken`. Метод `createToken` повертає екземпляр `Laravel\Sanctum\NewAccessToken`. Токен API хешуються за допомогою хешування SHA-256 перед збереженням у вашій базі даних, але ви можете отримати доступ до звичайного текстового значення маркера за допомогою властивості `plainTextToken` екземпляра `NewAccessToken`. Ви повинні показати це значення користувачеві відразу після створення токену:

```php
use Illuminate\Http\Request;

Route::post('/tokens/create', function (Request $request) {
	$token = $request->user()->createToken($request->token_name);

	return ['token' => $token->plainTextToken];
});
```
Ви можете отримати доступ до всіх токенів користувача, використовуючи зв’язок Eloquent `tokens`, наданий `trait` `HasApiTokens`:

```php
foreach ($user->tokens as $token) {
	//
}
```

<a name="token-abilities"></a>
### Повноваження токенів

Sanctum дозволяє призначати токенам «повноваження». Повноваження служать такій самій меті, що й «права доступу» OAuth scopes. Ви можете передати масив повноважень рядків як другий аргумент методу createToken:

```php
    return $user->createToken('token-name', ['server:update'])->plainTextToken;
```
При обробці вхідного запиту, автентифікованого Sanctum, ви можете визначити, чи має токен зазначені повноваження, використовуючи метод `tokenCan`:

```php
if ($user->tokenCan('server:update')) {
	//
}
```

<a name="token-ability-middleware"></a>
#### Посередники повноважень токена

Sanctum також включає два посередника, які можна використовувати для перевірки автентифікації вхідного запиту за допомогою токена, якому надано певні повноваження. Щоб розпочати, додайте таке проміжне програмне забезпечення до властивості `$routeMiddleware` файлу `app/Http/Kernel.php` вашої програми:

```php
'abilities' => \Laravel\Sanctum\Http\Middleware\CheckAbilities::class,
'ability' => \Laravel\Sanctum\Http\Middleware\CheckForAnyAbility::class,
```

Посередника `abilities` може бути призначено маршруту для перевірки того, що токен вхідного запиту має всі перелічені повноваження:

```php
Route::get('/orders', function () {
	// У токена є повноваження на «перевірку статусу» та «розміщення замовлень» ...
})->middleware(['auth:sanctum', 'abilities:check-status,place-orders']);
```
Посередник `ability` може бути призначений маршруту для перевірки того, що токен вхідного запиту має *принаймні одне* з перерахованих повноважень:

```php
    Route::get('/orders', function () {
        // Токен має повноваження на «перевірку статусу» або «розміщення замовлень» ...
    })->middleware(['auth:sanctum', 'ability:check-status,place-orders']);
```

<a name="first-party-ui-initiated-requests"></a>
#### Запити, ініційовані основним інтерфейсом користувача

Для зручності метод `tokenCan` завжди повертатиме true, якщо вхідний автентифікований запит надійшов від вашого основного SPA, і ви використовуєте вбудовану [автентифікацію SPA Sanctum](#spa-authentication).

Однак це не обов’язково означає, що ваш додаток має дозволяти користувачеві виконувати дію. Як правило, [політика авторизації](authorization.md#creating-policies) вашого додатка визначатиме, чи було надано токену дозвіл на виконання можливостей, а також перевірятиме, чи дозволено самому екземпляру користувача виконувати дію.

Наприклад, якщо ми уявимо додаток, яке керує серверами, це може означати перевірку того, що токен авторизований для оновлення серверів **і** що сервер належить користувачеві:


```php
return $request->user()->id === $server->user_id &&
       $request->user()->tokenCan('server:update')
```
Спочатку може здатися дивним припущення виклику методу `tokenCan`, що завжди повертає true для запитів, ініційованих інтерфейсом користувача; проте, зручно мати можливість завжди припускати, що токен API доступний і може бути перевірений за допомогою методу `tokenCan`. Застосовуючи цей підхід, ви завжди можете викликати метод `tokenCan` у політиках авторизації ваших додатків, не турбуючись про те, чи був запит ініційований з інтерфейсу користувача вашої програми або був ініційований одним із сторонніх споживачів вашого API.

<a name="protecting-routes"></a>
### Захист маршрутів

Щоб захистити маршрути таким чином, щоб усі вхідні запити проходили автентифікацію, вам слід приєднати захист автентифікації `sanctum` до ваших захищених маршрутів у ваших `routes/web.php` і `routes/api.php` Цей охоронець гарантує, що вхідні запити автентифікуються як запити з автентифікацією стану, файли cookie або містять дійсний заголовок токена API, якщо запит надходить від третьої сторони.

Вас може зацікавити, чому ми пропонуємо вам аутентифікувати маршрути у файлі `routes/web.php` вашого додатку за допомогою охоронця sanctum. Пам’ятайте, що Sanctum спочатку намагатиметься автентифікувати вхідні запити за допомогою типових файлів cookie сеансу автентифікації Laravel. Якщо файл cookie відсутній, Sanctum спробує автентифікувати запит за допомогою токену в заголовку `Authorization` запиту. Крім того, автентифікація всіх запитів за допомогою Sanctum гарантує, що ми завжди можемо викликати метод `tokenCan` у поточному автентифікованому екземплярі користувача:

```php
use Illuminate\Http\Request;

Route::middleware('auth:sanctum')->get('/user', function (Request $request) {
	return $request->user();
});
```

<a name="revoking-tokens"></a>
### Відхилення токенів

Ви можете «відхилити» токени, видаливши їх зі своєї бази даних за допомогою зв’язку `tokens`, який надає `trait` `Laravel\Sanctum\HasApiTokens`:

```php
// Анулювати всі токени...
$user->tokens()->delete();

// Анулювати токен, який використовувався для автентифікації поточного запиту...
$request->user()->currentAccessToken()->delete();

// Анулювання певного токена ...
$user->tokens()->where('id', $tokenId)->delete();
```

<a name="token-expiration"></a>
### Термін дії токена

За замовчуванням токени Sanctum ніколи не закінчуються і можуть бути визнані недійсними лише шляхом [відкликання токена](#revoking-tokens). Однак, якщо ви хочете налаштувати час закінчення терміну дії токенів API вашого додатка, то ви можете зробити це за допомогою параметра `expiration`, визначеного в конфігураційному файлі `sanctum` вашого додатку. Цей параметр конфігурації визначає кількість хвилин, після яких виданий токен буде вважатися простроченим:

```php
'expiration' => 525600,
```
Якщо ви задаєте термін дії токена для свого додатку, то ви також можете [запланувати завдання](scheduling.md), щоб видалити токени зі строком дії вашого додатку, що минув. На щастя, у Sanctum є команда `sanctum:prune-expired` Artisan, яку ви можете використати для цього. Наприклад, ви можете налаштувати заплановані завдання для видалення всіх прострочених записів бази даних токенів, термін дії яких закінчується через 24 години:

```php
$schedule->command('sanctum:prune-expired --hours=24')->daily();
```

<a name="spa-authentication"></a>
## Аутентифікація SPA

Sanctum також забезпечує простий метод автентифікації односторінкових додатків (SPA), що взаємодіють з API Laravel.
Ці SPA можуть існувати в тому ж репозиторії, що і ваш додаток Laravel, або можуть бути повністю окремим репозиторієм.

Для цього функціоналу Sanctum не використовує жодних токенів. Натомість Sanctum використовує вбудовані в Laravel служби автентифікації сесії на основі файлів Cookies. Такий підхід автентифікації забезпечує переваги захисту CSRF, автентифікації сеансу, а також захищає від витоку облікових даних автентифікації через XSS.

> {note} Для автентифікації ваші SPA та API мають використовувати один домен верхнього рівня. Однак вони можуть бути розміщені на різних субдоменах. Крім того, вам слід переконатися, що ви надсилаєте заголовок `Accept: application/json` із вашим запитом.


<a name="spa-configuration"></a>
### Конфігурація

<a name="configuring-your-first-party-domains"></a>
#### Налаштування ваших власних доменів

По-перше, вам слід налаштувати, з яких доменів ваш SPA надсилатиме запити. Ви можете налаштувати ці домени за допомогою параметра конфігурації `stateful` у файлі конфігурації `sanctum`. Цей параметр конфігурації визначає, які домени підтримуватимуть автентифікацію з урахуванням стану за допомогою сеансових файлів cookie Laravel під час надсилання запитів до вашого API.

> {note} Якщо ви отримуєте доступ до свого додатку через URL-адресу, яка містить порт (`127.0.0.1:8000`), переконайтеся, що номер порту включено в домен.

<a name="sanctum-middleware"></a>
#### Посередник Sanctum

Далі вам слід додати посередника Sanctum до групи посередників `api` у файлі `app/Http/Kernel.php`. Цей посередник відповідає за те, щоб вхідні запити від вашого SPA могли автентифікуватись за допомогою сеансових файлів cookie Laravel, і водночас дозволяти запитам від третіх сторін або мобільних програм автентифікуватися за допомогою токенів API:

```php
'api' => [
	\Laravel\Sanctum\Http\Middleware\EnsureFrontendRequestsAreStateful::class,
	'throttle:api',
	\Illuminate\Routing\Middleware\SubstituteBindings::class,
],
```

<a name="cors-and-cookies"></a>
#### CORS & Cookies

Якщо у вас виникли проблеми з автентифікацією вашого SPA, що виконується на окремому піддоміні, ви, ймовірно, неправильно налаштували параметри CORS (спільне використання ресурсів між різними джерелами) або cookie сесій.

Ви повинні переконатися, що конфігурація CORS додатка повертає заголовок `Access-Control-Allow-Credentials` зі значенням `true`. Цього можна досягти, встановивши для параметра `supports_credentials` значення `true` в конфігураційному файлі `config/cors.php` вашого додатку.

Крім того, ви повинні задіяти параметр `withCredentials` у глобальному екземплярі `axios` вашого додатку. Зазвичай це потрібно робити у файлі `resources/js/bootstrap.js`. Якщо ви на клієнтській стороні не використовуєте Axios для виконання HTTP-запитів, вам слід виконати аналогічне налаштування свого HTTP-клієнта:

```js
axios.defaults.withCredentials = true;
```
Нарешті, ви повинні переконатися, що конфігурація домену cookie сесії вашого додатку підтримує будь-який піддомен вашого кореневого домену. Ви можете зробити це, додавши домену префікс `.` у конфігураційному файлі `config/session.php` вашого додатку:

```php
'domain' => '.domain.com',
```

<a name="spa-authenticating"></a>
### Автентифікація SPA

<a name="csrf-protection"></a>
#### CSRF захист

Для аутентифікації вашого SPA сторінка «входу» вашого SPA повинна спочатку зробити запит до кінцевої точки `/sanctum/csrf-cookie` для ініціалізації захисту від CSRF для додатків:


```js
axios.get('/sanctum/csrf-cookie').then(response => {
    // Login...
});
```
Під час цього запиту Laravel встановить cookie `XSRF-TOKEN`, що містить поточний токен CSRF. Цей токен слід передавати в заголовку `X-XSRF-TOKEN` наступними запитами, який клієнтські бібліотеки HTTP, такі як Axios і Angular HttpClient, будуть передавити за вас. Якщо ваша HTTP-бібліотека JavaScript не задає автоматично значення, вам потрібно буде вручну встановити заголовок `X-XSRF-TOKEN`, щоб він відповідав значенню `XSRF-TOKEN` cookie, встановленому цим маршрутом.


<a name="logging-in"></a>
#### Вхід в систему

Після того, як захист від CSRF був ініціалізований, ви повинні зробити `POST` запит до маршруту `/login` вашого додатку Laravel. Цей маршрут `/login` може бути [реалізований вручну](authentication.md#authenticating-users) або з використанням пакета безголової автентифікації, як [Laravel Fortify](fortify.md).

Якщо запит на вхід буде успішним, користувач буде автентифікований, і наступні запити до маршрутів вашого додатку будуть автоматично автентифікуватися через cookie сесії, які додаток Laravel надіслав клієнтській стороні. Крім того, оскільки ваш додаток вже зробив запит до маршруту `/sanctum/csrf-cookie`, то наступні запити повинні автоматично отримувати захист від CSRF, поки ваш HTTP-клієнт JavaScript надсилає значення `XSRF-TOKEN` cookie у заголовку `X-XSRF-TOKEN`.

Звичайно, якщо сеанс вашого користувача закінчується через відсутність активності, наступні запити до додатка Laravel можуть отримати відповідь про помилку HTTP 401 або 419. У цьому випадку вам слід перенаправити користувача на сторінку входу в SPA.

> {note} Ви можете написати власну кінцеву точку `/login`; однак ви повинні переконатися, що він автентифікує користувача за допомогою стандартних служб автентифікації [на основі сеансу, які надає Laravel](authentication.md#authenticating-users). Як правило, це означає використання захисту `web` охоронця..

<a name="protecting-spa-routes"></a>
### Захист маршрутів

Щоб захистити маршрути таким чином, щоб усі вхідні запити проходили автентифікацію, вам слід приєднати захист автентифікації `sanctum` до своїх маршрутів API у файлі `routes/api.php`. Цей охоронець гарантує, що вхідні запити автентифікуються як запити з автентифікацією *стану* від вашого SPA або містять дійсний заголовок з API-токеном, якщо запит надходить від третьої сторони:

```php
use Illuminate\Http\Request;

Route::middleware('auth:sanctum')->get('/user', function (Request $request) {
	return $request->user();
});
```

<a name="authorizing-private-broadcast-channels"></a>
### Авторизація приватних каналів мовлення

Якщо ваш SPA потребує автентифікації за [приватних каналів/каналів трансляції присутності](broadcasting.md#authorizing-channels), вам слід розмістити виклик методу `Broadcast::routes` у файлі `routes/api.php`:

```php
    Broadcast::routes(['middleware' => ['auth:sanctum']]);
```
Далі, щоб запити на авторизацію Pusher були успішними, вам потрібно буде надати спеціальний авторизатор Pusher під час ініціалізації [Laravel Echo](broadcasting.md#client-side-installation). Це дозволяє вашому додатку налаштувати Pusher на використання екземпляра axios, який [належним чином налаштований для міждомених запитів](#cors-and-cookies):

```js
window.Echo = new Echo({
    broadcaster: "pusher",
    cluster: import.meta.env.VITE_PUSHER_APP_CLUSTER,
    encrypted: true,
    key: import.meta.env.VITE_PUSHER_APP_KEY,
    authorizer: (channel, options) => {
        return {
            authorize: (socketId, callback) => {
                axios.post('/api/broadcasting/auth', {
                    socket_id: socketId,
                    channel_name: channel.name
                })
                .then(response => {
                    callback(false, response.data);
                })
                .catch(error => {
                    callback(true, error);
                });
            }
        };
    },
})
```

<a name="mobile-application-authentication"></a>
## Аутентифікація мобільних додатків

Ви також можете використовувати токени Sanctum для автентифікації запитів вашого мобільного додатку до вашого API. Процес автентифікації запитів мобільних додатків подібний до автентифікації запитів сторонніх API; однак існують невеликі відмінності в тому, як ви будете випускати токени API.


<a name="issuing-mobile-api-tokens"></a>
### Видача токенів API мобільним додаткам

Щоб почати, створіть маршрут, який приймає електронну пошту користувача/ім’я користувача, пароль і назву пристрою, а потім обмінюйте ці облікові дані на новий Sanctum token. «Назва пристрою», надана цій кінцевій точці, призначена для інформаційних цілей і може мати будь-яке значення. Загалом значення імені пристрою має бути ім’ям, яке користувач міг би впізнати, наприклад «iPhone 12 Nuno».


```php
use App\Models\User;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash;
use Illuminate\Validation\ValidationException;

Route::post('/sanctum/token', function (Request $request) {
	$request->validate([
		'email' => 'required|email',
		'password' => 'required',
		'device_name' => 'required',
	]);

	$user = User::where('email', $request->email)->first();

	if (! $user || ! Hash::check($request->password, $user->password)) {
		throw ValidationException::withMessages([
			'email' => ['The provided credentials are incorrect.'],
		]);
	}

	return $user->createToken($request->device_name)->plainTextToken;
});
```
Коли мобільна програма використовує токен для надсилання запиту API до вашого додатку, вона повинна передавати токен у заголовку `Authorization` як токен `Bearer`.

> {tip} Випускаючи токени для мобільного додатку, ви також можете вказати [повноваження токена](#token-abilities).

<a name="protecting-mobile-api-routes"></a>
### Захист маршрутів API мобільних додатків

Як задокументовано раніше, ви можете захистити маршрути так, щоб усі вхідні запити проходили автентифікацію, прикріпивши до маршрутів захист автентифікації `sanctum`:

```php
    Route::middleware('auth:sanctum')->get('/user', function (Request $request) {
        return $request->user();
    });
```

<a name="revoking-mobile-api-tokens"></a>
### Відкликання токенів API мобільних додатків

Щоб дозволити користувачам відкликати токен API, видані мобільним пристроям, ви можете перерахувати їх за іменами разом із кнопкою «Відкликати» в розділі «Параметри облікового запису» інтерфейсу користувача веб-додатку. Коли користувач натискає кнопку «Відкликати», ви можете видалити маркер із бази даних. Пам’ятайте, що ви можете отримати доступ до токенів API користувача через зв’язок `tokens`, який наданий трейтом `Laravel\Sanctum\HasApiTokens`:


```php
// Анулювати всі токени...
$user->tokens()->delete();

// Анулювати токен, який використовувався для автентифікації поточного запиту...
$request->user()->currentAccessToken()->delete();

// Анулювання певного токена ...
$user->tokens()->where('id', $tokenId)->delete();
```

<a name="testing"></a>
## Тестування

Під час тестування метод `Sanctum::actingAs` може використовуватися для автентифікації користувача та вказівки, які повноваження мають бути надані його токену:

```php
use App\Models\User;
use Laravel\Sanctum\Sanctum;

public function test_task_list_can_be_retrieved()
{
	Sanctum::actingAs(
		User::factory()->create(),
		['view-tasks']
	);

	$response = $this->get('/api/task');

	$response->assertOk();
}
```
Якщо ви хочете надати токену всі повноваження, то ви повинні вказати `*` у списку повноважень методу `actingAs:

```php
Sanctum::actingAs(
	User::factory()->create(),
	['*']
);
```