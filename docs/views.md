# HTML-шаблонів

- [Вступ](#introduction)
- [Створення і Візуалізація Шаблонів](#creating-and-rendering-views)
  - [Вкладені Каталоги Шаблонів](#nested-view-directories)
  - [Створення Першого Доступного Шаблону](#creating-the-first-available-view)
  - [Визначення Існування Шаблону](#determining-if-a-view-exists)
- [Передача Даних в Шаблони](#passing-data-to-views)
  - [Загальнодоступні Дані для Всіх Шаблонів](#sharing-data-with-all-views)
- [Компанувальник Шаблонів](#view-composers)
  - [Створення Шаблонів](#view-creators)
- [Оптимізація Шаблонів](#optimizing-views)

<a name="introduction"></a>

## Вступ

Звичайно, непрактично повертати цілі рядки документів HTML безпосередньо з ваших маршрутів або контролерів. На щастя, шаблони надають зручний спосіб розмістити весь наш HTML в окремих файлах. Шаблони відокремлюють логіку вашого контролера / додатка від логіки презентації та зберігаються в каталозі `resources/views`. Простий шаблон може виглядати приблизно так:

```blade
<!-- View stored in resources/views/greeting.blade.php -->

<html>
    <body>
        <h1>Hello, {{ $name }}</h1>
    </body>
</html>
```

Оскільки цей шаблон зберігається за адресою `resources/views/greeting.blade.php`, ми можемо повернути його за допомогою глобального помічника `view` таким чином:

```php
    Route::get('/', function () {
        return view('greeting', ['name' => 'James']);
    });
```

> **Note**  
> Шукаєте більше інформації про те, як писати шаблони Blade? Перегляньте повну [документацію Blade](blade.md), щоб почати працювати.

<a name="creating-and-rendering-views"></a>

## Створення і Візуалізація Шаблонів

Ви можете створити шаблон, розмістивши файл із розширенням `.blade.php` в каталозі `resources/views` додатка. Розширення `.blade.php` повідомляє фреймворк про те, що файл містить [шаблон Blade](blade.md). Шаблони Blade містять HTML, а також директиви Blade, які дозволяють легко відтворювати значення, визначати `if` оператори, перебирати дані тощо.

Створивши шаблон, ви можете повернути його з одного з маршрутів або контролерів вашого додатка за допомогою глобального помічника `view`:

```php
Route::get('/', function () {
    return view('greeting', ['name' => 'James']);
});
```

Шаблони також можуть бути повернуті з фасада `View`:

```php
use Illuminate\Support\Facades\View;

return View::make('greeting', ['name' => 'James']);
```

Як ви бачите, перший аргумент, переданий помічнику `view`, відповідає імені файла шаблона, який розташований в каталозі `resources/views`. Другий аргумент — це масив даних, які повинні бути доступні для перегляду. У цьому випадку ми передаємо змінну `name`, яка передається в шаблон за допомогою [синтаксису Blade](blade.md).

<a name="nested-view-directories"></a>

### Вкладені Каталоги Шаблонів

Шаблони також можуть бути вкладені в підкаталоги каталогу `resources/views`. "Точкова" нотацію можна використовувати для посилання на вкладені шаблони. Наприклад, якщо ваш шаблон зберігається в `resources/views/admin/profile.blade.php`, ви можете повернути його з одного з маршрутів/контролерів вашого додатка таким чином:

```php
    return view('admin.profile', $data);
```

> **Warning**  
> Імена каталогів з шаблононами не повинні містити `.` крапку.

<a name="creating-the-first-available-view"></a>

### Створення Першого Доступного Шаблону

Використовуючи метод `first` фасада `View`, ви можете створити перше представлення, яке існує в заданому масиві шаблонів. Це може бути корисним, якщо ваш додаток або пакунок дозволяє налаштовувати або перезаписувати шаблони:

```php
use Illuminate\Support\Facades\View;

return View::first(['custom.admin', 'admin'], $data);
```

<a name="determining-if-a-view-exists"></a>

### Визначення Існування Шаблону

Якщо вам потрібно визначити, чи існує певний шаблон, ви можете скористатися фасадом `View`. Метод `exists` поверне `true`, якщо шаблон існує:

```php
use Illuminate\Support\Facades\View;

if (View::exists('emails.customer')) {
    //
}
```

<a name="passing-data-to-views"></a>

## Передача Даних в Шаблони

Як ви бачили в попередніх прикладах, ви можете передати масив даних в шаблон, щоб зробити ці дані доступними для шаблона:

```php
return view('greetings', ['name' => 'Victoria']);
```

При передачі інформації таким чином, дані мають бути асоціативним масивом з парами ключ/значення. Після надання даних в шаблон ви можете отримати доступ до кожного значення у вашому шаблоні за допомогою ключів даних, таких як `<?php echo $name; ?>`.

Як альтернатива передачі повного масива даних у допоміжну функцію `view`, ви можете використовувати метод `with` для додавання окремих фрагментів даних до шаблона. Метод `with` повертає екземпляр об’єкта візуалізації, щоб ви могли продовжити ланцюжок методів перед тим як повернути шаблон:

```php
return view('greeting')
    ->with('name', 'Victoria')
    ->with('occupation', 'Astronaut');
```

<a name="sharing-data-with-all-views"></a>

### Загальнодоступні Дані для Всіх Шаблонів

Іноді вам може знадобитися обмінюватися даними з усіма шаблонами, які візуалізує ваш додаток. Ви можете зробити це за допомогою метода `share` фасада `View`. Як правило, ви повинні розміщувати виклики метода `share` в методі `boot` постачальника служб. Ви можете додати їх до класа `App\Providers\AppServiceProvider` або створити окремого постачальника служб для їх розміщення:

```php
<?php

namespace App\Providers;

use Illuminate\Support\Facades\View;

class AppServiceProvider extends ServiceProvider
{
    /**
     * Зареєструйте будь-які служби додатка.
     *
     * @return void
     */
    public function register()
    {
        //
    }

    /**
     * Завантажте будь-які служби додатка.
     *
     * @return void
     */
    public function boot()
    {
        View::share('key', 'value');
    }
}
```

<a name="view-composers"></a>

## Компанувальник Шаблонів

Компанувальники шаблонів — це замикання або методи класа, які викликаються під час візуалізації шаблона. Якщо у вас є дані, які ви хочете прив’язувати до шаблону щоразу, коли цей шаблон візуалізується, компанувальник шаблонів може допомогти вам організувати цю логіку в одному місці. Компанувальник шаблонів може виявитися особливо корисними, якщо однин і той самий шаблон повертається кількома маршрутами або контроллерами у вашому додатку та завжди потребує певної частини даних.

Як правило, компанувальники шаблонів реєструються в одному з [постачальників служб](providers.md) вашого додатка. У цьому прикладі ми припустимо, що ми створили новий `App\Providers\ViewServiceProvider` для цієї логіки.

Ми використаємо метод `composer` фасада `View`, щоб зареєструвати компанувальник шаблонів. Laravel не містить каталогу за замовчуванням для компанувальників шаблонів на основі класів, тому ви можете організовувати їх як завгодно. Наприклад, ви можете створити каталог `app/View/Composers` для розміщення всіх компанувальників шаблонів вашого додатка:

```php
<?php

namespace App\Providers;

use App\View\Composers\ProfileComposer;
use Illuminate\Support\Facades\View;
use Illuminate\Support\ServiceProvider;

class ViewServiceProvider extends ServiceProvider
{
    /**
     * Зареєструйте будь-які служби додатка.
     *
     * @return void
     */
    public function register()
    {
        //
    }

    /**
     * Завантажте будь-які служби додатка.
     *
     * @return void
     */
    public function boot()
    {
        // Використання компонувальників на основі класів ...
        View::composer('profile', ProfileComposer::class);

        // Використання анонімних компонувальників ...
        View::composer('dashboard', function ($view) {
            //
        });
    }
}
```

> **Warning**  
> Пам’ятайте: якщо ви створюєте нового постачальника служб, який буде містити ваші реєстрації компанувальників шаблонів, вам потрібно буде додати постачальника служб до масиву `providers` у файлі конфігурації `config/app.php`.

Тепер, коли ми зареєстрували компанувальника, метод `compose` класа `App\View\Composers\ProfileComposer` виконуватиметься кожного разу, коли візуалізується шаблон `profile`. Давайте подивимося на приклад класа компанувальника:

```php
<?php

namespace App\View\Composers;

use App\Repositories\UserRepository;
use Illuminate\View\View;

class ProfileComposer
{
    /**
     * Реалізація сховища User.
     *
     * @var \App\Repositories\UserRepository
     */
    protected $users;

    /**
     * Створіть новий профіль компанувальника.
     *
     * @param  \App\Repositories\UserRepository  $users
     * @return void
     */
    public function __construct(UserRepository $users)
    {
        $this->users = $users;
    }

    /**
     * Прив’язати дані до шаблона.
     *
     * @param  \Illuminate\View\View  $view
     * @return void
     */
    public function compose(View $view)
    {
        $view->with('count', $this->users->count());
    }
}
```

Як ви бачите, всі компанувальники шаблонів вилучаються через [контейнер служби](container.md), тому ви можете оголосити будь-які потрібні вам залежності в конструкторі компанувальника.

<a name="attaching-a-composer-to-multiple-views"></a>

#### Зв'язування компонувальника з кількома шаблонами

Ви можете приєднати компанувальника шаблонів до декількох шаблонів одночасно, передавши масив шаблонів першим аргументом методу `composer`:

```php
use App\Views\Composers\MultiComposer;

View::composer(
    ['profile', 'dashboard'],
    MultiComposer::class
);
```

Метод `composer` також приймає символ `*` як символ підкладення, який дозволяє вам прикріпити компанувальника до всіх шаблонів:

```php
View::composer('*', function ($view) {
    //
});
```

<a name="view-creators"></a>

### Творці шаблонів

«Творці» шаблонів дуже схожі на компанувальників шаблонів; однак вони виконуються одразу після створення екземпляра візуалізації, а не чекають, поки шаблон візуалізується. Щоб зареєструвати творця шаблона, скористайтеся методом `creator`:

```php
use App\View\Creators\ProfileCreator;
use Illuminate\Support\Facades\View;

View::creator('profile', ProfileCreator::class);
```

<a name="optimizing-views"></a>

## Оптимізація Шаблонів

За замовчуванням шаблони Blade компілюються на вимогу. Коли виконується запит, який візуалізує шаблон, Laravel визначить, чи існує скомпільована версія шаблона. Якщо файл існує, Laravel далі визначить, чи був вихідний шаблон змінено пізніше скомпілюваного. Якщо скомпілюваний шаблон не існує, або вихідний шаблон був змінений, Laravel перекомпілює шаблон.

Компіляція шаблонів під час запита негативно впливає на продуктивність, тому Laravel містить команду Artisan `view:cache` для попередньої компіляції всіх шаблонів, які використовуються вашим додатком. Для підвищення продуктивності ви можете виконати цю команду як частину процесу розгортання:

```shell
php artisan view:cache
```

Ви можете використовувати команду `view:clear` для очищення кешу шаблонів:

```shell
php artisan view:clear
```
