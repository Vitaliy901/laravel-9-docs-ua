# Laravel 9 · Автентифікація

- [Вступ](#introduction)
    - [Стартові компоненти](#starter-kits)
    - [Рекомендації щодо бази даних](#introduction-database-considerations)
    - [Огляд екосистеми](#ecosystem-overview)
- [Швидкий старт автентифікації](#authentication-quickstart)
    - [Встановлення стартових пакетів](#install-a-starter-kit)
    - [Отримання автентифікованого користувача](#retrieving-the-authenticated-user)
    - [Захист маршрутів](#protecting-routes)
    - [Регулювання частоти спроб входу у додаток](#login-throttling)
- [Самостійна реалізація автентифікації користувачів](#authenticating-users)
    - [Запам'ятовування користувачів](#remembering-users)
    - [Інші методи автентифікації](#other-authentication-methods)
- [Базова HTTP-автентифікація](#http-basic-authentication)
    - [Базова HTTP-автентифікація без збереження стану](#stateless-http-basic-authentication)
- [Вихід із додатка](#logging-out)
    - [Анулювання сесій на інших пристроях](#invalidating-sessions-on-other-devices)
- [Підтвердження пароля](#password-confirmation)
    - [Конфігурація підтвердження пароля](#password-confirmation-configuration)
    - [Маршрутизація підтвердження пароля](#password-confirmation-routing)
    - [Захист маршрутів](#password-confirmation-protecting-routes)
- [Додавання власних охоронців автентифікації](#adding-custom-guards)
    - [Анонімні охоронці авентифікації на базі HTTP-запитів](#closure-request-guards)
- [Додавання власних провайдерів користувачів](#adding-custom-user-providers)
    - [Контракт `UserProvider`](#the-user-provider-contract)
    - [Контракт `Authenticatable`](#the-authenticatable-contract)
- [Автентифікація через соціальні мережі](socialite.md)
- [Події](#events)

<a name="introduction"></a>
## Вступ

Багато веб-застосунків надають своїм користувачам можливість автентифікуватися в програмі та «увійти в систему». Реалізація цього функціоналу у веб-додатках може бути складним та потенційно ризикованим завданням. З цієї причини Laravel прагне надати вам інструменти, необхідні для швидкої, безпечної та простої реалізації автентифікації.

За своєю суттю засоби автентифікації Laravel складаються з «охоронців» та «провайдерів». Охоронці визначають, як користувачі проходять автентифікацію для кожного запиту. Наприклад, Laravel поставляється з охоронцем `session`, який підтримує стан, використовуючи сховище сесій та файли `Cookies`.

Провайдери визначають, як користувачі вилучаються з постійного сховища. Laravel поставляється з підтримкою отримання користувачів за допомогою [Eloquent](eloquent.md) та розробника запитів (Query Builder) до бази даних. Однак, ви можете визначити додаткових провайдерів, якщо це необхідно для вашої програми.

Файл конфігурації автентифікації вашого додатка знаходиться в `config/auth.php`. Цей файл містить кілька добре задокументованих варіантів для налаштування поведінки служб автентифікації Laravel.

> {tip} Охоронців та провайдерів не слід плутати з «ролями» та «дозволами». Щоб дізнатися більше про авторизацію дій користувача за допомогою дозволів, зверніться до [авторизації](authorization.md).

<a name="starter-kits"></a>
### Стартові компоненти

Бажаєте швидко розпочати роботу? Встановіть [стартовий комплект додатка](starter-kits.md) у новий додаток Laravel. Після міграції бази даних перейдіть у браузері за адресою `/register` або будь-якою іншою URL-адресою вашого додатка. Стартові компоненти візьмуть на себе створення усієї вашої системи автентифікації!

**Навіть якщо ви вирішите не використовувати стартовий набір у своєму остаточному додатку Laravel, встановлення стартового набору [Laravel Breeze](starter-kits.md#laravel-breeze) може бути чудовою можливість дізнатися, як реалізується вся функціональність автентифікації в актуальних проектах Laravel.** Оскільки Laravel Breeze створить для вас контроллери автентифікації, маршрути та шаблони, ви можете вивчити код у цих файлах, щоб дізнатися, як може бути реалізований функціонал автентифікації Laravel.

<a name="introduction-database-considerations"></a>
### Рекомендації щодо бази даних

За замовчуванням Laravel містить [модель Eloquent](eloquent.md) `App\Models\User` у вашому каталозі `app/Models`. Ця модель використовує драйвер автентифікації `eloquent` за замовчуванням. Якщо ваш додаток не використовує Eloquent, то ви можете використовувати драйвер автентифікації `database`, заснований на `Query Builder` Laravel.

Під час створення схеми бази даних для моделі App\Models\User переконайтеся, що довжина колонка `password` не менше 60 символів. Звичайно, міграція таблиці користувачів, яка занесена до нових додатків Laravel, вже містить колону, довжина якої перевищує цю довжину.

Крім того, ви повинні переконатися, що таблиця users (або еквівалентна) містить колонку `remember_token` з параметрами `VARCHAR(100) NULL`. Цей стовпець буде використовуватися для зберігання токена для користувачів, які вибирають опцію "Запам'ятати мене" під час входу до вашого додатка.Знову ж таки, міграція таблиці користувачів за замовчуванням, яка включена в нові додатки Laravel, вже містить цю колонку.

<a name="ecosystem-overview"></a>
### Огляд екосистеми

Laravel пропонує кілька пакетів, пов'язаних із автентифікацією. Перш ніж продовжити, ми розглянемо загальну екосистему автентифікації в Laravel та обговоримо призначення кожного пакету.

По-перше, розглянемо, як працює автентифікація. Під час використання веб-браузера користувач вводить своє ім'я користувача та пароль через форму входу. Якщо ці облікові дані вірні, програма зберігатиме інформацію про автентифікованого користувача в [сесії](session.md) користувача. Файл cookie, надісланий браузеру, містить ідентифікатор сесії, щоб наступні запити до програми могли пов'язати користувача з правильною сесією. Після отримання файлу cookie сесії, додаток вилучає дані сесії на основі ідентифікатора сесії, позначає, що автентифікаційна інформація була збережена в сесії, і розглядає користувача як «автентифікованого».

Коли віддаленій службі необхідно пройти автентифікацію для доступу до API, файли cookie зазвичай не використовуються для автентифікації, оскільки веб-браузер відсутній. Натомість віддалена служба надсилає API-токен при кожному запиті до API. Програма може перевіряти вхідний токен по таблиці допустимих API-токенів і «автентифікувати» запит як виконаний користувачем, пов’язаним із цим маркером API-токеном.

<a name="laravels-built-in-browser-authentication-services"></a>
#### Вбудовані служби Web-автентифікації браузера Laravel

Laravel містить вбудовані служби автентифікації та сеансу, доступ до яких зазвичай здійснюється через фасади `Auth` і `Session`. Ці функції забезпечують автентифікацію на основі файлів cookie для запитів, ініційованих веб-браузерами. Вони надають методи, які дозволяють перевірити облікові дані користувача та автентифікувати користувача. Крім того, ці служби автоматично зберігатимуть необхідні дані автентифікації в сеансі користувача та видаватимуть файл cookie сеансу користувача. Обговорення того, як використовувати ці служби, міститься в цій документації.

**Початкові компоненти додатка**

Як обговорювалося в цій документації, ви можете взаємодіяти з цими службами автентифікації вручну, щоб створити власний рівень автентифікації вашого додатка. Однак, щоб допомогти вам швидше розпочати роботу, ми випустили [безкоштовні пакети](starter-kits.md), які забезпечують надійну, сучасну основу для всього рівня автентифікації. Це пакети Laravel Breeze, Laravel Jetstream і Laravel Fortify.

[**Laravel Breeze**](starter-kits.md#laravel-breeze) — це проста мінімальна реалізація всіх функцій автентифікації Laravel, включаючи вхід, реєстрацію, скидання пароля, перевірку електронної пошти та підтвердження пароля. Шар перегляду Laravel Breeze складається з простих [шаблонів Blade](blade.md), стилізованих за допомогою [Tailwind CSS](https://tailwindcss.com). Щоб почати, перегляньте документацію [стартових наборів](starter-kits.md) Laravel.

[**Laravel Fortify**](fortify.md) – це лише серверна автентифікації для Laravel, яка реалізує безліч функцій, наведених у цій документації, включаючи автентифікацію на основі файлів cookie, а також інші можливості, такі як двофакторна автентифікація та перевірка електронної пошти. Fortify надає серверну автентифікацію для Laravel Jetstream або може використовуватися окремо в поєднанні з [Laravel Sanctum](sanctum.md) для забезпечення односторінкових додатків (SPA) можливістю автентифікації разом з Laravel.

[**Laravel Jetstream**](https://jetstream.laravel.com) – це надійний стартовий набір компонентів, який використовує та надає послуги автентифікації Laravel Fortify із красивим сучасним інтерфейсом користувача на основі [Tailwind CSS](https://tailwindcss.com), [Livewire](https://laravel-livewire.com) та/або [Inertia.js](https://inertiajs.com). Laravel Jetstream включає додаткову підтримку двофакторної автентифікації, підтримку команд, керування сеансами браузера, керування профілями та вбудовану інтеграцію з [Laravel Sanctum](sanctum.md) для автентифікації токена API. Пропозиції автентифікації API Laravel обговорюються нижче.

<a name="laravels-api-authentication-services"></a>
#### Сервіси API-автентифікації Laravel

Laravel надає два додаткові пакети, які допоможуть вам керувати токенами API та автентифікувати запити, зроблені за допомогою токенів API: [Passport](passport.md) і [Sanctum](sanctum.md). Зверніть увагу на те, що ці бібліотеки та вбудовані бібліотеки автентифікації на основі файлів cookie Laravel не є взаємовиключними. Ці бібліотеки в основному зосереджені на автентифікації токенів API, тоді як вбудовані служби автентифікації зосереджені на автентифікації браузера на основі файлів cookie. Безліч додатків використовуватимуть як вбудовані служби автентифікації на основі файлів cookie Laravel, так і один із пакетів API-автентифікації Laravel.

**Passport**

Passport — це постачальник автентифікації OAuth2, який пропонує різноманітні OAuth2 Grant Types «види грантів», які дозволяють видавати різні типи токенів. Загалом, це надійний і складний пакет для аутентифікації API. Однак для більшості програм не потрібні складні функції, які пропонує специфікація OAuth2, що може заплутати як користувачів, так і розробників. Крім того, розробники історично не розуміли, як автентифікувати додатки SPA або мобільні додатки за допомогою постачальників автентифікації OAuth2, таких як Passport.

**Sanctum**

У відповідь на складність OAuth2 і плутанину розробників ми вирішили створити простіший і оптимізований пакет автентифікації, який міг би обробляти як сторонні веб-запити з браузера, так і запити API через токени. Ця мета була реалізована з випуском [Laravel Sanctum](sanctum.md), який слід вважати кращим і рекомендованим пакетом автентифікації для додатків, які пропонуватимуть власний веб-інтерфейс на додаток до API, або працюватимуть на основі односторінкового додатка (SPA), який існує окремо від серверної програми Laravel або програм, які пропонують мобільний клієнт.

Laravel Sanctum — це гібридний пакет автентифікації Web / API, який може керувати всім процесом автентифікації вашого додатка. Це можливо тому, що коли додатки на основі Sanctum отримують запит, Sanctum спочатку визначає, чи містить запит файл cookie сеансу, який посилається на сесію автентифікації. Sanctum досягає цього, викликаючи вбудовані служби аутентифікації Laravel, які ми обговорювали раніше. Якщо запит не автентифікується за допомогою файлу cookie сеансу, Sanctum перевірить запит на наявність токена API. Якщо токен API присутній, Sanctum автентифікує запит за допомогою цього токена. Щоб дізнатися більше про цей процес, зверніться до документації [«як це працює»](sanctum.md#how-it-works)

Laravel Sanctum — це пакет API, який ми вирішили включити до початкового набору програм [Laravel Jetstream](https://jetstream.laravel.com), оскільки вважаємо, що він найкраще підходить для більшості потреб автентифікації веб-додатків.

<a name="summary-choosing-your-stack"></a>
#### Підсумок і вибір вашого стека

Таким чином, якщо доступ до вашої програми буде здійснюватися за допомогою браузера, і ви створюєте монолітний додаток Laravel, ваш додаток використовуватиме вбудовані служби автентифікації Laravel.

Далі, якщо ваш додаток пропонує API, який використовуватиметься третіми сторонами, ви матимете вибір між [Passport](passport.md) або [Sanctum](sanctum.md), щоб забезпечити автентифікацію токенів API для вашого додатка. Загалом слід надавати перевагу Sanctum, коли це можливо, оскільки це просте повне рішення для автентифікації API, автентифікації SPA та мобільної автентифікації, включаючи підтримку «scopes» або «abilities».

Якщо ви створюєте односторінкову програму (SPA), яка працюватиме з серверною частиною Laravel, вам слід використовувати [Laravel Sanctum](sanctum.md). Використовуючи Sanctum, вам потрібно буде [вручну запровадити власні маршрути автентифікації на сервері](#authenticating-users), або використовувати [Laravel Fortify](fortify.md) як серверну службу автентифікації, яка надає маршрути та контролери для такого функціонування, як реєстрація, скидання пароля, підтвердження електронної пошти тощо.

Passport можна обрати, якщо вашому додатоку необхідний абсолютно весь функціонал, що надається специфікацією OAuth2.

І, якщо ви хочете швидко почати роботу, то ми раді порекомендувати пакет [Laravel Jetstream](https://jetstream.laravel.com) як швидкий спосіб запустити новий додаток Laravel, який вже використовує кращий стек аутентифікації: вбудовані служби автентифікації Laravel та Laravel Sanctum.

<a name="authentication-quickstart"></a>
## Швидкий запуск автентифікації

> {note} У цій частині документації розглядається автентифікація користувачів за допомогою [стартових пакетів Laravel](starter-kits.md), які включають каркас інтерфейсу користувача, який допоможе вам швидко розпочати роботу. Якщо ви хочете безпосередньо інтегруватись із системами автентифікації Laravel, перегляньте документацію щодо [ручної автентифікації користувачів](#authenticating-users).

<a name="install-a-starter-kit"></a>
### Встановлення стартових пакетів

По-перше, вам слід [встановити стартовий пакет Laravel](starter-kits.md). Наші поточні стартові пакети, Laravel Breeze та Laravel Jetstream, пропонують чудово розроблені початкові точки для включення автентифікації у ваш новий додаток Laravel.

Laravel Breeze — це мінімальна проста реалізація всіх функцій автентифікації Laravel, включаючи вхід, реєстрацію, скидання пароля, перевірку електронної пошти та підтвердження пароля. Шар представлення Laravel Breeze складається з простих [шаблонів Blade](blade.md), стилізованих за допомогою [Tailwind CSS](https://tailwindcss.com). Breeze також пропонує варіант створення каркасів на основі [Inertia](https://inertiajs.com) з використанням Vue або React.

[Laravel Jetstream](https://jetstream.laravel.com) – це більш надійний стартовий пакет для додатків, який включає підтримку побудови вашого додатка за допомогою [Livewire](https://laravel-livewire.com) або [Inertia.js и Vue](https://inertiajs.com). Крім того, Jetstream пропонує додаткову підтримку двофакторної аутентифікації, команд, керування профілями, керування сеансами браузера, підтримки API через [Laravel Sanctum](sanctum.md), видалення акаунтів і т.д.

<a name="retrieving-the-authenticated-user"></a>
### Отримання автентифікованого користувача

Після встановлення початкового пакету автентифікації та дозволу користувачам реєструватися та автентифікуватися за допомогою вашого додатку вам часто потрібно буде взаємодіяти з поточним автентифікованим користувачем. При обробці вхідного запиту ви можете отримати доступ до автентифікованого користувача за допомогою методу `user` фасаду `Auth`:

```php
use Illuminate\Support\Facades\Auth;

// Отримати автентифікованого користувача...
$user = Auth::user();

// Отримати ідентифікатор поточного автентифікованого користувача...
$id = Auth::id();
```

Крім того, після автентифікації користувача ви можете отримати доступ до автентифікованого користувача через екземпляр `Illuminate\Http\Request`. Пам'ятайте, що оголошені типи залежностей у методах контролера будуть автоматично впроваджені. Оголосивши об'єкт `Illuminate\Http\Request` ви можете отримати зручний доступ до автентифікованого користувача з будь-якого методу контролера у вашому додатку через метод `user` запиту:


```php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class FlightController extends Controller
{
	/**
		* Оновити інформацію про наявний рейс
		*
		* @param  \Illuminate\Http\Request  $request
		* @return \Illuminate\Http\Response
		*/
	public function update(Request $request)
	{
		// $request->user()
	}
}
```

<a name="determining-if-the-current-user-is-authenticated"></a>
#### Визначення статусу аутентифікації користувача

Щоб визначити, чи автентифікований користувач, що виконує вхідний HTTP-запит, ви можете використовувати метод `check` фасаду `Auth`. Цей метод поверне true, якщо користувач автентифікований:

```php
use Illuminate\Support\Facades\Auth;

if (Auth::check()) {
	// Користувач увійшов...
}
```

> {tip} Незважаючи на те, що можна визначити, чи автентифікований користувач за допомогою методу `check`, ви зазвичай будете використовувати посередника для перевірки статусу автентифікації користувача перед наданням користувачеві доступу до певних маршрутів/контролерів. Щоб дізнатися більше про це, ознайомтесь із документацією щодо [захисту маршрутів](#protecting-routes).

<a name="protecting-routes"></a>
### Захист маршрутів

[Посередник маршруту](middleware.md) використовується для того, щоб дозволити лише автентифікованим користувачам доступ до зазначеного маршруту. Laravel містить посередник `auth`, який посилається на клас `Illuminate\Auth\Middleware\Authenticate`. Оскільки цей посередник вже зареєстрований у HTTP-ядрі вашого додатку, все, що вам потрібно зробити, це задати посередника для визначення маршруту:

```php
Route::get('/flights', function () {
	// Тільки автентифіковані користувачі можуть отримати доступ до цього маршруту.
})->middleware('auth');
```

<a name="redirecting-unauthenticated-users"></a>
#### Перенаправлення неавтентифікованих користувачів

Коли посередник `auth` виявляє неавтентифікованого користувача, він перенаправляє користувача на [іменований маршрут](routing.md#named-routes) `login`. Ви можете змінити цю поведінку, оновивши метод `redirectTo` у файлі app/Http/Middleware/Authenticate.php вашого додатка:

```php
/**
 * Отримати шлях, по якому користувач повинен бути перенаправлений.
 *
 * @param  \Illuminate\Http\Request  $request
 * @return string
 */
protected function redirectTo($request)
{
	return route('login');
}
```

<a name="specifying-a-guard"></a>
#### Визначення ​​охоронця автентифікації

При визначенні посередника `auth` маршруту ви також можете вказати, який охоронець повинен використовуватися для автентифікації користувача. Зазначений охоронець повинен відповідати одному із вказаних кулючів у масиві `guards` конфігураційного файлу `config/auth.php`:

```php
Route::get('/flights', function () {
	// Тільки автентифіковані користувачі можуть отримати доступ до цього маршруту...
})->middleware('auth:admin');
```

<a name="login-throttling"></a>
### Регулювання частоти спроб входу у додаток

Якщо ви використовуєте [стартові пакети](starter-kits.md) Laravel Breeze або Laravel Jetstream, то до спроб входу у систему автоматично застосовуватиметься обмеження. За замовчуванням, якщо користувач не зможе надати правильні облікові дані після кількох спроб, він не зможе увійти в систему протягом однієї хвилини. Частота спроб унікальна для імені користувача/адреси електронної пошти та разом з IP-адресою.

> {tip} Якщо ви хочете обмежити частоту запитів до інших маршрутів свого додатку, ознайомтеся з [документацією з обмеження частоти запитів](routing.md#rate-limiting).

<a name="authenticating-users"></a>
## Самостійна реалізація автентифікації користувачів

Вам не обов'язково використовувати каркас автентифікації, занесений до [стартових пакетів](starter-kits.md) Laravel. Якщо ви вирішите не використовувати їх, вам потрібно буде керувати аутентифікацією користувачів безпосередньо, використовуючи класи аутентифікації Laravel. Не хвилюйтеся, адже це просто!

Ми матимемо доступ до служб автентифікації Laravel через [фасад](facades.md) `Auth`, тому нам потрібно обов'язково імпортувати фасад `Auth` у верхній частині нашого класу. Далі, давайте перевіримо метод `attempt`. Метод `attempt` зазвичай використовується для обробки спроб аутентифікації з форми входу до системи вашого додатка. Якщо автентифікація пройшла успішно, ви повинні повторно створити [сесію](session.md) користувача, щоб запобігти [фіксації сесії](https://en.wikipedia.org/wiki/Session_fixation):

```php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;

class LoginController extends Controller
{
	/**
	 * Обробка спроб автентифікації.
	 *
	 * @param  \Illuminate\Http\Request  $request
	 * @return \Illuminate\Http\Response
	 */
	public function authenticate(Request $request)
	{
		$credentials = $request->validate([
			'email' => ['required', 'email'],
			'password' => ['required'],
		]);
		
		if (Auth::attempt($credentials)) {
			$request->session()->regenerate();

			return redirect()->intended('dashboard');
		}

		return back()->withErrors([
			'email' => 'The provided credentials do not match our records.',
		])->onlyInput('email');
	}
}
```
Метод `attempt` приймає масив пар ключ / значення у якості свого першого аргумента. Значення в масиві використовуватимуться для пошуку користувача у вашій таблиці бази даних. Отже, у наведеному вище прикладі користувача буде отримано за значенням колонки `email`. Якщо користувача знайдено, хешований пароль, що зберігається в базі даних, порівнюватиметься зі значенням `password`, переданим у метод через масив. Ви не повинні хешувати значення пароля вхідного запиту, оскільки структура автоматично хешує значення перед тим, як порівняти його з хешованим паролем у базі даних. Якщо два хешованих паролі збігаються, для користувача буде розпочато автентифікований сеанс.

Пам’ятайте, що служби автентифікації Laravel будуть отримувати користувачів із вашої бази даних на основі конфігурації «провайдера» вашого захисника автентифікації. У файлі конфігурації `config/auth.php` за замовчуванням вказано провайдера користувача Eloquent, і йому наказано використовувати модель `App\Models\User` під час отримання користувачів. Ви можете змінити ці значення у файлі конфігурації відповідно до потреб вашої програми.

Метод `attempt поверне значення `true`, якщо автентифікація пройшла успішно. В іншому випадку буде повернено `false`.

Метод `intended`, екземпляра `Illuminate\Routing\Redirector` Laravel, перенаправить користувача на URL-адресу, до якої він намагався отримати доступ, перш ніж його перехопить `middleware` автентифікації. Резервний URI може бути надано цьому методу, якщо призначенина адреса недоступна.

<a name="specifying-additional-conditions"></a>
#### Визначення ​​додаткових умов

За бажанням, ви також можете додати додаткові умови запиту до запиту автентифікації на додаток до електронної пошти та пароля користувача. Щоб досягти цього, ми можемо просто додати умови запиту до масиву, переданого методу `attempt`. Наприклад, ми можемо перевірити, що користувач позначений як «активный»:

При желании вы также можете добавить дополнительные условия запроса к запросу аутентификации в дополнение к электронной почте и паролю пользователя. Для этого мы можем просто добавить условия запроса в массив, переданному методу `attempt`. Например, мы можем проверить, что пользователь отмечен как «активный»:

```php
if (Auth::attempt(['email' => $email, 'password' => $password, 'active' => 1])) {
	// Authentication was successful...
}
```

> {note} У цих прикладах `email` не є обов’язковою опцією, вона використовується лише як приклад. Ви повинні використовувати будь-яке ім’я колонки, яке відповідає «імені користувача» у вашій таблиці бази даних.

<a name="accessing-specific-guard-instances"></a>
#### Доступ до окремо взятих екземплярів охоронця автентифікації

Використовуючи метод `guard` фасаду `Auth`, ви можете вказати, який екземпляр охоронця ви хочете використовувати під час аутентифікації користувача. Це дозволяє вам керувати аутентифікацією для окремих частин вашого додатка з використанням абсолютно окремих аутентифікованих моделей або таблиць користувача.

Ім'я охоронця, передане методу `guard`, має відповідати одному з налаштованих у файлі конфігурації `auth.php` охоронцю:

```php
if (Auth::guard('admin')->attempt($credentials)) {
	// ...
}
```

<a name="remembering-users"></a>
### Запам'ятовування користувачів

Багато веб-застосунків містять прапорець «Запам'ятати мене» у формі входу. Якщо ви хочете реалізувати функціонал «Запам'ятати мене» у своїй програмі, то ви можете передати логічне значення як другий аргумент методу `attempt`.

Коли це значення дорівнює `true`, Laravel підтримуватиме автентифікацію користувача невизначено довго або доти, доки він не вийде із системи вручну. Ваша таблиця `users` повинна мати колонку `remember_token`, яка використовуватиметься для зберігання токена функціоналу «Запам'ятати мене». Міграція таблиці користувачів, що входить до нових додатків Laravel, вже містить цю колонку:

```php
use Illuminate\Support\Facades\Auth;

if (Auth::attempt(['email' => $email, 'password' => $password], $remember)) {
	// Запам'ятовуємо користувача ...
}
```
Якщо ваша програма надає функціонал «запам'ятовування користувача», ви можете використовувати метод `viaRemember`, щоб визначити, чи був автентифікований поточний користувач за допомогою файлу cookie «запам'ятовування користувача»:

```php
use Illuminate\Support\Facades\Auth;

if (Auth::viaRemember()) {
	// ...
}
```

<a name="other-authentication-methods"></a>
### Інші методи автентифікації

<a name="authenticate-a-user-instance"></a>
#### Автентифікація користувача за екземпляром моделі

Якщо вам потрібно встановити існуючий екземпляр користувача як поточного автентифікованого користувача, ви можете передати цей екземпляр користувача методу `login` фасада `Auth`. Даний екземпляр користувача має бути реалізацією [контракту](contracts.md) `Illuminate\Contracts\Auth\Authenticatable`. Модель `App\Models\User`, що входить до складу Laravel, уже реалізує цей інтерфейс. Цей метод автентифікації корисний, коли у вас уже є дійсний екземпляр користувача, наприклад, безпосередньо після реєстрації користувача у вашій програмі:


```php
use Illuminate\Support\Facades\Auth;

Auth::login($user);
```

Ви можете передати логічне значення другим аргументом методу `login`. Це значення вказує, чи потрібен функціонал «запам’ятати мене» для автентифікованого сеансу. Пам’ятайте, що це означає, що сеанс автентифікуватиметься нескінченно або доки користувач вручну не вийде з програми:

```php
Auth::login($user, $remember = true);
```
Якщо потрібно, ви можете вказати охоронця автентифікації перед викликом методу `login`:

```php
    Auth::guard('admin')->login($user);
```

<a name="authenticate-a-user-by-id"></a>
#### Автентифікація користувача за ідентифікатором

Для аутентифікації користувача з використанням первинного ключа запису в базі даних можна використовувати метод `loginUsingId`. Цей метод приймає первинний ключ користувача, якого ви хочете автентифікувати:

```php
    Auth::loginUsingId(1);
```
Ви можете передати логічне значення як другий аргумент методу `loginUsingId`. Це значення вказує, чи потрібен функціонал «запам’ятати мене» для автентифікованого сеансу. Пам’ятайте, що це означає, що сеанс автентифікуватиметься нескінченно або доки користувач вручну не вийде з додатка:

```php
    Auth::loginUsingId(1, $remember = true);
```

<a name="authenticate-a-user-once"></a>
#### Автентифікація користувача один раз

Ви можете використовувати метод `once` для автентифікації користувача у додатку тільки для одного запита. Під час виклику цього методу не використовуватимуться жодні сеанси чи файли cookie:

```php
if (Auth::once($credentials)) {
	//
}
```

<a name="http-basic-authentication"></a>
## Базова автентифікація HTTP

[Basic HTTP-автентифікація](https://en.wikipedia.org/wiki/Basic_access_authentication) надає швидкий спосіб автентифікації користувачів вашого додатка без налаштування спеціальної «сторінки входу». Для початку встановіть маршруту [middleware](middleware.md) `auth.basic`. Посередник `auth.basic` постачається з Laravel, тому вам не потрібно його визначати в `Kernel`:

```php
Route::get('/profile', function () {
	// Тільки автентифіковані користувачі можуть отримати доступ до цього маршруту.
})->middleware('auth.basic');
```
Після того, як посередник задано маршруту, вам буде автоматично запропоновано ввести облікові дані при доступі до маршруту у вашому браузері. За замовчуванням посередник `auth.basic` припускає, що стовпець email у таблиці бази даних `users` є його «логіном»

<a name="a-note-on-fastcgi"></a>
#### Примітка по FastCGI

Якщо ви використовуєте PHP FastCGI та Apache для своєї програми Laravel, то автентифікація HTTP Basic може працювати некоректно. Щоб виправити ці проблеми, до файлу `.htaccess` вашої програми можна додати такі рядки:

```apache
RewriteCond %{HTTP:Authorization} ^(.+)$
RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization}]
```

<a name="stateless-http-basic-authentication"></a>
### Базова HTTP-автентифікація без збереження стану

Ви також можете використовувати Basic HTTP-автентифікацію без визначення cookie ідентифікатора користувача в сесії. Це в першу чергу корисно, якщо ви вирішите використовувати аутентифікацію HTTP для аутентифікації запитів до API вашого додатка. Для цього [визначте посередника](middleware.md), який викликає метод `onceBasic`. Якщо метод `onceBasic` не повертає відповіді, то запит може бути переданий далі у додаток:

Вы также можете использовать Basic HTTP-аутентификацию без задания cookie идентификатора пользователя в сессии. Это в первую очередь полезно, если вы решите использовать HTTP-аутентификацию для аутентификации запросов к API вашего приложения. Для этого [визначте посередника](middleware.md), который вызывает метод `onceBasic`. Если метод `onceBasic` не возвращает ответа, то запрос может быть передан дальше в приложение:

```php
<?php

namespace App\Http\Middleware;

use Illuminate\Support\Facades\Auth;

class AuthenticateOnceWithBasicAuth
{
	/**
	 * Обробка вхідного запита...
	 *
	 * @param  \Illuminate\Http\Request  $request
	 * @param  \Closure  $next
	 * @return mixed
	 */
	public function handle(Request $request, $next)
	{
		return Auth::onceBasic() ?: $next($request);
	}

}
```
Потім [зареєструйте посередника](middleware.md#registering-middleware) та задайте його маршруту:

```php
    Route::get('/api/user', function () {
       // Тільки автентифіковані користувачі можуть отримати доступ до цього маршруту.
    })->middleware('auth.basic.once');
```

<a name="logging-out"></a>
## Вихід з додатка

Щоб забезпечити користувачеві можливість виходу з вашого додатка ви можете використати метод `logout` фасаду `Auth`. Це видаляє інформацію автентифікації із сесії користувача, тому наступні запити не будуть автентифіковані.

На додаток до виклику методу `logout` рекомендується скасувати сесію користувача і повторно згенерувати його [токен CSRF](csrf.md). Після виходу користувача із системи ви зазвичай перенаправляєте користувача в корінь вашого додатка:

```php
    use Illuminate\Http\Request;
    use Illuminate\Support\Facades\Auth;

    /**
     * Вихід користувача із додатка.
     *
     * @param  \Illuminate\Http\Request  $request
     * @return \Illuminate\Http\Response
     */
    public function logout(Request $request)
    {
        Auth::logout();

        $request->session()->invalidate();

        $request->session()->regenerateToken();

        return redirect('/');
    }
```

<a name="invalidating-sessions-on-other-devices"></a>
### Анулювання сесій на інших пристроях

Laravel також пропонує механізм для «виходу» користувача та анулювання сесій, активних на інших пристроях, без анулювання сесії на його поточному пристрої. Цей функціонал зазвичай використовується, коли користувач змінює або оновлює свій пароль, і ви хочете скасувати сесії на інших пристроях, але зберегти автентифікацію поточного пристрою.

Перед тим, як почати, ви повинні переконатися, що посередник `Illuminate\Session\Middleware\AuthenticateSession` доданий у маршрути, які повинні отримувати автентифікацію сесії. Як правило, цей посередник слід розміщувати у визначенні групи маршрутів, щоб його можна було застосовувати до більшої кількості маршрутів вашої програми. За замовчуванням посередник `AuthenticateSession` може бути прикріплений до маршруту за допомогою ключа `auth.session`, як це визначено в ядрі HTTP вашого додатка:

```php
Route::middleware(['auth', 'auth.session'])->group(function () {
	Route::get('/', function () {
		// ...
	});
});
```
Потім можна використовувати метод `logoutOtherDevices` фасаду `Auth`. Цей метод вимагає, щоб користувач підтвердив свій поточний пароль, який ваш додаток має прийняти через форму введення:

```php
use Illuminate\Support\Facades\Auth;

Auth::logoutOtherDevices($currentPassword);
```
Коли викликається метод `logoutOtherDevices`, інші сесії користувача будуть повністю анульовані, тобто його буде «відключено» від усіх охоронців, якими він раніше був автентифікований.

<a name="password-confirmation"></a>
## Підтвердження паролю

Під час створення вашого додатка ви можете час від часу виконувати дії, які повинні вимагати від користувача підтвердження свого пароля перед виконанням дії або перед тим, як користувача буде перенаправлено до конфіденційної розділу додатка. Laravel містить вбудований `middleware`, щоб зробити цей процес легким. Реалізація цього функціоналу вимагатиме від вас визначити два маршрути: один маршрут для відображення перегляду з проханням користувача підтвердити свій пароль, а інший маршрут для підтвердження того, що пароль дійсний і перенаправити користувача до бажаного розділу.

> {tip} У наведеній нижче документації описано як напряму інтегруватися з функціоналом підтвердження пароля Laravel. Однак, якщо ви бажаєте розпочати роботу швидше, то [початкові пакети Laravel](starter-kits.md) вже мають підтримку цього функціоналу!

<a name="password-confirmation-configuration"></a>
### Конфігурація підтвердження пароля

Після підтвердження пароля користувачеві не пропонуватиметься повторно підтвердити пароль протягом трьох годин. Однак ви можете налаштувати час, після якого користувачеві буде запропоновано повторно ввести пароль, змінивши значення параметра конфігурації `password_timeout` у конфігураційному файлі `config/auth.php` вашого додатка.

<a name="password-confirmation-routing"></a>
### Маршрутизація підтвердження пароля

<a name="the-password-confirmation-form"></a>
#### Форма підтвердження пароля

По-перше, ми визначимо маршрут для відображення шаблону форми, який вимагає від користувача підтвердити свій пароль:

```php
Route::get('/confirm-password', function () {
	return view('auth.confirm-password');
})->middleware('auth')->name('password.confirm');
```
Як і можна було очікувати, шаблон, який повертається цим маршрутом, повинен мати форму, що містить поле `password`. Крім того, не соромтеся включити текст у вікно, яке пояснює, що користувач входить до захищеного розділу додатка та має підтвердити свій пароль.

<a name="confirming-the-password"></a>
#### Процес підтвердження пароля

Далі ми визначимо маршрут, який оброблятиме запит форми з шаблону «підтвердження пароля». Цей маршрут відповідатиме за перевірку пароля та перенаправлення користувача до місця призначення:

```php
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Facades\Redirect;

Route::post('/confirm-password', function (Request $request) {
	if (! Hash::check($request->password, $request->user()->password)) {
		return back()->withErrors([
			'password' => ['The provided password does not match our records.']
		]);
	}

	$request->session()->passwordConfirmed();

	return redirect()->intended();
})->middleware(['auth', 'throttle:6,1']);
```
Перш ніж рухатися далі, давайте розглянемо цей маршрут детальніше. По-перше, визначається, що поле `password` запиту дійсно відповідає паролю автентифікованого користувача. Якщо пароль дійсний, нам потрібно повідомити сесії Laravel, що користувач підтвердив свій пароль. Метод `passwordConfirmed` встановлює тимчасову мітку в сесії користувача, яку Laravel може використовувати, щоб визначити, коли користувач востаннє підтвердив свій пароль. Нарешті ми можемо перенаправити користувача за призначенням.

<a name="password-confirmation-protecting-routes"></a>
### Захист маршрутів

Ви повинні переконатися, що будь-якому маршруту, пов'язаному з підтвердженням пароля, призначено посередника `password.confirm`. Цей `middleware` присутній в Laravel за замовчуванням і автоматично зберігає передбачуване місце призначення користувача в сесії, щоб можна було перенаправити користувача в це місце після підтвердження свого пароля. Після збереження передбачуваного пункту призначення користувача в сесії, посередник перенаправить користувача на [іменований маршрут](routing.md#named-routes) `password.confirm`:

```php
Route::get('/settings', function () {
	// ...
})->middleware(['password.confirm']);

Route::post('/settings', function () {
	// ...
})->middleware(['password.confirm']);
```

<a name="adding-custom-guards"></a>
## Додавання власних охоронців автентифікації

Ви можете визначити власні засоби захисту автентифікації за допомогою методу `extend` фасаду `Auth`. Як правило, виклик цього методу здійснюється у методі `boot` [провайдера](providers.md) `App\Providers\AuthServiceProvider`. Оскільки Laravel вже поставляється з `AuthServiceProvider`, ми можемо розмістити код у цьому провайдері:

```php
<?php

namespace App\Providers;

use App\Services\Auth\JwtGuard;
use Illuminate\Foundation\Support\Providers\AuthServiceProvider as ServiceProvider;
use Illuminate\Support\Facades\Auth;

class AuthServiceProvider extends ServiceProvider
{
	/**
	 * Зареєструйте будь-які служби автентифікації/авторизації додатка.
	 *
	 * @return void
	 */
	public function boot()
	{
		$this->registerPolicies();

		Auth::extend('jwt', function ($app, $name, array $config) {
			// Повертає екземпляр `Illuminate\Contracts\Auth\Guard`...

			return new JwtGuard(Auth::createUserProvider($config['provider']));
		});
	}
}
```
Як ви можете бачити в прикладі вище, зворотний виклик, переданий методу extend, повинен повертати реалізацію `Illuminate\Contracts\Auth\Guard` Цей інтерфейс містить кілька методів, які вам потрібно буде реалізувати, щоб визначити власного охоронця. Після того, як власний охоронець буде визначено, ви можете посилатися на нього в конфігурації `guards` у файлі конфігурацій `config/auth.php`:

```php
'guards' => [
	'api' => [
		'driver' => 'jwt',
		'provider' => 'users',
	],
],
```

<a name="closure-request-guards"></a>
### Анонімні охоронці автентифікації на основі HTTP-запитів

Найпростіший спосіб реалізувати власну систему аутентифікації на основі HTTP-запитів – використовувати метод `Auth::viaRequest`. Цей метод дозволяє швидко визначити процес автентифікації за допомогою одного замикання.

Для початку викличте метод `Auth::viaRequest` у методі `boot` провайдера `App\Providers\AuthServiceProvider`. Метод `viaRequest` приймає ім'я драйвера автентифікації як перший аргумент. Це ім'я може бути будь-яким рядком, який описує вашого охоронця. Другий аргумент, що передається методу, має бути замикання, яке приймає вхідний HTTP-запит і повертає екземпляр користувача або якщо автентифікація не вдалася, то `null`:

```php
use App\Models\User;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;

/**
 * Регистрация любых служб аутентификации / авторизации.
 *
 * @return void
 */
public function boot()
{
	$this->registerPolicies();

	Auth::viaRequest('custom-token', function (Request $request) {
		return User::where('token', $request->token)->first();
	});
}
```
Після того, як ваш драйвер аутентифікації було визначено, ви можете налаштувати його як драйвер у конфігурації `guards` конфігураційного файлу `config/auth.php`:

```php
'guards' => [
	'api' => [
		'driver' => 'custom-token',
	],
],
```

<a name="adding-custom-user-providers"></a>
## Додавання власних провайдерів користувачів

Якщо ви не використовуєте традиційну реляційну базу даних для зберігання своїх користувачів, вам потрібно буде розширити Laravel за допомогою власного провайдера автентифікації користувачів. Ми будемо використовувати метод `provider` фасаду `Auth`, щоб визначити власного провайдера користувачів. Провайдер провайдера користувача має повертати реалізацію `Illuminate\Contracts\Auth\UserProvider`:

```php
<?php

namespace App\Providers;

use App\Extensions\MongoUserProvider;
use Illuminate\Foundation\Support\Providers\AuthServiceProvider as ServiceProvider;
use Illuminate\Support\Facades\Auth;

class AuthServiceProvider extends ServiceProvider
{
	/**
	 * Зареєструйте будь-які служби автентифікації/авторизації додатка.
	 *
	 * @return void
	 */
	public function boot()
	{
		$this->registerPolicies();

		Auth::provider('mongo', function ($app, array $config) {
			// Повертає екземпляр `Illuminate\Contracts\Auth\UserProvider`...

			return new MongoUserProvider($app->make('mongo.connection'));
		});
	}
}
```
Після того, як ви зареєстрували провайдера за допомогою методу `provider`, ви можете перейти до нового провайдера користувачів у файлі конфігурації `config/auth.php`. Спочатку визначте провайдера, який використовує ваш новий драйвер:

```php
'providers' => [
	'users' => [
		'driver' => 'mongo',
	],
],
```

Нарешті, ви можете вказати цього провайдера у своїй конфігурації `guards`:

```php
'guards' => [
	'web' => [
		'driver' => 'session',
		'provider' => 'users',
	],
],
```

<a name="the-user-provider-contract"></a>
### Контракт `UserProvider`

Реалізації `Illuminate\Contracts\Auth\UserProvider` відповідають за отримання реалізації `Illuminate\Contracts\Auth\Authenticatable` із системи постійного зберігання, такої як MySQL, MongoDB і т.п. Ці два інтерфейси дозволяють механізмам автентифікації Laravel продовжувати функціонувати незалежно від того, як зберігаються дані користувача або який тип класу використовується для надання автентифікованого користувача.

Давайте подивимося на контракт `Illuminate\Contracts\Auth\UserProvider`:

```php
<?php

namespace Illuminate\Contracts\Auth;

interface UserProvider
{
	public function retrieveById($identifier);
	public function retrieveByToken($identifier, $token);
	public function updateRememberToken(Authenticatable $user, $token);
	public function retrieveByCredentials(array $credentials);
	public function validateCredentials(Authenticatable $user, array $credentials);
}
```
- Метод `retrieveById` зазвичай отримує ключ, який представляє користувача, наприклад ідентифікатор із автоматичним збільшенням із бази даних MySQL. Реалізація `Authenticatable`, яка відповідає ідентифікатору, повинна бути отримана та повернена методом.

- Метод `retrieveByToken` отримує користувача за його унікальним `$identifier` і `$token`, який зазвичай зберігається в колонці `remember_token` бази даних. Як і в попередньому методі, цей метод повинен повертати реалізацію `Authenticatable`, яка відповідатиме значенню токена.

- Метод `updateRememberToken` оновлює `remember_token` екземпляра `$user` новим `$token`. Новий токен призначається користувачам після успішної спроби автентифікації "запам'ятати мене" або коли користувач виходить із системи.

- Метод `retrieveByCredentials` отримує масив облікових даних, переданих методу `Auth::attempt` під час спроби автентифікації за допомогою додатка. Потім метод повинен "запитувати" базове постійне сховище для користувача, який відповідає цим обліковим даним. Як правило, цей метод виконує запит із умовою `WHERE`, який шукає запис користувача з «ім’ям користувача», яке відповідає значенню `$credentials['username']`. Метод має повертати реалізацію `Authenticatable`. **Цей метод не повинен намагатися виконати будь-яку перевірку пароля або автентифікацію.**

Метод validateCredentials має порівнювати наданий `$user` з `$credentials` для автентифікації користувача. Наприклад, цей метод зазвичай використовує метод `Hash::check` для порівняння значення `$user->getAuthPassword()` зі значенням `$credentials['password']`. Цей метод має повертати значення `true` або `false`, вказуючи, чи дійсний пароль.

<a name="the-authenticatable-contract"></a>
### Контракт `Authenticatable`

Тепер, коли ми вивчили кожен з методів `UserProvider`, погляньмо на контракт `Authenticatable`. Пам'ятайте, що провайдери користувачів повинні повертати реалізації цього інтерфейсу з методів `retrieveById`, `retrieveByToken` та `retrieveByCredentials`:

```php
<?php

namespace Illuminate\Contracts\Auth;

interface Authenticatable
{
	public function getAuthIdentifierName();
	public function getAuthIdentifier();
	public function getAuthPassword();
	public function getRememberToken();
	public function setRememberToken($value);
	public function getRememberTokenName();
}
```
Цей інтерфейс простий. Метод `getAuthIdentifierName` повинен повертати ім'я поля первинного ключа користувача, а метод `getAuthIdentifier` повинен повертати первинний ключ користувача. При використанні серверної частини MySQL, це, ймовірно, буде автоінкрементний первинний ключ, що присвоюється запису користувача. Метод `getAuthPassword` має повертати хешований пароль користувача.

Цей інтерфейс дозволяє системі автентифікації працювати з будь-яким класом `User`, незалежно від того, який ORM або рівень абстракції сховища ви використовуєте. За замовчуванням Laravel включає клас `App\Models\User` до каталогу `app/Models`, який реалізує цей інтерфейс.

<a name="events"></a>
## Події

Laravel відправляє безліч [подій](events.md) у процесі автентифікації. Як правило, реєстрація слухачів цих подій здійснюється у постачальнику `App\Providers\EventServiceProvider`:

```php
/**
 * Карта слухачів подій додатків.
 *
 * @var array
 */
protected $listen = [
	'Illuminate\Auth\Events\Registered' => [
		'App\Listeners\LogRegisteredUser',
	],

	'Illuminate\Auth\Events\Attempting' => [
		'App\Listeners\LogAuthenticationAttempt',
	],

	'Illuminate\Auth\Events\Authenticated' => [
		'App\Listeners\LogAuthenticated',
	],

	'Illuminate\Auth\Events\Login' => [
		'App\Listeners\LogSuccessfulLogin',
	],

	'Illuminate\Auth\Events\Failed' => [
		'App\Listeners\LogFailedLogin',
	],

	'Illuminate\Auth\Events\Validated' => [
		'App\Listeners\LogValidated',
	],

	'Illuminate\Auth\Events\Verified' => [
		'App\Listeners\LogVerified',
	],

	'Illuminate\Auth\Events\Logout' => [
		'App\Listeners\LogSuccessfulLogout',
	],

	'Illuminate\Auth\Events\CurrentDeviceLogout' => [
		'App\Listeners\LogCurrentDeviceLogout',
	],

	'Illuminate\Auth\Events\OtherDeviceLogout' => [
		'App\Listeners\LogOtherDeviceLogout',
	],

	'Illuminate\Auth\Events\Lockout' => [
		'App\Listeners\LogLockout',
	],

	'Illuminate\Auth\Events\PasswordReset' => [
		'App\Listeners\LogPasswordReset',
	],
];
```