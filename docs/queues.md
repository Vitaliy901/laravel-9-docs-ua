# Черги

- [Вступ](#introduction)
  - [Підключення і Черги](#connections-vs-queues)
  - [Попередня Підготовка Драйверів](#driver-prerequisites)
- [Створення Завдань](#creating-jobs)
  - [Створення Класа Завдань](#generating-job-classes)
  - [Структура Класа](#class-structure)
  - [Унікальні Завдання](#unique-jobs)
- [Посередник Завдання](#job-middleware)
  - [Обмеження Частоти](#rate-limiting)
  - [Попередження Дублювання Завдання](#preventing-job-overlaps)
  - [Обмеження Частоти Генерації Винятків](#throttling-exceptions)
- [Відправлення Завдань](#dispatching-jobs)
  - [Відкладене Відправлення](#delayed-dispatching)
  - [Синхронне Відправлення](#synchronous-dispatching)
  - [Завдання та Транзакції Бази даних](#jobs-and-database-transactions)
  - [Ланцюжок Завдань](#job-chaining)
  - [Налаштування Черги та Підключення](#customizing-the-queue-and-connection)
  - [Вказівка ​Максимальної Кількості Спроб Завдання / Значень Тайм-ауту](#max-job-attempts-and-timeout)
  - [Виконання Помилок](#error-handling)
- [Партійне виконання Завдань](#job-batching)
  - [Визначення Партії Завдань](#defining-batchable-jobs)
  - [Відправлення Партії Завдань](#dispatching-batches)
  - [Додавання Завдань у Партії Завдань](#adding-jobs-to-batches)
  - [Інспектування Партії](#inspecting-batches)
  - [Скасування Партій](#cancelling-batches)
  - [Невдачі у Партії Завдань](#batch-failures)
  - [Очищення Партій](#pruning-batches)
- [Анонімні Черги](#queueing-closures)
- [Запуск Виконавця Черги](#running-the-queue-worker)
  - [Команда `queue:work`](#the-queue-work-command)
  - [Пріоритети Черги](#queue-priorities)
  - [Виконавці Черги та Розгортання](#queue-workers-and-deployment)
  - [Закінчення Терміну та Тайм-аути Завдання](#job-expirations-and-timeouts)
- [Конфігурація Supervisor](#supervisor-configuration)
- [Розбір Невдалих Завдань](#dealing-with-failed-jobs)
  - [Очищення Після Невдалих Завдань](#cleaning-up-after-failed-jobs)
  - [Повторна Спроба Виконання Невдалих Завдань](#retrying-failed-jobs)
  - [Ігнорування Відсутніх Моделей](#ignoring-missing-models)
  - [Видалення Невдалих Завдань](#pruning-failed-jobs)
  - [Зберігання Невдалих Завдань у DynamoDB](#storing-failed-jobs-in-dynamodb)
  - [Відключення Сховища Невдалих Завдань](#disabling-failed-job-storage)
  - [Події Невдалих Завдань](#failed-job-events)
- [Видалення Завдань з Черг](#clearing-jobs-from-queues)
- [Моніторинг Ваших Черг](#monitoring-your-queues)
- [Події Завдання](#job-events)

<a name="introduction"></a>

## Вступ

Під час створення вашого веб-додатка у вас можуть виникнути деякі завдання, як-от синтаксичний аналіз і збереження завантаженого файлу CSV, виконання яких, під час звичайного веб-запита займає надто багато часу. На щастя, Laravel дозволяє легко створювати завдання в черзі, які можуть виконуватися у фоновому режимі. Перемістивши завдання, які потребують багато часу, у чергу, ваш додаток може відповідати на веб-запити з неймовірною швидкістю та забезпечувати позитивний досвід роботи для ваших клієнтів.

Черги Laravel надають уніфікований API черги для різних серверних модулів черги, таких як [Amazon SQS](https://aws.amazon.com/sqs/), [Redis](https://redis.io), або навіть реляційної база даних.

Параметри конфігурації черги Laravel зберігаються у конфігураційному файлі додатка config/queue.php. У цьому файлі ви знайдете конфігурації підключення для кожного з драйверів черги, які входять до складу фреймворка, включаючи базу даних, [Amazon SQS](https://aws.amazon.com/sqs/), [Redis](https://redis.io) і драйвери [Beanstalkd](https://beanstalkd.github.io/), а також синхронний драйвер, який виконуватиме завдання негайно (використовується під час локальної розробки). Також включено драйвер черги `null`, який скасовує завдання в черзі.

> **Note**  
> Тепер Laravel пропонує Horizon, чудову інформаційну панель і систему конфігурації для ваших черг на основі Redis. Перегляньте повну [документацію Horizon](horizon.md) для отримання додаткової інформації.

<a name="connections-vs-queues"></a>

### Підключення і Черги

Перш ніж розпочати роботу з чергами Laravel, важливо зрозуміти різницю між «підкюченнями» та «чергами». У вашому конфігураційному файлі config/queue.php є масив конфігурації `connections`. Цей параметр визначає підключення з серверними службами черги, такими як Amazon SQS, Beanstalk або Redis. Однак будь-яке зазначене «підключення» черги може мати декілька «черг», які можна розглядати як різні стеки або купи завдань у черзі.

Зверніть увагу, що кожен приклад конфігурації підключення у файлі конфігурації `queue` містить ключ `queue`. Це черга за замовчуванням, до якої надсилатимуться завдання, коли вони надсилаються до певного підключення. Іншими словами, якщо ви відправляєте завдання без явного визначення черги, до якої його слід відправляти, завдання буде розміщено в черзі, яка визначена в атрибуті `queue` конфігурації підключення:

```php
use App\Jobs\ProcessPodcast;

// Це завдання надсилається до черги стандартного підключення за замовчуванням...
ProcessPodcast::dispatch();

// Це завдання надсилається до черги електронних листів за замовчуванням...
ProcessPodcast::dispatch()->onQueue('emails');
```

Деяким додаткам може не знадобитися надсилати завдання до декількох черг, натомість вони віддають перевагу одній черзі. Однак надсилання завдань до декількох черг може бути особливо корисним для додатків, які бажають розставляти пріоритети або сегментувати процес виконання завдань, оскільки виконавць черги Laravel дозволяє вам вказати, які черги він має виконувати за пріоритетом. Наприклад, якщо ви надсилаєте завдання до `high` черги, ви можете запустити виконавця, який надає їм вищий пріоритет виконання:

```shell
php artisan queue:work --queue=high,default
```

<a name="driver-prerequisites"></a>

### Попередня Підготовка Драйверів

<a name="database"></a>

#### База даних

Щоб використовувати драйвер черги `database`, вам знадобиться таблиця бази даних для зберігання завдань. Щоб створити міграцію, яка створює цю таблицю, виконайте команду `queue:table` Artisan. Після створення міграції ви можете додати її у свою базу даних за допомогою команди `migrate`:

```shell
php artisan queue:table

php artisan migrate
```

Нарешті, не забудьте вказати додатку використовувати драйвер `database`, оновивши змінну `QUEUE_CONNECTION` у файлі `.env` вашого додатка:

```
    QUEUE_CONNECTION=database
```

<a name="redis"></a>

#### Redis

Щоб використовувати драйвер черги `redis`, вам слід налаштувати підключення до бази даних `redis` у файлі конфігурації `config/database.php`.

**Кластер Redis**

Якщо ваше підключення до черги Redis використовує кластер Redis, імена вашої черги мають містити [хеш-тег ключа](https://redis.io/topics/cluster-spec#keys-hash-tags). Це потрібно для того, щоб переконатися, що всі ключі Redis для певної черги розміщено в одному хеш-слоті:

```php
'redis' => [
    'driver' => 'redis',
    'connection' => 'default',
    'queue' => '{default}',
    'retry_after' => 90,
],
```

**Блокування**

Під час використання черги Redis ви можете використовувати параметр конфігурації `block_for`, щоб вказати, як довго драйвер має чекати, поки завдання стане доступним, перш ніж виконати ітерацію робочого циклу та повторне опитування бази даних Redis.

Налаштування цього значення на основі завантаження черги може бути ефективнішим, ніж постійне опитування бази даних Redis щодо нових завдань. Наприклад, ви можете встановити значення `5`, щоб вказати, що драйвер повинен заблокувати на п’ять секунд, очікуючи, поки завдання стане доступним:

```php
'redis' => [
    'driver' => 'redis',
    'connection' => 'default',
    'queue' => 'default',
    'retry_after' => 90,
    'block_for' => 5,
],
```

> **Warning**  
> Встановлення `block_for` на `0` призведе до того, що виконавці черги будуть блокуватися на невизначений термін, доки не стане доступним завдання. Це також попереджатиме виконання таких сигналів, як `SIGTERM`, доки не буде виконано наступне завдання.

<a name="other-driver-prerequisites"></a>

#### Додаткові залежності драйверів

Для перелічених драйверів черги потрібні такі залежності. Ці залежності можна встановити через менеджер пакетів Composer:

<div class="content-list" markdown="1">

- Amazon SQS: `aws/aws-sdk-php ~3.0`
- Beanstalkd: `pda/pheanstalk ~4.0`
- Redis: `predis/predis ~1.0` or phpredis PHP extension

</div>

<a name="creating-jobs"></a>

## Створення завдань

<a name="generating-job-classes"></a>

### Створення класів завдань

За замовчуванням всі завдання, які стоять у черзі для вашого додатка, зберігаються в каталозі `app/Jobs`. Якщо каталог `app/Jobs` не існує, він буде створений під час виконання команди `make:job` Artisan:

```shell
php artisan make:job ProcessPodcast
```

Згенерований клас буде реалізовувати інтерфейс `Illuminate\Contracts\Queue\ShouldQueue`, вказуючи Laravel, що завдання має бути відправлено в чергу для асинхронного виконання.

> **Note**  
> Заготовки завдань можна налаштувати за допомогою [публікації заготовок](artisan.md#stub-customization).

<a name="class-structure"></a>

### Структура класу

Класи завдань дуже прості, зазвичай містять лише метод `handle`, який викликається, коли завдання виконується чергою. Для початку, давайте розглянемо приклад класа завдання. У цьому прикладі ми вдамо, що керуємо службою публікації подкастів і внас є необхідність опрацювати завантажені файли подкастів перед їх публікацією:

```php
<?php

namespace App\Jobs;

use App\Models\Podcast;
use App\Services\AudioProcessor;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;

class ProcessPodcast implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    /**
     * Екземпляр подкасту.
     *
     * @var \App\Models\Podcast
     */
    public $podcast;

    /**
     * Створити новий екземпляр завдання.
     *
     * @param  App\Models\Podcast  $podcast
     * @return void
     */
    public function __construct(Podcast $podcast)
    {
        $this->podcast = $podcast;
    }

    /**
     * Виконати завдання.
     *
     * @param  App\Services\AudioProcessor  $processor
     * @return void
     */
    public function handle(AudioProcessor $processor)
    {
        // Виконання завантаженого подкасту ...
    }
}
```

Зверніть увагу, що в цьому прикладі ми змогли передати [модель Eloquent](eloquent.md) безпосередньо в конструктор завдання. Завдяки трейту `SerializesModels`, який використовує завдання, моделі Eloquent та їхні завантажені відношення будуть коректно серіалізовані та десеріалізовані під час виконання завдання.

Якщо ваше завдання в черзі приймає модель Eloquent у своєму конструкторі, лише ідентифікатор моделі буде серіалізовано в чергу. Коли завдання фактично виконeється, система черги автоматично повторно отримає повний екземпляр моделі та його завантажені відношення з бази даних. Такий підхід до серіалізації моделі дозволяє відправляти до драйвера черги набагато менший обсяг даних.

<a name="handle-method-dependency-injection"></a>

#### Впровадженням залежностей метода `handle`

Метод `handle` викликається, коли завдання виконужться чергою. Зверніть увагу, що ми можемо визначати типи залежностей у методі `handle` завдання. [Контейнер служби](container.md) Laravel автоматично додає ці залежності.

Якщо ви хочете отримати повний контроль над тим, як контейнер вставляє залежності в метод `handle`, ви можете використовувати метод `bindMethod` контейнера. Метод `bindMethod` приймає зворотний виклик, який отримує завдання та контейнер. У зворотному виклику ви можете викликати метод виконання, як завгодно. Як правило, цей метод слід викликати з метода `boot` вашого [постачальника послуг](providers.md) `App\Providers\AppServiceProvider`:

```php
use App\Jobs\ProcessPodcast;
use App\Services\AudioProcessor;

$this->app->bindMethod([ProcessPodcast::class, 'handle'], function ($job, $app) {
    return $job->handle($app->make(AudioProcessor::class));
});
```

> **Warning**  
> Двійкові дані, як-от необроблений вміст зображення, слід передати через функцію `base64_encode` перед передачею до завдання в черзі. Інакше завдання може не бути належним чином серіалізовано в JSON під час розміщення в черзі.

<a name="handling-relationships"></a>

#### Відношення в черзі

Оскільки завантажені відношення також серіалізуються, серіалізований рядок завдання іноді може стати досить великим. Щоб запобігти серіалізації відношень, ви можете викликати метод `withoutRelations` у моделі під час встановлення значення властивості. Цей метод поверне екземпляр моделі без завантажених відношень:

```php
/**
 * Створіть новий екземпляр завдання.
 *
 * @param  \App\Models\Podcast  $podcast
 * @return void
 */
public function __construct(Podcast $podcast)
{
    $this->podcast = $podcast->withoutRelations();
}
```

Крім того, коли завдання десеріалізовано та модельні відношень повторно дістаються з бази даних, вони будуть витягнуті повністю. Будь-які попередні обмеження відношень, застосовані до серіалізації моделі під час процесу постановки в чергу завдань, не будуть застосовані під час десеріалізації завдання. Таким чином, якщо ви бажаєте працювати з підмножиною даного відношення, вам слід повторно обмежити це відношення у вашому завданні в черзі.

<a name="unique-jobs"></a>

### Унікальні завдання

> **Warning**  
> Для унікальних завдань потрібен драйвер кеша, який підтримує [блокування](cache.md#atomic-locks). Наразі драйвери `memcached`, `redis`, `dynamodb`, `database`, `file`, і `array`, підтримують атомарне блокування. Крім того, обмеження унікальних завдань не застосовуються до партійних завдань.

Іноді вам може знадобитися переконатися у тому, що в черзі в будь-який момент часу знаходиться лише один екземпляр певного завдання. Ви можете зробити це, реалізувавши інтерфейс `ShouldBeUnique` у своєму класі завдань. Цей інтерфейс не вимагає від вас визначення додаткових методів у вашому класі:

```php
<?php

use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Contracts\Queue\ShouldBeUnique;

class UpdateSearchIndex implements ShouldQueue, ShouldBeUnique
{
    ...
}
```

У наведеному вище прикладі завдання `UpdateSearchIndex` є унікальним. Отже, завдання не буде відправлено, якщо інший екземпляр завдання вже стоїть у черзі і не завершив виконання.

У деяких випадках ви можете визначити конкретний «ключ», який робить завдання унікальним, або ви можете вказати час очікування, після якого завдання більше не залишається унікальним. Щоб досягти цього, ви можете визначити властивості або методи `uniqueId` і `uniqueFor` у своєму класі завдань:

```php
<?php

use App\Product;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Contracts\Queue\ShouldBeUnique;

class UpdateSearchIndex implements ShouldQueue, ShouldBeUnique
{
    /**
     *  Екземпляр продукту.
     *
     * @var \App\Product
     */
    public $product;

    /**
     * Кількість секунд, після яких буде знято унікальне блокування завдання.
     *
     * @var int
     */
    public $uniqueFor = 3600;

    /**
     * Унікальний ідентифікатор завдання.
     *
     * @return string
     */
    public function uniqueId()
    {
        return $this->product->id;
    }
}
```

У наведеному вище прикладі завдання `UpdateSearchIndex` є унікальним за ідентифікатором продукту. Отже, будь-які нові надсилання завдання з тим самим ідентифікатором продукту ігноруватимуться, доки не завершиться виконання наявного завдання. Крім того, якщо наявне завдання не буде виконано протягом однієї години, унікальне блокування буде знято, і інше завдання з тим самим унікальним ключем може бути відправлено в чергу.

> **Warning**  
> Якщо ваш додаток відправляє завдання з кількох веб-серверів або контейнерів, ви повинні переконатися, що всі ваші сервери спілкуються з единим центральним кеш-сервером, щоб Laravel міг точно визначити, чи завдання унікальне.

<a name="keeping-jobs-unique-until-processing-begins"></a>

#### Зберігання завдань унікальними лише до початку виконання

За замовчуванням унікальні завдання «розблокуються» після того, як завдання завершить виконання або не вдасться виконати всі повторні спроби. Однак можуть виникнути ситуації, деб ви забажали, щоб ваше завдання було розблоковане безпосередньо перед його виконанням. Щоб досягти цього, ваше завдання має реалізувати контракт `ShouldBeUniqueUntilProcessing` замість контракту `ShouldBeUnique`:

```php
<?php

use App\Product;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Contracts\Queue\ShouldBeUniqueUntilProcessing;

class UpdateSearchIndex implements ShouldQueue, ShouldBeUniqueUntilProcessing
{
    // ...
}
```

<a name="unique-job-locks"></a>

#### Унікальні блокування завдань

За лаштунками, коли надсилається завдання `ShouldBeUnique`, Laravel намагається отримати [блокування](cache.md#atomic-locks) за допомогою ключа `uniqueId`. Якщо блокування не отримано, завдання не відправляється. Це блокування знімається, коли завдання завершує виконання або не вдається виконати всі повторні спроби. За замовчуванням Laravel використовуватиме драйвер кеша, який визначений за замовчуванням, щоб отримати це блокування. Однак, якщо ви бажаєте використовувати інший драйвер для отримання блокування, ви можете визначити метод `uniqueVia`, який повертає драйвер кеша, який слід використовувати:

```php
use Illuminate\Support\Facades\Cache;

class UpdateSearchIndex implements ShouldQueue, ShouldBeUnique
{
    ...

    /**
     * Отримайти драйвер кеша для унікального блокування завдання.
     *
     * @return \Illuminate\Contracts\Cache\Repository
     */
    public function uniqueVia()
    {
        return Cache::driver('redis');
    }
}
```

> **Note**  
> Якщо вам потрібно лише обмежити паралельне виконання завдання, замість цього використовуйте посередник для завдань [`WithoutOverlapping`](queues.md#preventing-job-overlaps).

<a name="job-middleware"></a>

## Посередник завдання

Посередник завдання дозволяє огорнути власну логіку навколо виконання завдань у черзі, зменшуючи шаблонність самих завдань. Наприклад, розглянемо наступний метод `handle`, який використовує функції обмеження частоти Redis від Laravel, щоб дозволити виконання лише одного завдання кожні п’ять секунд:

```php
use Illuminate\Support\Facades\Redis;

/**
 * Виконати завдання
 *
 * @return void
 */
public function handle()
{
    Redis::throttle('key')->block(0)->allow(1)->every(5)->then(function () {
        info('Lock obtained...');

        // Виконати завдання...
    }, function () {
        // Не вдалося отримати блокування...

        return $this->release(5);
    });
}
```

Хоча цей код дійсний, реалізація метода `handle` стає «шумною», оскільки вона пореповнюється логікою обмеження частоти Redis. Крім того, ця логіка обмеження частоти має бути продубльована для будь-яких інших завдань, які ми хочемо обмежити.

Замість обмеження частоти в методі `handle` ми могли б визначити посередник завдання, який виконуватиме обмеження частоти. Laravel не має стандартного розташування для посереника, тому ви можете розмістити посередника будь-де у своєму додатку. У цьому прикладі ми розмістимо посередник в каталозі `app/Jobs/Middleware`:

```php
<?php

namespace App\Jobs\Middleware;

use Illuminate\Support\Facades\Redis;

class RateLimited
{
    /**
     * Виконати завдання в черзі.
     *
     * @param  mixed  $job
     * @param  callable  $next
     * @return mixed
     */
    public function handle($job, $next)
    {
        Redis::throttle('key')
                ->block(0)->allow(1)->every(5)
                ->then(function () use ($job, $next) {
                    // Блокування отримано...

                    $next($job);
                }, function () use ($job) {
                    // Не вдалося отримати блокування...

                    $job->release(5);
                });
    }
}
```

Як бачите, як і посередник маршрутів, посередник завдання отримує виконане завдання та замикання, яке має бути викликане для продовження виконання завдання.

Після створення посередника завдання його можна приєднати до завдання, повернувши його із метода `middleware` завдання. Цей метод не існує для завдань, створених командою `make:job` Artisan, тому вам потрібно буде вручну додати його до класу завдань:

```php
use App\Jobs\Middleware\RateLimited;

/**
 * Отримайте посередника, через який має проходити завдання.
 *
 * @return array
 */
public function middleware()
{
    return [new RateLimited];
}
```

> **Note**  
> Посередник завдань також можна призначити слухачам подій у черзі, поштовим листам і сповіщенням.

<a name="rate-limiting"></a>

### Обмеження частоти виконання завдань

Хоч ми щойно і продемонстрували, як написати власний посередник обмеження частоти завдання, Laravel насправді містить посередник з обмеженням частоти, який ви можете використовувати для обмеження частоти завдань. Як і [обмежувачі частоти маршруту](routing.md#defining-rate-limiters), обмежувачі частоти завдання визначаються за допомогою фасада `RateLimiter` методом `for`.

Наприклад, ви можете дозволити користувачам створювати резервні копії своїх даних раз на годину, не накладаючи такого обмеження на преміальних клієнтів. Щоб досягти цього, ви можете визначити `RateLimiter` у методі `boot` вашого `AppServiceProvider`:

```php
use Illuminate\Cache\RateLimiting\Limit;
use Illuminate\Support\Facades\RateLimiter;

/**
 * Завантажте будь-які служби додатків.
 *
 * @return void
 */
public function boot()
{
    RateLimiter::for('backups', function ($job) {
        return $job->user->vipCustomer()
            ? Limit::none()
            : Limit::perHour(1)->by($job->user->id);
    });
}
```

У наведеному вище прикладі ми визначили годинний ліміт частоти; однак ви можете легко визначити обмеження частоти на основі хвилин за допомогою методу `perMinute`. Крім того, ви можете передати будь-яке значення методу `by` обмеження частоти; однак це значення найчастіше використовується для сегментації обмежень частоти по клієнтам:

```php
return Limit::perMinute(50)->by($job->user->id);
```

Визначивши обмеження частоти, ви можете приєднати обмежувач частоти до завдання резервного копіювання за допомогою посередника `Illuminate\Queue\Middleware\RateLimited`. Кожного разу, коли завдання перевищує обмеження частоти, цей посередник повертає завдання до черги з відповідною затримкою на основі тривалості обмеження частоти.

```php
use Illuminate\Queue\Middleware\RateLimited;

/**
 * Отримайти посередника, через якй має проходити завдання.
 *
 * @return array
 */
public function middleware()
{
    return [new RateLimited('backups')];
}
```

Повернення завдання з обмеженою частотою назад до черги призведе до збільшення загальної кількості `attempts` завдання. Можливо ви забажаєте відповідним чином налаштувати властивості `tries` і `maxExceptions` у своєму класі завдань. Або ви можете використати [метод `retryUntil`](#time-based-attempts), щоб визначити час, по завершенню якого спроб виконання завдання більше не буде.

Якщо ви не хочете, щоб завдання повторювалося, коли його частота обмежена, ви можете скористатися методом `dontRelease`:

```php
/**
 * Отримайти посередника, через який має проходити завдання.
 *
 * @return array
 */
public function middleware()
{
    return [(new RateLimited('backups'))->dontRelease()];
}
```

> **Note**  
> Якщо ви використовуєте Redis, ви можете використовувати посередник `Illuminate\Queue\Middleware\RateLimitedWithRedis`, який точно налаштовано для Redis, і який ефективніший, ніж базовий посередник з обмеженням частоти.

<a name="preventing-job-overlaps"></a>

### Попередження дублювання завдання

Laravel містить посередник `Illuminate\Queue\Middleware\WithoutOverlapping`, який дозволяє попередити дублюванню завдань на основі довільного ключа. Це може бути корисним, коли завдання в черзі змінює ресурс, який має бути змінено лише одним завданням за раз.

Наприклад, уявімо, що у вас є завдання в черзі, яке оновлює кредитний рейтинг користувача, і ви хочете попередити дублювання завдання, яке оновлює кредитний рейтинг для того самого ідентифікатора користувача. Щоб досягти цього, ви можете повернути посередник `WithoutOverlapping` із метода `middleware` вашого завдання:

```php
use Illuminate\Queue\Middleware\WithoutOverlapping;

/**
 * Отримайте посередника, через який має проходити завдання.
 *
 * @return array
 */
public function middleware()
{
    return [new WithoutOverlapping($this->user->id)];
}
```

Будь-які завдання, які накладаються, повернуться до черги. Ви також можете вказати кількість секунд, які мають пройти перед повторною спробою звільненого завдання:

```php
/**
 * Отримайте посередника, через який має проходити завдання.
 *
 * @return array
 */
public function middleware()
{
    return [(new WithoutOverlapping($this->order->id))->releaseAfter(60)];
}
```

Якщо ви хочете негайно видалити всі завдання, які накладаються, щоб вони не повторювалися, ви можете використовувати метод `dontRelease`:

```php
/**
 * Отримайте посередника, через який має проходити завдання.
 *
 * @return array
 */
public function middleware()
{
    return [(new WithoutOverlapping($this->order->id))->dontRelease()];
}
```

Посередник `WithoutOverlapping` працює на основі атомарного блокування Laravel. Іноді ваше завдання може неочікувано завершитися збоєм або сплином часу, у таких випадках блокування не буде знято. Тому ви можете явно визначити час закінчення дії блокування за допомогою метода `expireAfter`. Наприклад, наведений нижче приклад накаже Laravel зняти блокування `WithoutOverlapping` через три хвилини після початку виконання завдання:

```php
/**
 * Отримайте посередника, через який має проходити завдання.
 *
 * @return array
 */
public function middleware()
{
    return [(new WithoutOverlapping($this->order->id))->expireAfter(180)];
}
```

> **Warning**  
> Посередник `WithoutOverlapping` вимагає драйвера кеша, який підтримує [блокування](cache.md#atomic-locks). Наразі драйвери `memcached`, `redis`, `dynamodb`, `database`, `file`, і `array` підтримують атомарне блокування.

<a name="throttling-exceptions"></a>

### Обмеження частоти генерації винятків

Laravel містить посередник `Illuminate\Queue\Middleware\ThrottlesExceptions`, який дозволяє регулювати винятки. Після того, як завдання створює задану кількість винятків, всі подальші спроби виконати завдання відкладаються, доки не закінчиться вказаний проміжок часу. Цей посередник особливо корисний для завдань, які взаємодіють з нестабільними сторонніми службами.

Наприклад, уявімо завдання в черзі, яке взаємодіє зі стороннім API, який починає створювати винятки. Щоб обмежити винятки, ви можете повернути посередник `ThrottlesExceptions` з метода `middleware` вашого завдання. Як правило, цей посередник має поєднуватися з завданням, яке реалізує [спроби на основі часу](#time-based-attempts):

```php
use Illuminate\Queue\Middleware\ThrottlesExceptions;

/**
 * Отримайте посередника, через який має проходити завдання.
 *
 * @return array
 */
public function middleware()
{
    return [new ThrottlesExceptions(10, 5)];
}

/**
 * Визначте час очікування завдання.
 *
 * @return \DateTime
 */
public function retryUntil()
{
    return now()->addMinutes(5);
}
```

Перший аргумент конструктора, прийнятий посередником, — це кількість винятків, які завдання може створити перед обмеженням, у той час як другий аргумент конструктора — це кількість хвилин, які мають пройти до повторної спроби виконання завдання після його обмеження. Як описано в коді вище, якщо завдання видає 10 винятків протягом 5 хвилин, ми зачекаємо 5 хвилин, перш ніж спробувати виконати завдання знову.

Якщо завдання створює виняток, але поріг винятку ще не досягнуто, завдання як правило, повторюється негайно. Однак ви можете вказати кількість хвилин, на які таке завдання має бути відкладено, викликавши метод `backoff` під час підключення посередника до завдання:

```php
use Illuminate\Queue\Middleware\ThrottlesExceptions;

/**
 * Отримайте посередника, через який має проходити завдання.
 *
 * @return array
 */
public function middleware()
{
    return [(new ThrottlesExceptions(10, 5))->backoff(5)];
}
```

Внутрішньо цей посередник використовує систему кеша Laravel для реалізації обмеження частоти, а ім’я класа завдання використовується як «ключ» кеша. Ви можете замінити цей ключ, викликавши метод `by` під час підключення посередника до вашого завдання. Це може бути корисно, якщо у вас є кілька завдань, які взаємодіють з однією сторонньою службою, і ви хочете, щоб вони спільно використовували загальну регулюючу «корзину»:

```php
use Illuminate\Queue\Middleware\ThrottlesExceptions;

/**
 * Отримайте посередника, через який має проходити завдання.
 *
 * @return array
 */
public function middleware()
{
    return [(new ThrottlesExceptions(10, 10))->by('key')];
}
```

> **Note**  
> Якщо ви використовуєте Redis, ви можете використовувати посередник Illuminate\Queue\Middleware\ThrottlesExceptionsWithRedis, який точно налаштовано для Redis, і який є ефективнішим, ніж базовий посередник винятка обмеження частоти.

<a name="dispatching-jobs"></a>

## Відправка завдань

Після того, як ви написали свій клас завдання, ви можете відправити його за допомогою метода `dispatch` самого ж завдання. Аргументи, передані методу `dispatch`, будуть передані конструктору завдання:

```php
<?php

namespace App\Http\Controllers;

use App\Http\Controllers\Controller;
use App\Jobs\ProcessPodcast;
use App\Models\Podcast;
use Illuminate\Http\Request;

class PodcastController extends Controller
{
    /**
     * Зберегти новий подкаст.
     *
     * @param  \Illuminate\Http\Request  $request
     * @return \Illuminate\Http\Response
     */
    public function store(Request $request)
    {
        $podcast = Podcast::create(/* ... */);

        // ...

        ProcessPodcast::dispatch($podcast);
    }
}
```

Якщо ви хочете умовно відправити завдання, ви можете використовувати методи `dispatchIf` і `dispatchUnless`:

```php
ProcessPodcast::dispatchIf($accountActive, $podcast);

ProcessPodcast::dispatchUnless($accountSuspended, $podcast);
```

У нових дадатках Laravel драйвер `sync` є драйвером черги за замовчуванням. Цей драйвер виконує завдання синхронно на передньому плані поточного запита, що зазвичай зручно під час локальної розробки. Якщо ви дійсно бажаєте почати чергування завданнь для фонового виконання, ви можете вказати інший драйвер черги у конфігураційному файлі додатка `config/queue.php`.

<a name="delayed-dispatching"></a>

### Відкладена відправка

Якщо ви бажаєте вказати, що завдання не повинно бути негайно доступним для виконавця черги, ви можете використовувати метод `delay` під час відправлення завдання. Наприклад, давайте вкажемо, що завдання не повинно бути доступним для виконання протягом 10 хвилин після його відправки:

```php
<?php

namespace App\Http\Controllers;

use App\Http\Controllers\Controller;
use App\Jobs\ProcessPodcast;
use App\Models\Podcast;
use Illuminate\Http\Request;

class PodcastController extends Controller
{
    /**
     * Зберегти новий подкаст.
     *
     * @param  \Illuminate\Http\Request  $request
     * @return \Illuminate\Http\Response
     */
    public function store(Request $request)
    {
        $podcast = Podcast::create(/* ... */);

        // ...

        ProcessPodcast::dispatch($podcast)
            ->delay(now()->addMinutes(10));
    }
}
```

> **Warning**  
> Служба черги Amazon SQS має максимальний час затримки 15 хвилин.

<a name="dispatching-after-the-response-is-sent-to-browser"></a>

#### Надсилання завдання після надсилання відповіді браузеру

Крім того, метод `dispatchAfterResponse` затримує відправлення завдання до моменту відправлення HTTP-відповіді в браузер користувача. Це все одно дозволить користувачеві розпочати використовувати додаток, навіть якщо завдання в черзі все ще виконується. Оскільки вони виконуються в рамках поточного HTTP-запита, завдання надіслані таким чином, не вимагають запуску виконавця черги для їх виконання:

```php
use App\Jobs\SendNotification;

SendNotification::dispatchAfterResponse();
```

Ви також можете надіслати замикання та зв’язати метод `afterResponse` з помічником `dispatch` , щоб виконати замикання після того, як відповідь HTTP буде надіслано браузеру:

```php
use App\Mail\WelcomeMessage;
use Illuminate\Support\Facades\Mail;

dispatch(function () {
    Mail::to('taylor@example.com')->send(new WelcomeMessage);
})->afterResponse();
```

<a name="synchronous-dispatching"></a>

### Синхронне відправлення

Якщо ви хочете відправити завдання негайно (синхронно), ви можете скористатися методом `dispatchSync`. При використанні цього методу завдання не буде поставлено в чергу і буде виконано негайно в рамках поточного процесу:

```php
<?php

namespace App\Http\Controllers;

use App\Http\Controllers\Controller;
use App\Jobs\ProcessPodcast;
use App\Models\Podcast;
use Illuminate\Http\Request;

class PodcastController extends Controller
{
    /**
     * Збережіть новий подкаст.
     *
     * @param  \Illuminate\Http\Request  $request
     * @return \Illuminate\Http\Response
     */
    public function store(Request $request)
    {
        $podcast = Podcast::create(/* ... */);

        // Створити подкаст...

        ProcessPodcast::dispatchSync($podcast);
    }
}
```

<a name="jobs-and-database-transactions"></a>

### Завдання і транзкації бази данних

Хоча цілком нормально відправляти завдання в рамках транзакцій бази даних, ви повинні бути особливо уважними, щоб переконатися, що ваше завдання справді зможе успішно виконуватися. Під час відправлення завдання в рамках транзакції можливо, що завдання буде виконано до того, як буде зафіксовано батьківську транзакцію. Коли це станеться, будь-які оновлення, які ви зробили в моделях або записах бази даних під час транзакцій бази даних, можуть ще не відображатися в базі даних. Крім того, будь-які моделі або записи бази даних, створені в рамках транзакції, можуть не існувати в базі даних.

На щастя, Laravel пропонує кілька методів вирішення цієї проблеми. По-перше, ви можете встановити параметр підключення `after_commit` у масиві конфігурації підключення з чергою:

```php
'redis' => [
    'driver' => 'redis',
    // ...
    'after_commit' => true,
],
```

Коли параметр `after_commit` має значення `true`, ви можете відправляти завдання в рамках транзакцій бази даних; однак Laravel чекатиме, доки транзакції відкритої батьківської бази даних не будуть зафіксовані, перш ніж фактично відправити завдання. Звичайно, якщо транзакції бази даних наразі не відкриті, завдання буде відправлено негайно.

Якщо транзакцію відкатують через виняткову ситуацію, яка виникає під час транзакції, завдання, які було надіслано під час цієї транзакції, буде відхилено.

> **Note**  
> Встановлення для параметра конфігурації `after_commit` значення `true` також призведе до відправки всіх слухачів подій у черзі, електронних листів, сповіщень і широкомовних подій після завершення всіх відкритих транзакцій бази даних.

<a name="specifying-commit-dispatch-behavior-inline"></a>

#### Встановлення внутрішньої поведінки надсилання при фіксації транзакцій БД

Якщо ви не встановите для параметра конфігурації підключення черги `after_commit` значення `true`, ви все одно можете вказати, що конкретне завдання має бути відправлено після того, як всі відкриті транзакції бази даних будуть зафіксовані. Щоб досягти цього, ви можете приєднати метод `afterCommit` до вашої операції відправки:

```php
use App\Jobs\ProcessPodcast;

ProcessPodcast::dispatch($podcast)->afterCommit();
```

Подібним чином, якщо для параметра конфігурації `after_commit` встановлено значення `true`, ви можете вказати, що конкретне завдання має бути відправлено негайно, не чекаючи на фіксацію відкритої транзакції бази даних:

```php
ProcessPodcast::dispatch($podcast)->beforeCommit();
```

<a name="job-chaining"></a>

### Ланцюжок завдань

Ланцюжок завдань дозволяє вказати список завдань у черзі, які слід виконувати послідовно після успішного виконання основного завдання. Якщо одне завдання в послідовності не вдасться, решта завдань не будуть запущені. Щоб виконати ланцюжок завдань із черги, ви можете використати метод `chain`, наданий фасадом `Bus`. Командна шина Laravel — це компонент нижчого рівня, на основі якого побудовано постачання завдань у черги:

```php
use App\Jobs\OptimizePodcast;
use App\Jobs\ProcessPodcast;
use App\Jobs\ReleasePodcast;
use Illuminate\Support\Facades\Bus;

Bus::chain([
    new ProcessPodcast,
    new OptimizePodcast,
    new ReleasePodcast,
])->dispatch();
```

Окрім зв’язування екземплярів класів завдань, ви також можете під'язувати замикання:

```php
Bus::chain([
    new ProcessPodcast,
    new OptimizePodcast,
    function () {
        Podcast::update(/* ... */);
    },
])->dispatch();
```

> **Warning**  
> Видалення завдань за допомогою метода `$this->delete()` в середині завдання не завадить виконаннб зв’язаних завдань. Ланцюжок припинить виконання, лише якщо завдання в ланцюжку не вдасться.

<a name="chain-connection-queue"></a>

#### Підключення та черга ланцюжкових завдань

Якщо ви бажаєте вказати підключення та чергу, які мають використовуватися для пов'язаних завдань, ви можете використати методи `onConnection` і `onQueue`. Ці методи вказують підключення до черги та ім’я черги, які слід використовувати, якщо завданню в черзі явно не призначено інше підключення / чергу:

```php
Bus::chain([
    new ProcessPodcast,
    new OptimizePodcast,
    new ReleasePodcast,
])->onConnection('redis')->onQueue('podcasts')->dispatch();
```

<a name="chain-failures"></a>

#### Збої в ланцюжках завдань

Під час ланцюжка завдань ви можете використовувати метод `catch`, щоб вказати замикання, яке має бути викликано, якщо завдання в ланцюжку не вдається. Даний зворотний виклик отримає екземпляр `Throwable`, який спричинив збій завдання:

```php
use Illuminate\Support\Facades\Bus;
use Throwable;

Bus::chain([
    new ProcessPodcast,
    new OptimizePodcast,
    new ReleasePodcast,
])->catch(function (Throwable $e) {
    // Не вдалося виконати завдання в ланцюжку...
})->dispatch();
```

<a name="customizing-the-queue-and-connection"></a>

### Налаштування черги та підключення

<a name="dispatching-to-a-particular-queue"></a>

#### Відправлення у певну чергу

Розміщуючи завдання в різних чергах, ви можете «класифікувати» ваші завдання в черзі та навіть визначити пріоритетність кількості виконавців, які ви призначаєте до різних черг. Пам’ятайте, що це не надсилає завдання до різних «підключень» черги, як визначено у файлі конфігурації черги, а лише до певних черг у межах одного підключення. Щоб вказати чергу, використовуйте метод `onQueue` під час відправки завдання:

```php
<?php

namespace App\Http\Controllers;

use App\Http\Controllers\Controller;
use App\Jobs\ProcessPodcast;
use App\Models\Podcast;
use Illuminate\Http\Request;

class PodcastController extends Controller
{
    /**
     * Зберегти новий подкаст.
     *
     * @param  \Illuminate\Http\Request  $request
     * @return \Illuminate\Http\Response
     */
    public function store(Request $request)
    {
        $podcast = Podcast::create(/* ... */);

        // Створення подкаста ...

        ProcessPodcast::dispatch($podcast)->onQueue('processing');
    }
}
```

Крім того, ви можете вказати чергу завдання, викликавши метод `onQueue` у конструкторі завдання:

```php
<?php

namespace App\Jobs;

    use Illuminate\Bus\Queueable;
    use Illuminate\Contracts\Queue\ShouldQueue;
    use Illuminate\Foundation\Bus\Dispatchable;
    use Illuminate\Queue\InteractsWithQueue;
    use Illuminate\Queue\SerializesModels;

class ProcessPodcast implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    /**
     * Створити новий екземпляр завдання.
     *
     * @return void
     */
    public function __construct()
    {
        $this->onQueue('processing');
    }
}
```

<a name="dispatching-to-a-particular-connection"></a>

#### Надсилання у певне підключення

Якщо ваш додаток взаємодіє з декількома підключеннями черги, ви можете вказати, до якого підключення надсилати завдання за допомогою методу `onConnection`:

```php
<?php

namespace App\Http\Controllers;

use App\Http\Controllers\Controller;
use App\Jobs\ProcessPodcast;
use App\Models\Podcast;
use Illuminate\Http\Request;

class PodcastController extends Controller
{
    /**
     * Створити новий екземпляр завдання.
     *
     * @param  \Illuminate\Http\Request  $request
     * @return \Illuminate\Http\Response
     */
    public function store(Request $request)
    {
        $podcast = Podcast::create(/* ... */);

        // Створення подкаста ...

        ProcessPodcast::dispatch($podcast)->onConnection('sqs');
    }
}
```

Ви можете об’єднати методи `onConnection` і `onQueue` разом, щоб визначити підключення та чергу для завдання:

```php
ProcessPodcast::dispatch($podcast)
        ->onConnection('sqs')
        ->onQueue('processing');
```

Крім того, ви можете вказати підключення завдання, викликавши метод `onConnection` у конструкторі завдання:

```php
<?php

namespace App\Jobs;

    use Illuminate\Bus\Queueable;
    use Illuminate\Contracts\Queue\ShouldQueue;
    use Illuminate\Foundation\Bus\Dispatchable;
    use Illuminate\Queue\InteractsWithQueue;
    use Illuminate\Queue\SerializesModels;

class ProcessPodcast implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    /**
     * Створіть новий екземпляр завдання.
     *
     * @return void
     */
    public function __construct()
    {
        $this->onConnection('sqs');
    }
}
```

<a name="max-job-attempts-and-timeout"></a>

### Вказівка ​​максимальної кількості спроб / значень часу очікування

<a name="max-attempts"></a>

#### Максимальна кількість спроб

Якщо одне з ваших завдань у черзі наштовхуються на помилкою, ви, швидше за все, не хочете, щоб воно повторювалося безкінечно. Таким чином, Laravel надає різні способи вказати, скільки разів або як довго завдання буде повторно виконуватись.

Одним із підходів до визначення максимальної кількості спроб виконання завдання є перемикач `--tries` у командному рядку Artisan. Це буде застосовуватися до всіх завдань виконавця, якщо виконане завдання не вказує більш конкретну кількість спроб його виконання:

```shell
php artisan queue:work --tries=3
```

Якщо завдання перевищує максимальну кількість спроб, воно вважатиметься «невдалим». Для отримання додаткової інформації щодо виконання невдалих завдань зверніться до [документації невдалих завдань](#dealing-with-failed-jobs).

Ви можете застосувати більш детальний підхід, вказавши максимальну кількість спроб виконання завдання для самого класу завдання. Якщо для завдання вказано максимальну кількість спроб, вони матимуть пріоритет над значенням `--tries`, наданим у командному рядку:

```php
<?php

namespace App\Jobs;

class ProcessPodcast implements ShouldQueue
{
    /**
     * Кількість спроб виконання завдання.
     *
     * @var int
     */
    public $tries = 5;
}
```

<a name="time-based-attempts"></a>

#### Спроби на основі часу

Як альтернатива визначенню того, скільки разів можна спробувати виконати завдання, перш ніж воно буде невдалим, ви можете визначити час, коли завдання більше не слід виконувати. Це дозволяє виконувати завдання будь-яку кількість разів протягом заданого періоду часу. Щоб визначити час, коли завдання більше не слід виконувати, додайте метод `retryUntil` до свого класу завдань. Цей метод має повертати екземпляр `DateTime`:

```php
    /**
     * Визначте часову межу спроб для виконання завдання.
     *
     * @return \DateTime
     */
    public function retryUntil()
    {
        return now()->addMinutes(10);
    }
```

> **Note**  
> Ви також можете визначити властивість `tries` або метод `retryUntil` для [слухачів подій у черзі](events.md#queued-event-listeners).

<a name="max-exceptions"></a>

#### Максимальна кількість винятків

Іноді ви можете вказати, що завдання може бути виконано багато разів, але воно повинно завершитися невдачею, якщо повторні спроби викликані певною кількістю невиконаних винятків (на відміну від безпосереднього звільнення методом `release`). Щоб досягти цього, ви можете визначити властивість `maxExceptions` у своєму класі завдань:

```php
<?php

namespace App\Jobs;

use Illuminate\Support\Facades\Redis;

class ProcessPodcast implements ShouldQueue
{
    /**
     * Кількість спроб виконання завдання.
     *
     * @var int
     */
    public $tries = 25;

    /**
     * Максимальна кількість невиконаних винятків, які дозволено перед збоєм.
     *
     * @var int
     */
    public $maxExceptions = 3;

    /**
     * Виконати завдання.
     *
     * @return void
     */
    public function handle()
    {
        Redis::throttle('key')->allow(10)->every(60)->then(function () {
            // Отримано блокування, порацюйте подкаст...
        }, function () {
            // Не вдалося отримати блокування...
            return $this->release(10);
        });
    }
}
```

У цьому прикладі завдання звільняється на десять секунд, якщо додаток не може отримати блокування Redis, і продовжить повторюватися до 25 разів. Однак завдання завершиться невдачею, якщо завдання створить три невиконані винятки.

<a name="timeout"></a>

#### Перерва

> **Warning**  
> Розширення PHP `pcntl` має бути встановлено, щоб вказати час завершення завдань.

Часто ви приблизно знаєте, скільки часу займе виконання завдань у черзі. З цієї причини Laravel дозволяє вам визначити значення «тайм-ауту». Якщо завдання виконується довше, ніж кількість секунд, вказана значенням тайм-ауту, виконавць завершиться з помилкою. Як правило, виконавця буде автоматично перезапущено [менеджером процесів, налаштованим на вашому сервері.](#supervisor-configuration).

Максимальну кількість секунд, протягом яких завдання можуть виконуватися, можна вказати за допомогою параметра `--timeout` у командному рядку Artisan:

```shell
php artisan queue:work --timeout=30
```

Якщо завдання перевищує максимальну кількість спроб через постійний тайм-аут, воно буде позначено як невдале.

Ви також можете визначити максимальну кількість секунд, протягом яких завдання має виконуватися в самому класі завдань. Якщо тайм-аут вказано в завданні, він матиме пріоритет над будь-яким тайм-аутом, вказаним у командному рядку:

```php
<?php

namespace App\Jobs;

class ProcessPodcast implements ShouldQueue
{
    /**
     * Кількість секунд, протягом яких завдання може виконуватися до закінчення визначеного часу.
     *
     * @var int
     */
    public $timeout = 120;
}
```

Іноді процеси блокування вводу-виводу, такі як сокети або вихідні HTTP-з’єднання, можуть не враховувати вказаний вами тайм-аут. Тому, використовуючи цеі функції, ви завжди повинні намагатися вказати тайм-аутЮ за допомогою їхніх API. Наприклад, використовуючи Guzzle, ви завжди повинні вказувати значення запита і тайм-аута підключення.

<a name="failing-on-timeout"></a>

#### Помилка тайм-ауту

Якщо ви бажаєте вказати, що завдання має бути позначене як [невиконане](#dealing-with-failed-jobs) після тайм-ауту, ви можете визначити властивість `$failOnTimeout` у класі завдань:

```php
/**
 * Вкажіть, чи має завдання позначатися як невдале після тайм-ауту.
 *
 * @var bool
 */
public $failOnTimeout = true;
```

<a name="error-handling"></a>

### Виконання помилок

Якщо під час виконання завдання виникає виняток, завдання автоматично повертається до черги, щоб його можна було повторити. Завдання продовжуватиме звільнятися, доки його не буде виконано дозволену максимальну кількість разів, вашим додатком. Максимальна кількість спроб визначається перемикачем `--tries`, який використовується в команді `queue:work` Artisan. Крім того, максимальну кількість спроб можна визначити в самому класі завдання. Додаткову інформацію про запуск виконавця черги [можна знайти нижче](#running-the-queue-worker).

<a name="manually-releasing-a-job"></a>

#### Звільнення завдання вручну

Іноді вам може знадобитися вручну повернути завдання до черги, щоб можна було повторити його пізніше. Ви можете зробити це, викликавши метод `release`:

```php
/**
 * Виконайте завдання.
 *
 * @return void
 */
public function handle()
{
    // ...

    $this->release();
}
```

За замовчуванням метод `release` повертає завдання назад у чергу для негайного виконання. Однак, передавши ціле число в метод `release`, ви можете наказати черзі не робити завдання доступним для виконання, доки не мине задана кількість секунд:

```php
$this->release(10);
```

<a name="manually-failing-a-job"></a>

#### Навмисна невдача завдання

Іноді вам може знадобитися вручну позначити завдання як «не виконане». Для цього ви можете викликати метод `fail`:

```php
/**
 * Виконати завдання
 *
 * @return void
 */
public function handle()
{
    // ...

    $this->fail();
}
```

Якщо ви бажаєте позначити своє завдання як невдале через виняткок, який ви спіймали, ви можете передати виняток методу `fail`:

```php
$this->fail($exception);
```

Щоб отримати додаткові відомості про невдалі завдання, ознайомтеся з документацією щодо роботи з невдалими завданнями.

> **Note**  
> For more information on failed jobs, check out the [documentation on dealing with job failures](#dealing-with-failed-jobs).

<a name="job-batching"></a>

## Партійне виконання завдань

Функціонал партійності завдань Laravel дозволяє вам легко виконати партію завдань, а потім виконати певну дію, коли партія завдань завершить виконання. Перш ніж почати, ви повинні створити міграцію бази даних, щоб побудувати таблицю, яка містить метаінформацію про ваші партії завдань, наприклад відсоток їх виконання. Цю міграцію можна згенерувати за допомогою команди `queue:batches-table` Artisan:

```shell
php artisan queue:batches-table

php artisan migrate
```

<a name="defining-batchable-jobs"></a>

### Визначення партійних завдань

Щоб визначити партнійне завдання, ви повинні[створити завдання в черзі](#creating-jobs), як зазвичай; однак вам слід додати трейт `Illuminate\Bus\Batchable` до класу завдань. Цей трейт надає доступ до метода `batch`, який можна використовувати для отримання поточної партії, в якій виконується завдання:

```php
<?php

namespace App\Jobs;

use Illuminate\Bus\Batchable;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;

class ImportCsv implements ShouldQueue
{
    use Batchable, Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    /**
     * Виконати завдання.
     *
     * @return void
     */
    public function handle()
    {
        if ($this->batch()->cancelled()) {
            // Визначаємо, чи партія була скасована ...

            return;
        }

        // Імпортувати частину файлу CSV...
    }
}
```

<a name="dispatching-batches"></a>

### Вдправлення партії завданнь

Щоб відправити партію завдань, слід використовувати `batch` метод фасада `Bus`. Звичайно, партійність корисна в першу чергу в поєднанні з зворотними викликами завершення. Отже, ви можете використовувати методи `then`, `catch`, і `finally` щоб визначити зворотні виклики завершення для партії. Кожен з цих зворотних викликів отримає екземпляр `Illuminate\Bus\Batch`, коли їх буде викликано. У цьому прикладі ми уявимо, що ми ставимо в чергу партію завдань, кожне з яких виконує певну кількість рядків із файлу CSV:

```php
use App\Jobs\ImportCsv;
use Illuminate\Bus\Batch;
use Illuminate\Support\Facades\Bus;
use Throwable;

$batch = Bus::batch([
    new ImportCsv(1, 100),
    new ImportCsv(101, 200),
    new ImportCsv(201, 300),
    new ImportCsv(301, 400),
    new ImportCsv(401, 500),
])->then(function (Batch $batch) {
    // Всі завдання виконано успішно...
})->catch(function (Batch $batch, Throwable $e) {
    // Виявлено першу помилку партійного завдання...
})->finally(function (Batch $batch) {
    // Партія завершила виконання...
})->dispatch();

return $batch->id;
```

Ідентифікатор партії, доступ до якого можна отримати через властивість $batch->id, можна використовувати для [запита командної шини Laravel](#inspecting-batches) щодо інформації про партію після відправки.

> **Warning**  
> Оскільки замикання серіалізуються і виконуються пізніше чергою Laravel, вам не слід використовувати змінну `$this` в замиканнях.

<a name="naming-batches"></a>

#### Найменування партій

Деякі інструменти, такі як Laravel Horizon і Laravel Telescope, можуть надавати більш зручну інформацію для налагодження піртій, якщо партії мають імена. Щоб призначити піртії довільне ім’я, ви можете викликати метод `name` під час визначення піртії:

```php
$batch = Bus::batch([
    // ...
])->then(function (Batch $batch) {
    // Всі завдання виконано успішно...
})->name('Import CSV')->dispatch();
```

<a name="batch-connection-queue"></a>

#### Партійне підключення та черга

Якщо ви хочете вказати підключення та чергу, які мають використовуватися для партійних завдань, ви можете використовувати методи `onConnection` and `onQueue`. Всі партійні завдання мають виконуватися в одному підключенні та черзі:

```php
$batch = Bus::batch([
    // ...
])->then(function (Batch $batch) {
    // Всі завдання виконано успішно...
})->onConnection('redis')->onQueue('imports')->dispatch();
```

<a name="chains-within-batches"></a>

#### Ланцюжки завданнь в середені партій

Ви можете визначити набір [ланцюжкових завдань](#job-chaining) у партії, помістивши ланцюжкові завдання в масив. Наприклад, ми можемо виконати два ланцюжки завдань паралельно та виконати зворотний виклик, коли обидва ланцюжки завдань завершили виконання:

```php
use App\Jobs\ReleasePodcast;
use App\Jobs\SendPodcastReleaseNotification;
use Illuminate\Bus\Batch;
use Illuminate\Support\Facades\Bus;

Bus::batch([
    [
        new ReleasePodcast(1),
        new SendPodcastReleaseNotification(1),
    ],
    [
        new ReleasePodcast(2),
        new SendPodcastReleaseNotification(2),
    ],
])->then(function (Batch $batch) {
    // ...
})->dispatch();
```

<a name="adding-jobs-to-batches"></a>

### Додавання завдань до партій

Іноді може бути корисно додати додаткові завдання в партію, безпосередньо із завдання, яке вже знаходиться в партії. Цей шаблон може бути корисним, коли вам потрібно групувати тисячі завдань, відправлення яких може зайняти надто багато часу під час веб-запита. Отже, натомість ви можете відправити початкову партію завдань «завантажувачу», які доповнюватимуть партію ще більшою кількістю завдань:

```php
$batch = Bus::batch([
    new LoadImportBatch,
    new LoadImportBatch,
    new LoadImportBatch,
])->then(function (Batch $batch) {
    // Всі завдання виконано успішно...
})->name('Import Contacts')->dispatch();
```

У цьому прикладі ми будемо використовувати завдання `LoadImportBatch` для доповнення партії додатковими завданнями. Щоб досягти цього, ми можемо використати метод `add` для партійного екземпляра, до якого можна отримати доступ через метод `batch` завдання:

```php
use App\Jobs\ImportContacts;
use Illuminate\Support\Collection;

/**
 * Виконати завдання
 *
 * @return void
 */
public function handle()
{
    if ($this->batch()->cancelled()) {
        return;
    }

    $this->batch()->add(Collection::times(1000, function () {
        return new ImportContacts;
    }));
}
```

> **Warning**  
> Ви можете додавати завдання до партії лише з завдання, яке належить до тої самої партії.

<a name="inspecting-batches"></a>

### Перевірка партій

Екземпляр `Illuminate\Bus\Batch`, який надається для зворотних викликів партійного завершення, має низку властивостей і методів, які допоможуть вам взаємодіяти з заданою партією завдань і перевіряти її:

```php
// UUID партії ...
$batch->id;

// Назва партії (якщо є)...
$batch->name;

// Кількість завдань, призначених партії...
$batch->totalJobs;

// Кількість завдань, які не були виконані чергою...
$batch->pendingJobs;

// Кількість невдалих завдань...
$batch->failedJobs;

// Кількість завдань, виконаних на даний момент...
$batch->processedJobs();

// Відсоток виконання партії (0-100)...
$batch->progress();

// Вказує, чи партія завершила виконання...
$batch->finished();

// Скасувати виконання партії...
$batch->cancel();

// Вказує, чи партія була скасована...
$batch->cancelled();
```

<a name="returning-batches-from-routes"></a>

#### Повернення партій з маршрутів

Всі екземпляри `Illuminate\Bus\Batch` можна серіалізувати в JSON, тобто ви можете повернути їх безпосередньо з одного з маршрутів вашого додатка, щоб отримати корисне навантаження JSON, який містить інформацію про партію, включаючи прогрес його завершення. Це дозволяє зручно відображати інформацію про хід виконання партії в інтерфейсі користувача вашого додатка.

Щоб отримати партію за її ідентифікатором, ви можете використати метод `findBatch` фасада `Bus`:

```php
use Illuminate\Support\Facades\Bus;
use Illuminate\Support\Facades\Route;

Route::get('/batch/{batchId}', function (string $batchId) {
    return Bus::findBatch($batchId);
});
```

<a name="cancelling-batches"></a>

### Скасування партій

Іноді вам може знадобитися скасувати виконання певної партії. Це можна зробити, викликавши метод `cancel` в екземплярі `Illuminate\Bus\Batch`:

```php
/**
 * Виконайте завдання.
 *
 * @return void
 */
public function handle()
{
    if ($this->user->exceedsImportLimit()) {
        return $this->batch()->cancel();
    }

    if ($this->batch()->cancelled()) {
        return;
    }
}
```

Як ви могли помітити в попередніх прикладах, партійні завдання зазвичай повинні перевіряти, чи не було скасовано пакет на початку їх метода `handle`:

```php
/**
 * Виконати завдання
 *
 * @return void
 */
public function handle()
{
    if ($this->batch()->cancelled()) {
        return;
    }

    // Продовжити виконання...
}
```

<a name="batch-failures"></a>

### Невдачі у партії завдань

Коли партійне завдання завершується невдачею, буде викликано зворотний виклик `catch` (якщо його призначено). Цей зворотній виклик викликається лише для першого завдання, яке завершилося помилкою в партії.

<a name="allowing-failures"></a>

#### Дозволені невдачі

Якщо завдання у партії не вдається, Laravel автоматично позначає пакет як «скасований». Якщо ви бажаєте, ви можете вимкнути цю поведінку, щоб помилка завдання не позначала пакет автоматично як скасований. Це можна зробити, викликавши метод `allowFailures` під час відправки партії:

```php
$batch = Bus::batch([
    // ...
])->then(function (Batch $batch) {
    // Всі завдання виконано успішно...
})->allowFailures()->dispatch();
```

<a name="retrying-failed-batch-jobs"></a>

#### Повторна спроба невдалих партійних завдань

Для зручності Laravel надає команду `queue:retry-batch` Artisan, яка дозволяє легко повторити всі невдалі завдання для даної партії. Команда `queue:retry-batch` приймає UUID партії, чиї невдалі завдання слід повторити:

```shell
php artisan queue:retry-batch 32dbc76c-4f82-4749-b610-a639fe0099b5
```

<a name="pruning-batches"></a>

### Очищення партій

Без очищення таблиця `job_batches`, може дуже швидко накопичувати записи. Щоб уникнути цього, вам слід [запланувати](scheduling.md) щоденний запуск команди `queue:prune-batches` Artisan:

```php
$schedule->command('queue:prune-batches')->daily();
```

За замовчуванням всі завершені партії, яким більше 24 годин, будуть видалені. Ви можете використовувати параметр `hours` під час виклика команди, щоб визначити, як довго зберігати партійні дані. Наприклад, наступна команда видалить всі партії, завершені понад 48 годин тому:

```php
$schedule->command('queue:prune-batches --hours=48')->daily();
```

Іноді ваша таблиця `jobs_batches` може накопичувати партійні записи для партій, які ніколи не завершувалися успішно, наприклад, патрії, у яких завдання не вдалося виконати, і це завдання ніколи не було успішно виконано. Ви можете вказати команді `queue:prune-batches` видалити ці незавершені партійні записи за допомогою параметра `unfinished`:

```php
$schedule->command('queue:prune-batches --hours=48 --unfinished=72')->daily();
```

<a name="queueing-closures"></a>

## Анонімні черги

Замість того, щоб відправляти клас завдання в чергу, ви також можете відправити замикання. Це чудово підходить для швидких простих завдань, які потрібно виконати поза поточним циклом запита. Під час надсилання замикання до черги вміст коду замикання підписується криптографічно, щоб його не можна було змінити під час передачі:

```php
$podcast = App\Podcast::find(1);

dispatch(function () use ($podcast) {
    $podcast->publish();
});
```

Використовуючи метод `catch`, ви можете надати замикання, яке слід виконати, якщо замикання в черзі не завершиться успішно після того, як вичерпано всі [налаштовані повторні спроби](#max-job-attempts-and-timeout) вашої черги:

```php
use Throwable;

dispatch(function () use ($podcast) {
    $podcast->publish();
})->catch(function (Throwable $e) {
    // Це завдання було невдалим...
});
```

<a name="running-the-queue-worker"></a>

## Запуск виконавця черги

<a name="the-queue-work-command"></a>

### Команда `queue:work`

Laravel містить команду Artisan, яка запускає виконавця черги та виконує нові завдання, щойно вони надходять до черги. Ви можете запустити виконавця за допомогою команди `queue:work` Artisan. Зауважте, що після запуску команди `queue:work` вона продовжуватиме працювати, доки її не буде зупинено вручну або ви не закриєте термінал:

```shell
php artisan queue:work
```

> **Note**  
> Щоб процес `queue:work` постійно працював у фоновому режимі, вам слід використовувати монітор процесу, наприклад [Supervisor](#supervisor-configuration), щоб бути впевненим, що виконавць черги не припиняє роботу.

Пам’ятайте, що виконавці черги є довготривалими процесами та зберігають стан завантаженого додатка в пам’яті. Як наслідок, вони не помітять змін у вашій кодовій базі після того, як їх запустять. Отже, під час процесу розгортання обов’язково перезапустіть виконавців черги. Крім того, пам’ятайте, що будь-який статичний стан, створений або змінений вашим додатком, не буде автоматично скинутий між завданнями.

Крім того, ви можете запустити команду `queue:listen`. Використовуючи команду `queue:listen`, вам не доведеться вручну перезапускати виконавця, коли ви хочете перезавантажити оновлений код або скинути стан додатка; однак ця команда значно менш ефективна, ніж команда `queue:listen`:

```shell
php artisan queue:listen
```

<a name="running-multiple-queue-workers"></a>

#### Запуск декількох виконавців черги

Щоб призначити декілька виконавців до черги та виконати завдання одночасно, вам слід просто запустити декілька процесів `queue:work`. Це можна зробити локально за допомогою декількох вкладок у вашому терміналі або у виробництві за допомогою налаштувань конфігурації диспетчера процесів. [Під час використання Supervisor](#supervisor-configuration) ви можете використовувати значення конфігурації `numprocs`.

<a name="specifying-the-connection-queue"></a>

#### Визначення ​​підключення та черги

Ви також можете вказати, яке підключення до черги має використовувати виконавець. Ім’я підключення, передане команді `work`, має відповідати одному з підключень, визначених у вашому конфігураційному файлі `config/queue.php`:

```shell
php artisan queue:work redis
```

За замовчуванням команда `queue:work` виконує лише завдання для черги за замовчуванням у певному підключенні. Однак ви можете ще більше налаштувати свого виконавця черги, виконуючи лише окремі черги для даного підключення. Наприклад, якщо всі ваші електронні листи виконуються в черзі `emails` у вашому підключенні черги `redis`, ви можете ввести таку команду, щоб запустити виконавця, який виконує лише цю чергу:

```shell
php artisan queue:work redis --queue=emails
```

<a name="processing-a-specified-number-of-jobs"></a>

#### Виконання визначеної кількості завдань

Параметр `--once` може бути використаний, щоб вказати виконавцю виконувати лише одне завдання з черги:

```shell
php artisan queue:work --once
```

Параметр `--max-jobs` може бути використаний, щоб вказати виконавцю виконати задану кількість завдань, а потім вийти. Цей параметр може бути корисним у поєднанні з [Supervisor](#supervisor-configuration), щоб ваші бробники автоматично перезапускалися після виконання певної кількості завдань, звільняючи зайняту ними пам’ять, яку вони могли зайняти:

```shell
php artisan queue:work --max-jobs=1000
```

<a name="processing-all-queued-jobs-then-exiting"></a>

#### Виконання всіх завдань у черзі та вихід

Параметр `--stop-when-empty` можна використати, щоб наказати виконавцю виконати всі завдання, а потім вийти. Цей параметр може бути корисним під час виконання черг Laravel у контейнері Docker, якщо ви хочете вимкнути контейнер після того, як черга спорожніє:

```shell
php artisan queue:work --stop-when-empty
```

<a name="processing-jobs-for-a-given-number-of-seconds"></a>

#### Виконання завдань протягом заданої кількості секунд

Параметр `--max-time` можна використовувати, щоб наказати виконавцю виконувати завдання протягом заданої кількості секунд, а потім вийти. Цей параметр може бути корисним у поєднанні з [Supervisor](#supervisor-configuration), щоб ваші виконавці автоматично перезапускалися після виконання завдань протягом заданого проміжку часу, звільняючи всю пам’ять, яку вони могли зайняти:

```shell
# Виконувати завдання протягом однієї години, а потім вийти...
php artisan queue:work --max-time=3600
```

<a name="worker-sleep-duration"></a>

#### Тривалість сну виконавця

Коли завдання доступні в черзі, виконавць продовжить виконання завдань без затримок між ними. Однак параметр `sleep` визначає, скільки секунд виконавець буде «спати», якщо немає нових доступних завдань. Під час сну виконавць не виконуватиме нові завдання – завдання будуть виконані після того, як працівник знову прокинеться.

```shell
php artisan queue:work --sleep=3
```

<a name="resource-considerations"></a>

#### Міркування щодо ресурсів

Демон виконавця черги не «перезавантажує» фреймворк перед виконанням кожного завдання. Тому ви повинні звільняти будь-які важкі ресурси після завершення кожного завдання. Тому ви повинні звільняти будь-які важкі ресурси після завершення кожного завдання. Наприклад, якщо ви виконуєте маніпуляції із зображеннями за допомогою бібліотеки GD, вам слід звільнити пам’ять за допомогою `imagedestroy` після завершення виконання зображення.

<a name="queue-priorities"></a>

### Пріорітети черги

Іноді вам може знадобитися визначити пріоритетність виконання ваших черг. Наприклад, у вашому конфігураційному файлі `config/queue.php` ви можете встановити `queue` за замовчуванням для підключення `redis` як `low`. Однак інколи ви можете помістити завдання до черги з `high` пріоритетом, наприклад:

```php
dispatch((new Job)->onQueue('high'));
```

Щоб запустити виконавця, який перевіряє, чи всі завдання `high` черги виконано перед тим, як продовжити будь-які завдання `low` черги, передайте команді `work` список імен черги, розділених комами:

```shell
php artisan queue:work --queue=high,low
```

<a name="queue-workers-and-deployment"></a>

### Виконавці черги та розгортання

Оскільки виконавці черги є довготривалими процесами, вони не помітять змін у вашому коді без перезапуска. Отже, найпростіший спосіб розгорнути додаток за допомогою черги — це перезапустити виконавця під час процесу розгортання. Ви можете коректно перезапустити всіх виконавців, виконавши команду `queue:restart`:

```shell
php artisan queue:restart
```

Ця команда накаже всім виконавцям черги коректно вийти після того, як вони завершать виконання свого поточного завдання, щоб не втратити існуючі завдання. Оскільки виконавці черги завершать роботу, коли буде виконано команду `queue:restart`, вам слід запустити менеджер процесів, наприклад [Supervisor](#supervisor-configuration), щоб автоматично перезапустити виконавців черги.

> **Note**  
> Черга використовує [кеш](cache.md) для зберігання сигналів перезапуску, тому перед використанням цієї функції слід переконатися, що драйвер кеша правильно налаштовано для вашого додатка.

<a name="job-expirations-and-timeouts"></a>

### Термін дії та тайм-аути завдань

<a name="job-expiration"></a>

#### Job Expiration

У вашому конфігураційному файлі `config/queue.php` кожне підключення до черги визначає параметр `retry_after`. Цей параметр визначає, скільки секунд підключення черги має чекати перед повторною спробою виконати завдання, яке виконується. Наприклад, якщо для параметра `retry_after` встановлено значення `90`, завдання буде повернуто до черги, якщо воно виконувалося протягом 90 секунд без звільнення чи видалення. Як правило, для значення `retry_after` слід встановити максимальну кількість секунд для завершення виконання ваших завдань.

> **Warning**  
> Єдиним підключенням черги, яке не містить значення `retry_after`, є Amazon SQS. SQS повторить спробу завдання на основі [тайм-ауту видимості за замовчуванням](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/AboutVT.html), яким керують у консолі AWS.

<a name="worker-timeouts"></a>

#### Тайм-аути виконавця

Команда `queue:work` Artisan надає опцію `--timeout`. За замовчуванням значення `--timeout` становить 60 секунд. Якщо завдання виконується довше, ніж кількість секунд, визначені значенням тайм-ауту, бробник, який виконує завдання, завершить роботу з помилкою. Як правило, виконавця буде автоматично перезапущено [менеджером процесів, налаштованим на вашому сервері](#supervisor-configuration):

```shell
php artisan queue:work --timeout=60
```

Параметр конфігурації `retry_after` і параметр командного рядка `--timeout` відрізняються, але працюють разом, щоб гарантувати, що завдання не буде втрачено і що завдання будуть успішно виконані лише один раз.

> **Warning**  
> Значення `--timeout` завжди має бути принаймні на кілька секунд коротшим за значення конфігурації `retry_after`. Це гарантує, що виконавець, який виконує заморожену роботу, завжди завершується перед повторною спробою завдання. Якщо параметр `--timeout` довший за значення конфігурації `retry_after`, ваші завдання можуть бути виконані двічі.

<a name="supervisor-configuration"></a>

## Конфігурація супервізора

В оточенні "production" вам потрібен спосіб підтримувати процеси `queue:work` у робочому стані. Процес `queue:work` може припинити роботу з різних причин, наприклад, перевищено робочий час очікування або виконання команди `queue:work`.

З цієї причини вам потрібно налаштувати монітор процесів, який може виявляти, коли ваші процеси `queue:work` завершуються, і автоматично їх перезапускати. Крім того, монітори процесів можуть дозволити вам вказати, скільки процесів `queue:work` ви хочете запускати одночасно. Supervisor — це монітор процесів, який зазвичай використовується в середовищах Linux, і ми обговоримо, як його налаштувати, у наведеній нижче документації.

<a name="installing-supervisor"></a>

#### Встановлення Supervisor

Supervisor — це монітор процесів для операційної системи Linux, який автоматично перезапустить ваші `queue:work` процеси, якщо вони вийдуть з ладу. Щоб інсталювати Supervisor на Ubuntu, ви можете використати таку команду:

```shell
sudo apt-get install supervisor
```

> **Note**  
> Якщо самостійне налаштування та керування Supervisor звучить надто складно, подумайте про використання [Laravel Forge](https://forge.laravel.com), який автоматично встановить і налаштує Supervisor для ваших робочих проектів Laravel.

<a name="configuring-supervisor"></a>

#### Налаштування Supervisor

Файли конфігурації Supervisor зазвичай зберігаються в каталозі `/etc/supervisor/conf.d`. У цьому каталозі ви можете створити будь-яку кількість конфігураційних файлів, які вказують Supervisor, як слід контролювати ваші процеси. Наприклад, давайте створимо файл `laravel-worker.conf`, який запускає та відстежує процеси `queue:work`:

```ini
[program:laravel-worker]
process_name=%(program_name)s_%(process_num)02d
command=php /home/forge/app.com/artisan queue:work sqs --sleep=3 --tries=3 --max-time=3600
autostart=true
autorestart=true
stopasgroup=true
killasgroup=true
user=forge
numprocs=8
redirect_stderr=true
stdout_logfile=/home/forge/app.com/worker.log
stopwaitsecs=3600
```

У цьому прикладі директива `numprocs` вкаже Supervisor запустити вісім процесів `queue:work і всі їх контролювати, автоматично перезапускаючи їх у разі збою. Ви повинні змінити директиву `command` конфігурації, щоб відобразити бажане підключення до черги та параметри робітника.

> **Warning**  
> Ви повинні переконатися, що значення `stopwaitsecs` є більшим за кількість секунд, які споживає ваша найтриваліша робота. В іншому випадку Supervisor може припинити роботу до завершення її обробки.

<a name="starting-supervisor"></a>

#### Запуск Supervisor

Після створення файлу конфігурації ви можете оновити конфігурацію Supervisor і запустити процеси за допомогою таких команд:

```shell
sudo supervisorctl reread

sudo supervisorctl update

sudo supervisorctl start laravel-worker:*
```

Для отримання додаткової інформації про Supervisor зверніться до [документації Supervisor](http://supervisord.org/index.html).

<a name="dealing-with-failed-jobs"></a>

## Робота з невдалими завданнями

Іноді ваші завдання в черзі не вдаються. Не хвилюйтеся, не завжди все йде за планом! Laravel містить зручний [спосіб вказати максимальну кількість спроб виконання завдання](#max-job-attempts-and-timeout). Після того як асинхронне завдання перевищить цю кількість спроб, воно буде вставлено в таблицю бази даних `failed_jobs`. [Синхронно надіслані завдання](queues.md#synchronous-dispatching), які вийшли з ладу, не зберігаються в цій таблиці, і їх винятки негайно обробляються додатком.

Міграція для створення таблиці `failed_jobs` зазвичай вже присутня в нових додатках Laravel. Однак, якщо ваш додаток не містить міграції для цієї таблиці, ви можете використати команду `queue:failed-table`, щоб створити міграцію:

```shell
php artisan queue:failed-table

php artisan migrate
```

Під час запуску [виконавця черги](#running-the-queue-worker) ви можете вказати максимальну кількість спроб виконання завдання за допомогою перемикача `--tries` у команді queue:work. Якщо ви не вкажете значення параметра `--tries`, завдання буде виконано лише один раз або стільки разів, скільки вказано у властивістю `$tries` класа завдань:

```shell
php artisan queue:work redis --tries=3
```

Використовуючи параметр `--backoff`, ви можете вказати, скільки секунд Laravel повинен чекати перед повторною спробою виконання завдання, яке зіткнулося з винятком. За замовчуванням завдання негайно повертається до черги, щоб його можна було повторити:

```shell
php artisan queue:work redis --tries=3 --backoff=3
```

Якщо ви хочете налаштувати, скільки секунд Laravel повинен чекати перед повторною спробою виконання кожного із завдань, для якого виник виняток, ви можете зробити це, визначивши властивість `backoff` у своєму класі завдання:

```php
/**
 * Кількість секунд очікування перед повторною спробою завдання.
 *
 * @var int
 */
public $backoff = 3;
```

Якщо вам потрібна складніша логіка для визначення часу відкладення завдань, ви можете визначити метод `backoff` для свого класу завдань:

```php
/**
* Обчисліть кількість секунд очікування перед повторним виконанням завдання.
*
* @return int
*/
public function backoff()
{
    return 3;
}
```

Ви можете легко налаштувати "експоненціальні" відкладення, повернувши масив значень відкладень із метода `backoff`. У цьому прикладі затримка повторної спроби становитиме 1 секунду для першої спроби, 5 секунд для другої спроби та 10 секунд для третьої спроби:

```php
    /**
    * Обчисліть кількість секунд очікування перед повторним виконанням завдання.
    *
    * @return array
    */
    public function backoff()
    {
        return [1, 5, 10];
    }
```

<a name="cleaning-up-after-failed-jobs"></a>

### Прибирання після невдалих завдань

Коли конкретне завдання не вдається, ви можете надіслати сповіщення своїм користувачам або скасувати будь-які дії, які були частково виконані завданням. Щоб досягти цього, ви можете визначити `failed` метод у своєму класі завдань. Екземпляр `Throwable`, який спричинив збій завдання, буде передано `failed` методу:

```php
<?php

namespace App\Jobs;

use App\Models\Podcast;
use App\Services\AudioProcessor;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Throwable;

class ProcessPodcast implements ShouldQueue
{
    use InteractsWithQueue, Queueable, SerializesModels;

    /**
     * Екземпляр подкасту.
     *
     * @var \App\Podcast
     */
    public $podcast;

    /**
     * Створіть новий екземпляр завдання.
     *
     * @param  \App\Models\Podcast  $podcast
     * @return void
     */
    public function __construct(Podcast $podcast)
    {
        $this->podcast = $podcast;
    }

    /**
     * Виконати завдання.
     *
     * @param  \App\Services\AudioProcessor  $processor
     * @return void
     */
    public function handle(AudioProcessor $processor)
    {
        // Виконання завантаженого подкаста...
    }

    /**
     * Опрацювати невдале завдання.
     *
     * @param  \Throwable  $exception
     * @return void
     */
    public function failed(Throwable $exception)
    {
        // Надіслати сповіщення користувачу про помилку, тощо......
    }
}
```

> **Warning**
> Новий екземпляр завдання створюється перед викликом метода `failed` ; отже, будь-які модифікації властивостей класа, які могли статися в межах метода `handle`, будуть втрачені.

<a name="retrying-failed-jobs"></a>

### Повторна спроба невдалих завдань

Щоб переглянути всі невдалі завдання, які були вставлені у вашу таблицю бази даних `failed_jobs`, ви можете використати команду `queue:failed` Artisan:

```shell
php artisan queue:failed
```

Команда `queue:failed` містить ідентифікатор завдання, підключення, чергу, час помилки та іншу інформацію про завдання. Ідентифікатор завдання можна використовувати для повторної спроби невдалого завдання. Наприклад, щоб повторити невдале завдання з ідентифікатором `ce7bb17c-cdd8-41f0-a8ec-7b4fef4e5ece`, виконайте наступну команду:

```shell
php artisan queue:retry ce7bb17c-cdd8-41f0-a8ec-7b4fef4e5ece
```

Якщо необхідно, ви можете передати декілька ідентифікаторів команді:

```shell
php artisan queue:retry ce7bb17c-cdd8-41f0-a8ec-7b4fef4e5ece 91401d2c-0784-4f43-824c-34f94a33c24d
```

Ви також можете повторити всі невдалі завдання для певної черги:

```shell
php artisan queue:retry --queue=name
```

Щоб повторити всі невдалі завдання, виконайте команду `queue:retry` і передайте `all` замість ID:

```shell
php artisan queue:retry all
```

Якщо ви хочете видалити невдале завдання, ви можете скористатися командою `queue:forget`:

```shell
php artisan queue:forget 91401d2c-0784-4f43-824c-34f94a33c24d
```

> **Note**  
> Під час використання [Horizon](horizon.md) вам слід використовувати команду `horizon:forget`, щоб видалити невдале завдання замість команди `queue:forget`

Щоб видалити всі невдалі завдання з таблиці `failed_jobs`, ви можете використати команду `queue:flush`:

```shell
php artisan queue:flush
```

<a name="ignoring-missing-models"></a>

### Ігнорування відсутніх моделей

Під час введення моделі Eloquent у завдання, модель автоматично серіалізується перед тим, як розміститися у черзі, і повторно вилучається з бази даних під час виконання завдання. Однак, якщо модель було видалено, коли завдання чекало на виконання, то ваше завдання може завершитися помилкою з `ModelNotFoundException`.

Для зручності ви можете обрати автоматичне видалення завдань з відсутніми моделями, встановивши для властивості `deleteWhenMissingModels` значення `true`. Якщо для цієї властивості встановлено значення `true`, Laravel тихо відмінить завдання, не викликаючи винятка:

```php
/**
 * Видалити завдання, якщо ця модель більше не існує.
 *
 * @var bool
 */
public $deleteWhenMissingModels = true;
```

<a name="pruning-failed-jobs"></a>

### Очищення невдалих завдань

Ви можете видалити всі записи в таблиці `failed_jobs` вашого додатка, викликавши команду `queue:prune-failed` Artisan:

```shell
php artisan queue:prune-failed
```

If you provide the `--hours` option to the command, only the failed job records that were inserted within the last N number of hours will be retained. For example, the following command will delete all of the failed job records that were inserted more than 48 hours ago:

```shell
php artisan queue:prune-failed --hours=48
```

<a name="storing-failed-jobs-in-dynamodb"></a>

### Збереження невдалих завдань DynamoDB

Такоє Laravel надає підтримку для збереження ваших записів невдалих завдань у [DynamoDB](https://aws.amazon.com/dynamodb) замість таблиці реляційної бази даних. Однак ви повинні створити таблицю DynamoDB для зберігання всіх записів невдалих завдань. Як правило, ця таблиця має називатися `failed_jobs`, але ви повинні називати таблицю на основі значення конфігурації `queue.failed.table` у файлі конфігурації черги вашого додатка.

Таблиця `failed_jobs` повинна мати рядковий первинний ключ розділу з іменем `application` і рядковий первинний ключ сортування з іменем `uuid`. Частина ключа `application` міститиме ім’я додатка, як визначено значенням `name` конфігураційного файла `app` вашого додатка. Оскільки назва додатка є частиною ключа таблиці DynamoDB, ви можете використовувати ту саму таблицю для зберігання невдалих завдань для кількох додатків Laravel.

Крім того, переконайтеся, що ви встановили AWS SDK, щоб ваш додаток Laravel міг спілкуватися з Amazon DynamoDB:

```shell
composer require aws/aws-sdk-php
```

Далі встановіть для параметра конфігурації `queue.failed.driver` значення `dynamodb`. Крім того, ви повинні визначити параметри конфігурації `key`, `secret`, and `region` в масиві конфігурації невдалого завдання. Ці параметри використовуватимуться для автентифікації за допомогою AWS. Під час використання драйвера `dynamodb` параметр конфігурації `queue.failed.database` непотрібний:

```php
'failed' => [
    'driver' => env('QUEUE_FAILED_DRIVER', 'dynamodb'),
    'key' => env('AWS_ACCESS_KEY_ID'),
    'secret' => env('AWS_SECRET_ACCESS_KEY'),
    'region' => env('AWS_DEFAULT_REGION', 'us-east-1'),
    'table' => 'failed_jobs',
],
```

<a name="disabling-failed-job-storage"></a>

### Вимкнення збереження невдалих завдань

Ви можете вказати Laravel відхиляти невдалі завдання, не зберігаючи їх, встановивши значення параметра конфігурації `queue.failed.driver` на `null`. Як правило, це можна зробити за допомогою змінної середовища `QUEUE_FAILED_DRIVER`:

```ini
QUEUE_FAILED_DRIVER=null
```

<a name="failed-job-events"></a>

### Події невдалих завдань

Якщо ви бажаєте зареєструвати слухача подій, який буде викликаний у разі збою завдання, ви можете використати метод `failing` фасада `Queue`. Наприклад, ми можемо додати замикання до цієї події з метода `boot` постачальника `AppServiceProvider`, який включено до Laravel:

```php
<?php

namespace App\Providers;

use Illuminate\Support\Facades\Queue;
use Illuminate\Support\ServiceProvider;
use Illuminate\Queue\Events\JobFailed;

class AppServiceProvider extends ServiceProvider
{
    /**
     * Реєстрація буь-яких сервісів додатка.
     *
     * @return void
     */
    public function register()
    {
        //
    }

    /**
     * Завантажте будь-які служби додатків.
     *
     * @return void
     */
    public function boot()
    {
        Queue::failing(function (JobFailed $event) {
            // $event->connectionName
            // $event->job
            // $event->exception
        });
    }
}
```

<a name="clearing-jobs-from-queues"></a>

## Видалення завдань з черг

> **Note**  
> Під час використання [Horizon](horizon) вам слід використовувати команду `horizon:clear`, щоб очистити завдання з черги замість команди `queue:clear`.

Якщо ви бажаєте видалити всі завдання з черги стандартного підключення, ви можете зробити це за допомогою команди `queue:clear` Artisan:

```shell
php artisan queue:clear
```

Ви також можете надати аргумент `connection` та параметр `queue`, щоб видалити завдання з певного підключення та черги:

```shell
php artisan queue:clear redis --queue=emails
```

> **Warning**  
> Очищення завдань із черг доступне лише для драйверів черги SQS, Redis і бази даних. Крім того, процес видалення повідомлення SQS займає до 60 секунд, тому завдання, надіслані до черги SQS протягом 60 секунд після очищення черги, також можуть бути видалені.

<a name="monitoring-your-queues"></a>

## Моніторинг ваших черг

Якщо ваша черга отримує раптовий наплив завдань, вона може переповнитися, що призведе до тривалого часу очікування виконання завдань. Якщо ви бажаєте, Laravel може повідомити вас, коли кількість завдань у черзі перевищує вказане порогове значення.

Щоб почати, вам слід запланувати виконання команди `queue:monitor` [щохвилини](scheduling.md). Команда приймає назви черг, які ви бажаєте відстежувати, а також бажане порогове значення кількості завдань:

```shell
php artisan queue:monitor redis:default,redis:deployments --max=100
```

Одного лише планування цієї команди недостатньо, щоб викликати повідомлення про переповнений статус черги. Коли команда зустрічається з чергою, у якій кількість завдань перевищує порогове значення, буде відправлено подію `Illuminate\Queue\Events\QueueBusy`. Ви можете прослухати цю подію в `EventServiceProvider` вашого додатка, щоб надіслати повідомлення вам або вашій команді розробників:

```php
use App\Notifications\QueueHasLongWaitTime;
use Illuminate\Queue\Events\QueueBusy;
use Illuminate\Support\Facades\Event;
use Illuminate\Support\Facades\Notification;

/**
 * Зареєструйте будь-які інші події для вашого додатка.
 *
 * @return void
 */
public function boot()
{
    Event::listen(function (QueueBusy $event) {
        Notification::route('mail', 'dev@example.com')
            ->notify(new QueueHasLongWaitTime(
                $event->connection,
                $event->queue,
                $event->size
            ));
    });
}
```

<a name="job-events"></a>

## Події завдань

Використовуючи методи `before` and `after` [фасада](facades.md) `Queue`, ви можете вказати зворотні виклики, які мають виконуватися до або після виконання завдання в черзі. Ці зворотні виклики є чудовою можливістю для додаткової реєстрації або збільшення статистики для мониторингової панелі. Як правило, ви повинні викликати ці методи з метода `boot` [постачальника послуг](providers.md). Наприклад, ми можемо використовувати `AppServiceProvider`, який входить до складу Laravel:

```php
<?php

namespace App\Providers;

use Illuminate\Support\Facades\Queue;
use Illuminate\Support\ServiceProvider;
use Illuminate\Queue\Events\JobProcessed;
use Illuminate\Queue\Events\JobProcessing;

class AppServiceProvider extends ServiceProvider
{
    /**
     * Зареєструйте будь-які сервіси додатка.
     *
     * @return void
     */
    public function register()
    {
        //
    }

    /**
     * Завантажте будь-які служби додатка.
     *
     * @return void
     */
    public function boot()
    {
        Queue::before(function (JobProcessing $event) {
            // $event->connectionName
            // $event->job
            // $event->job->payload()
        });

        Queue::after(function (JobProcessed $event) {
            // $event->connectionName
            // $event->job
            // $event->job->payload()
        });
    }
}
```

Використовуючи `looping` метод [фасада](facades.md) `Queue`, ви можете вказати зворотні виклики, який виконуються до того, як виконавець спробує отримати завдання з черги. Наприклад, ви можете зареєструвати замикання, щоб повернути будь-які транзакції, які залишелися відкритими через невдалу роботу:

```php
    use Illuminate\Support\Facades\DB;
    use Illuminate\Support\Facades\Queue;

    Queue::looping(function () {
        while (DB::transactionLevel() > 0) {
            DB::rollBack();
        }
    });
```
